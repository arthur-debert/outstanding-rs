<!DOCTYPE HTML>
<html lang="en" class="rust" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Standout</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="A CLI framework for Rust that enforces separation between logic and presentation">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="assets/version-banner.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('rust')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index.html">Introduction</a></li><li class="chapter-item affix "><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">Getting Started</li><li class="chapter-item "><a href="guides/tldr-intro-to-standout.html"><strong aria-hidden="true">1.</strong> Quick Start</a></li><li class="chapter-item "><a href="guides/intro-to-standout.html"><strong aria-hidden="true">2.</strong> Introduction to Standout</a></li><li class="chapter-item affix "><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">Rendering (standout-render)</li><li class="chapter-item "><a href="crates/render/guides/intro-to-rendering.html"><strong aria-hidden="true">3.</strong> Introduction to Rendering</a></li><li class="chapter-item "><a href="crates/render/guides/intro-to-tabular.html"><strong aria-hidden="true">4.</strong> Introduction to Tabular</a></li><li class="chapter-item "><a href="crates/render/topics/styling-system.html"><strong aria-hidden="true">5.</strong> Styling System</a></li><li class="chapter-item "><a href="crates/render/topics/templating.html"><strong aria-hidden="true">6.</strong> Templating</a></li><li class="chapter-item "><a href="crates/render/topics/file-system-resources.html"><strong aria-hidden="true">7.</strong> File System Resources</a></li><li class="chapter-item affix "><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">Dispatch (standout-dispatch)</li><li class="chapter-item "><a href="crates/dispatch/guides/intro-to-dispatch.html"><strong aria-hidden="true">8.</strong> Introduction to Dispatch</a></li><li class="chapter-item "><a href="crates/dispatch/topics/handler-contract.html"><strong aria-hidden="true">9.</strong> Handler Contract</a></li><li class="chapter-item "><a href="crates/dispatch/topics/execution-model.html"><strong aria-hidden="true">10.</strong> Execution Model</a></li><li class="chapter-item "><a href="crates/dispatch/topics/partial-adoption.html"><strong aria-hidden="true">11.</strong> Partial Adoption</a></li><li class="chapter-item affix "><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">Framework Topics</li><li class="chapter-item "><a href="topics/output-modes.html"><strong aria-hidden="true">12.</strong> Output Modes</a></li><li class="chapter-item "><a href="topics/app-configuration.html"><strong aria-hidden="true">13.</strong> App Configuration</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Standout</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/arthur-debert/standout" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="standout"><a class="header" href="#standout">Standout</a></h1>
<p><strong>Test your data. Render your view.</strong></p>
<p>Standout is a CLI framework for Rust that enforces separation between logic and presentation. Your handlers return structs, not strings—making CLI logic as testable as any other code.</p>
<h2 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h2>
<p>CLI code that mixes logic with <code>println!</code> statements is impossible to unit test:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// You can't unit test this—it writes directly to stdout
fn list_command(show_all: bool) {
    let todos = storage::list().unwrap();
    println!("Your Todos:");
    for todo in todos.iter() {
        if show_all || todo.status == Status::Pending {
            println!("  {} {}", if todo.done { "[x]" } else { "[ ]" }, todo.title);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The only way to test this is regex on captured stdout. That's fragile, verbose, and couples your tests to presentation details.</p>
<h2 id="the-solution"><a class="header" href="#the-solution">The Solution</a></h2>
<p>With Standout, handlers return data. The framework handles rendering:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This is unit-testable—it's a pure function that returns data
fn list_handler(matches: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;TodoResult&gt; {
    let show_all = matches.get_flag("all");
    let todos = storage::list()?
        .into_iter()
        .filter(|t| show_all || t.status == Status::Pending)
        .collect();
    Ok(Output::Render(TodoResult { todos }))
}

#[test]
fn test_list_filters_completed() {
    let matches = /* mock ArgMatches with all=false */;
    let result = list_handler(&amp;matches, &amp;ctx).unwrap();
    assert!(result.todos.iter().all(|t| t.status == Status::Pending));
}
<span class="boring">}</span></code></pre></pre>
<p>Because your logic returns a struct, you test the struct. No stdout capture, no regex, no brittleness.</p>
<h2 id="standing-out"><a class="header" href="#standing-out">Standing Out</a></h2>
<p>What Standout provides:</p>
<ul>
<li>Enforced architecture splitting data and presentation</li>
<li>Logic is testable as any Rust code</li>
<li>Boilerplateless: declaratively link your handlers to command names and templates, Standout handles the rest</li>
<li>Autodispatch: save keystrokes with auto dispatch from the known command tree</li>
<li>Free <a href="topics/output-modes.html">output handling</a>: rich terminal with graceful degradation, plus structured data (JSON, YAML, CSV)</li>
<li>Finely crafted output:
<ul>
<li>File-based <a href="crates/render/topics/templating.html">templates</a> for content and CSS for styling</li>
<li>Rich styling with <a href="crates/render/topics/styling-system.html">adaptive properties</a> (light/dark modes), inheritance, and full theming</li>
<li>Powerful templating through <a href="https://github.com/mitsuhiko/minijinja">MiniJinja</a>, including partials (reusable, smaller templates for models displayed in multiple places)</li>
<li><a href="crates/render/topics/file-system-resources.html">Hot reload</a>: changes to templates and styles don't require compiling</li>
<li>Declarative layout support for <a href="crates/render/guides/intro-to-tabular.html">tabular data</a></li>
</ul>
</li>
</ul>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<h3 id="1-define-your-commands-and-handlers"><a class="header" href="#1-define-your-commands-and-handlers">1. Define Your Commands and Handlers</a></h3>
<p>Use the <code>Dispatch</code> derive macro to connect commands to handlers. Handlers receive parsed arguments and return serializable data.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout::cli::{Dispatch, CommandContext, HandlerResult, Output};
use clap::{ArgMatches, Subcommand};
use serde::Serialize;

#[derive(Subcommand, Dispatch)]
#[dispatch(handlers = handlers)]  // handlers are in the `handlers` module
pub enum Commands {
    List,
    Add { title: String },
}

#[derive(Serialize)]
struct TodoResult {
    todos: Vec&lt;Todo&gt;,
}

mod handlers {
    use super::*;

    // HandlerResult&lt;T&gt; wraps your data; Output::Render tells Standout to render it
    pub fn list(_m: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;TodoResult&gt; {
        let todos = storage::list()?;
        Ok(Output::Render(TodoResult { todos }))
    }

    pub fn add(m: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;TodoResult&gt; {
        let title: &amp;String = m.get_one("title").unwrap();
        let todo = storage::add(title)?;
        Ok(Output::Render(TodoResult { todos: vec![todo] }))
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-define-your-presentation"><a class="header" href="#2-define-your-presentation">2. Define Your Presentation</a></h3>
<p>Templates use MiniJinja with semantic style tags. Styles are defined separately in CSS or YAML.</p>
<pre><code class="language-jinja">{# list.jinja #}
[title]My Todos[/title]
{% for todo in todos %}
  - {{ todo.title }} ([status]{{ todo.status }}[/status])
{% endfor %}
</code></pre>
<pre><code class="language-css">/* styles/default.css */
.title { color: cyan; font-weight: bold; }
.status { color: yellow; }
</code></pre>
<h3 id="3-wire-it-up"><a class="header" href="#3-wire-it-up">3. Wire It Up</a></h3>
<pre><pre class="playground"><code class="language-rust">use standout::cli::App;
use standout::{embed_templates, embed_styles};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = App::builder()
        .commands(Commands::dispatch_config())  // Register handlers from derive macro
        .templates(embed_templates!("src/templates"))
        .styles(embed_styles!("src/styles"))
        .build()?;

    app.run(Cli::command(), std::env::args());
    Ok(())
}</code></pre></pre>
<p>Run it:</p>
<pre><code class="language-bash">myapp list              # Rich terminal output with colors
myapp list --output json    # JSON for scripting
myapp list --output yaml    # YAML for config files
myapp list --output text    # Plain text, no ANSI codes
</code></pre>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<h3 id="architecture"><a class="header" href="#architecture">Architecture</a></h3>
<ul>
<li>Logic/presentation separation enforced by design</li>
<li>Handlers return data; framework handles rendering</li>
<li>Unit-testable CLI logic without stdout capture</li>
</ul>
<h3 id="output-modes"><a class="header" href="#output-modes">Output Modes</a></h3>
<ul>
<li>Rich terminal output with colors and styles</li>
<li>Automatic JSON, YAML, CSV serialization from the same handler</li>
<li>Graceful degradation when terminal lacks capabilities</li>
</ul>
<h3 id="rendering"><a class="header" href="#rendering">Rendering</a></h3>
<ul>
<li><a href="https://github.com/mitsuhiko/minijinja">MiniJinja</a> templates with semantic style tags</li>
<li>CSS or YAML stylesheets with light/dark mode support</li>
<li>Hot reload during development—edit templates without recompiling</li>
<li>Tabular layouts with alignment, truncation, and Unicode support</li>
</ul>
<h3 id="integration"><a class="header" href="#integration">Integration</a></h3>
<ul>
<li>Clap integration with automatic dispatch</li>
<li>Declarative command registration via derive macros</li>
</ul>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<pre><code class="language-bash">cargo add standout
</code></pre>
<h2 id="migrating-an-existing-cli"><a class="header" href="#migrating-an-existing-cli">Migrating an Existing CLI</a></h2>
<p>Already have a CLI? Standout supports incremental adoption. Standout handles matched commands automatically; unmatched commands return <code>ArgMatches</code> for your existing dispatch:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(matches) = app.run(Cli::command(), std::env::args()) {
    // Standout didn't handle this command, fall back to legacy
    your_existing_dispatch(matches);
}
<span class="boring">}</span></code></pre></pre>
<p>See the <a href="crates/dispatch/topics/partial-adoption.html">Partial Adoption Guide</a> for the full migration path.</p>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ul>
<li><strong><a href="guides/intro-to-standout.html">Introduction to Standout</a></strong> — Adopting Standout in a working CLI. Start here.</li>
<li><a href="crates/render/guides/intro-to-rendering.html">Introduction to Rendering</a> — Creating polished terminal output</li>
<li><a href="crates/render/guides/intro-to-tabular.html">Introduction to Tabular</a> — Building aligned, readable tabular layouts</li>
<li><a href="topics/index.html">All Topics</a> — In-depth documentation for specific systems</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fast-paced-intro-to-your-first-standout-based-command"><a class="header" href="#fast-paced-intro-to-your-first-standout-based-command">Fast Paced intro to your First Standout Based Command</a></h1>
<p>This is a terse and direct how to for more experienced developers or at least the ones in a hurry.
It skimps rationale, design and other useful bits you can read from the <a href="guides/intro-to-standout.html">longer form version</a></p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>A cli app, that uses clap for arg parsing.
A command function that is pure logic, that is, returns the result, and does not print to stdout or format output.</p>
<p>For this guide's purpose we'll use a fictitious "list" command of our todo list manager</p>
<h2 id="the-core-a-pure-function-logic-handler"><a class="header" href="#the-core-a-pure-function-logic-handler">The Core: A pure function logic handler</a></h2>
<p>The logic handler: receives parsed cli args, and returns a serializable data structure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn list(matches: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;TodoResult&gt; {}
<span class="boring">}</span></code></pre></pre>
<h2 id="making-it-outstanding"><a class="header" href="#making-it-outstanding">Making it outstanding</a></h2>
<h3 id="1-the-file-system"><a class="header" href="#1-the-file-system">1. The File System</a></h3>
<p>Create a templates/list.jinja and styles/default.css:</p>
<pre><code class="language-text">    src/
        ├── handlers.rs         # where list it
        ├── templates/          # standout will match templates name against rel. paths from temp root, here
            ├── list.jinja      # the template to render list, name matched against the command name
        ├── styles/             #  likewise for themes, this sets a theme called "default"
            ├── default.css     # the default style for the command, filename will be the theme name
</code></pre>
<h3 id="2-define-your-styles"><a class="header" href="#2-define-your-styles">2. Define your styles</a></h3>
<pre><code class="language-css">    .done {
        text-decoration: line-through;
        color: gray;
    }
    .pending {
        font-weight: bold;
        color: white;
    }
    .index {
        color: yellow;
    }
</code></pre>
<h3 id="3-write-your-template"><a class="header" href="#3-write-your-template">3. Write your template</a></h3>
<pre><code class="language-Jinja">    {% if message %}
        [message]{{ message }} [/message]
    {% endif %}
    {% for todo in todos %}
        [index]{{ loop.index }}.[/index] [{{ todo.status }}]{{ todo.title }}[/{{ todo.status }}]
    {% endfor %}
</code></pre>
<h3 id="4-putting-it-all-together"><a class="header" href="#4-putting-it-all-together">4. Putting it all together</a></h3>
<p>Configure the app:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let app = App::builder()
        .templates(embed_templates!("src/templates"))    //  Sets the root template path, hot reload for dev, embedded in release
        .styles(embed_styles!("src/styles"))                       //  Likewise the styles root
        .default_theme("default")                                       // Use styles/default.css or default.yaml
        .commands(Commands::dispatch_config())          // Register handlers from derive macro
    .build()?;
<span class="boring">}</span></code></pre></pre>
<p>Connect your logic to a command name and template :</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[dispatch(handlers = handlers)]
    pub enum Commands {
          ...
          list,
    }
<span class="boring">}</span></code></pre></pre>
<p>And finally, run in main, the autodispatcher:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    match app.run(Cli::command(), std::env::args()) {
        // If you've got other commands on vanilla manual dispatch, call it for unported commands
        RunResult::NoMatch(matches) =&gt; legacy_dispatch(matches),  // Your existing handler
    }
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standout-how-to"><a class="header" href="#standout-how-to">Standout How To</a></h1>
<p>This is a small, focused guide for adopting Standout in a working shell application. Each step is self-sufficient, takes a positive step towards a sane CLI design, and can be incrementally merged. This can be done for one command (probably a good idea), then replicated to as many as you'd like.</p>
<p>Note that only 2 out of 8 steps are Standout related. The others are generally good practices and clear designs for maintainable shell programs. This is not an accident, as Standout's goal is to allow your app to keep a great structure effortlessly, while providing testability, rich and fast output design, and more.</p>
<p>For explanation's sake, we will show a hypothetical list command for tdoo, a todo list manager.</p>
<p><strong>See Also:</strong></p>
<ul>
<li><a href="guides/../crates/dispatch/topics/handler-contract.html">Handler Contract</a> - detailed handler API</li>
<li><a href="guides/../crates/render/topics/styling-system.html">Styling System</a> - themes and styles in depth</li>
<li><a href="guides/../topics/output-modes.html">Output Modes</a> - all output format options</li>
<li><a href="guides/../crates/dispatch/topics/partial-adoption.html">Partial Adoption</a> - migrating incrementally</li>
</ul>
<h2 id="1-start-the-argument-parsing"><a class="header" href="#1-start-the-argument-parsing">1. Start: The Argument Parsing</a></h2>
<p>Arg parsing is insanely intricate and deceptively simple. In case you are not already: define your application's interface with clap. Nothing else is worth doing until you have a sane starting point.</p>
<p>If you don't have clap set up yet, here's a minimal starting point:</p>
<pre><pre class="playground"><code class="language-rust">use clap::{Parser, Subcommand};

#[derive(Parser)]
#[command(name = "tdoo")]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// List all todos
    List {
        #[arg(short, long)]
        all: bool,
    },
    /// Add a new todo
    Add {
        title: String,
    },
}

fn main() {
    let cli = Cli::parse();
    match cli.command {
        Commands::List { all } =&gt; list_command(all),
        Commands::Add { title } =&gt; add_command(&amp;title),
    }
}</code></pre></pre>
<p>(If you are using a non-clap-compatible crate, for now, you'd have to write an adapter for clap.)</p>
<blockquote>
<p><strong>Verify:</strong> Run <code>cargo build</code> - it should compile without errors.</p>
</blockquote>
<h2 id="2-hard-split-logic-and-formatting"><a class="header" href="#2-hard-split-logic-and-formatting">2. Hard Split Logic and Formatting</a></h2>
<p>Now, your command should be split into two functions: the logic handler and its rendering. Don't worry about the specifics, do the straightest path from your current code.</p>
<p>This is the one key step, the key design rule. And that's not because Standout requires it, rather the other way around: Standout is designed on top of it, and keeping it separate and easy to iterate on both logic and presentation under this design is Standout's key value.</p>
<p>If your CLI is in good shape this will be a small task, otherwise you may find yourself patching together print statements everywhere, tidying up the data model and centralizing the processing. The silver lining here being: if it takes considerable work, there will be considerable gain in doing so.</p>
<p><strong>Before</strong> (tangled logic and output):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn list_command(show_all: bool) {
    let todos = storage::list().unwrap();
    println!("Your Todos:");
    println!("-----------");
    for (i, todo) in todos.iter().enumerate() {
        if show_all || todo.status == Status::Pending {
            let marker = if todo.status == Status::Done { "[x]" } else { "[ ]" };
            println!("{}. {} {}", i + 1, marker, todo.title);
        }
    }
    if todos.is_empty() {
        println!("No todos yet!");
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>After</strong> (clean separation):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use clap::ArgMatches;

// Data types for your domain
#[derive(Clone)]
pub enum Status { Pending, Done }

#[derive(Clone)]
pub struct Todo {
    pub title: String,
    pub status: Status,
}

pub struct TodoResult {
    pub message: Option&lt;String&gt;,
    pub todos: Vec&lt;Todo&gt;,
}

// This is your core logic handler, receiving parsed clap args
// and returning a pure Rust data type.
//
// Note: This example uses immutable references. If your handler needs
// mutable state (&amp;mut self), see the "Mutable Handlers" section below.
pub fn list(matches: &amp;ArgMatches) -&gt; TodoResult {
    let show_done = matches.get_flag("all");
    let todos = storage::list().unwrap();

    let filtered: Vec&lt;Todo&gt; = if show_done {
        todos
    } else {
        todos.into_iter()
            .filter(|t| matches!(t.status, Status::Pending))
            .collect()
    };

    TodoResult {
        message: None,
        todos: filtered,
    }
}

// This will take the Rust data type and print the result to stdout
pub fn render_list(result: TodoResult) {
    if let Some(msg) = result.message {
        println!("{}", msg);
    }
    for (i, todo) in result.todos.iter().enumerate() {
        let status = match todo.status {
            Status::Done =&gt; "[x]",
            Status::Pending =&gt; "[ ]",
        };
        println!("{}. {} {}", i + 1, status, todo.title);
    }
}

// And the orchestrator:
pub fn list_command(matches: &amp;ArgMatches) {
    render_list(list(matches))
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Verify:</strong> Run <code>cargo build</code> and then <code>tdoo list</code> - output should look identical to before.</p>
</blockquote>
<h3 id="intermezzo-a-milestone---logic-and-presentation-split"><a class="header" href="#intermezzo-a-milestone---logic-and-presentation-split">Intermezzo A: Milestone - Logic and Presentation Split</a></h3>
<p><strong>What you achieved:</strong> Your command logic is now a pure function that returns data.
<strong>What's now possible:</strong></p>
<ul>
<li>All of your app's logic can be unit tested as any code, from the logic inwards.</li>
<li>You can test by feeding input strings and verifying your logic handler gets called with the right parameters.</li>
<li>The rendering can also be tested by feeding data inputs and matching outputs (though this is brittle).</li>
</ul>
<p><strong>What's next:</strong> Making the return type serializable for automatic JSON/YAML output.
<strong>Your files now:</strong></p>
<pre><code class="language-text">src/
├── main.rs          # clap setup + orchestrators
├── handlers.rs      # list(), add() - pure logic
└── render.rs        # render_list(), render_add() - output formatting
</code></pre>
<h2 id="3-fine-tune-the-logic-handlers-return-type"><a class="header" href="#3-fine-tune-the-logic-handlers-return-type">3. Fine Tune the Logic Handler's Return Type</a></h2>
<p>While any data type works, Standout's renderer takes a generic type that must implement <code>Serialize</code>. This enables automatic JSON/YAML output modes and template rendering through MiniJinja's context system. This is likely a small change, and beneficial as a baseline for logic results that will simplify writing renderers later.</p>
<p>Add serde to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
serde = { version = "1", features = ["derive"] }
</code></pre>
<p>Update your types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::Serialize;

#[derive(Clone, Serialize)]
#[serde(rename_all = "lowercase")]
pub enum Status { Pending, Done }

#[derive(Clone, Serialize)]
pub struct Todo {
    pub title: String,
    pub status: Status,
}

#[derive(Serialize)]
pub struct TodoResult {
    pub message: Option&lt;String&gt;,
    pub todos: Vec&lt;Todo&gt;,
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Verify:</strong> Run <code>cargo build</code> - it should compile without errors.</p>
</blockquote>
<h2 id="4-replace-imperative-print-statements-with-a-template"><a class="header" href="#4-replace-imperative-print-statements-with-a-template">4. Replace Imperative Print Statements With a Template</a></h2>
<p>Reading a template of an output next to the substituting variables is much easier to reason about than scattered prints, string concats and the like.</p>
<p>This step is optional - if your current output is simple, you can skip to step 5. If you want an intermediate checkpoint, use Rust's format strings:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn render_list(result: TodoResult) {
    let output = format!(
        "{header}\n{todos}",
        header = result.message.unwrap_or_default(),
        todos = result.todos.iter().enumerate()
            .map(|(i, t)| format!("{}. [{}] {}", i + 1, t.status, t.title))
            .collect::&lt;Vec&lt;_&gt;&gt;()
            .join("\n")
    );
    println!("{}", output);
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Verify:</strong> Run <code>tdoo list</code> - output should still work.</p>
</blockquote>
<h2 id="5-use-a-minijinja-template-string"><a class="header" href="#5-use-a-minijinja-template-string">5. Use a MiniJinja Template String</a></h2>
<p>Rewrite your <code>std::fmt</code> or imperative prints into a MiniJinja template string, and add minijinja to your crate. If you're not familiar with it, it's a Rust implementation of Jinja, pretty much a de-facto standard for more complex templates.</p>
<p><strong>Resources:</strong></p>
<ul>
<li><a href="https://docs.rs/minijinja">MiniJinja docs</a></li>
<li><a href="https://jinja.palletsprojects.com/en/3.1.x/templates/">Jinja syntax reference</a></li>
</ul>
<p>Add minijinja to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
minijinja = "2"
</code></pre>
<p>And then you call render in MiniJinja, passing the template string and the data to use. So now your rendering function looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn render_list(result: TodoResult) {
    let output_tmpl = r#"
{% if message %}
    {{ message }}
{% endif %}
{% for todo in todos %}
    {{ loop.index }}. [{{ todo.status }}] {{ todo.title }}
{% endfor %}
"#;

    let env = minijinja::Environment::new();
    let tmpl = env.template_from_str(output_tmpl).unwrap();
    let output = tmpl.render(&amp;result).unwrap();
    println!("{}", output);
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Verify:</strong> Run <code>tdoo list</code> - output should match (formatting may differ slightly).</p>
</blockquote>
<h2 id="6-use-a-dedicated-template-file"><a class="header" href="#6-use-a-dedicated-template-file">6. Use a Dedicated Template File</a></h2>
<p>Now, move the template content into a file (say <code>src/templates/list.jinja</code>), and load it in the rendering module. Dedicated files have several advantages: triggering editor/IDE support for the file type, more descriptive diffs, less risk of breaking the code/build and, in the event that you have less technical people helping out with the UI, a much cleaner and simpler way for them to contribute.</p>
<p>Create <code>src/templates/list.jinja</code>:</p>
<pre><code class="language-jinja">{% if message %}{{ message }} {% endif %}
{% for todo in todos %}
    {{ loop.index }}. [{{ todo.status }}] {{ todo.title }}
{% endfor %}
</code></pre>
<p>Update your render function to load from file:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn render_list(result: TodoResult) {
    let template_content = include_str!("templates/list.jinja");
    let env = minijinja::Environment::new();
    let tmpl = env.template_from_str(template_content).unwrap();
    let output = tmpl.render(&amp;result).unwrap();
    println!("{}", output);
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Verify:</strong> Run <code>tdoo list</code> - output should be identical.</p>
</blockquote>
<h3 id="intermezzo-b-declarative-output-definition"><a class="header" href="#intermezzo-b-declarative-output-definition">Intermezzo B: Declarative Output Definition</a></h3>
<p><strong>What you achieved:</strong> Output is now defined declaratively in a template file, separate from Rust code.
<strong>What's now possible:</strong></p>
<ul>
<li>Edit templates without recompiling (with minor changes to loading)</li>
<li>Non-Rust developers can contribute to UI</li>
<li>Clear separation in code reviews: "is this a logic change or display change?"</li>
<li>Use partials, filters, and macros for complex outputs (see <a href="guides/../crates/render/topics/templating.html">Templating</a>)</li>
</ul>
<p><strong>What's next:</strong> Hooking up Standout for automatic dispatch and rich output.
Also, notice we've yet to do anything Standout-specific. This is not a coincidence—the framework is designed around this pattern, making testability, fast iteration, and rich features natural outcomes of the architecture.
<strong>Your files now:</strong></p>
<pre><code class="language-text">src/
├── main.rs
├── handlers.rs
├── render.rs
└── templates/
    └── list.jinja
</code></pre>
<h2 id="7-standout-offload-the-handler-orchestration"><a class="header" href="#7-standout-offload-the-handler-orchestration">7. Standout: Offload the Handler Orchestration</a></h2>
<p>And now the Standout-specific bits finally show up.</p>
<h3 id="71-add-standout-to-your-cargotoml"><a class="header" href="#71-add-standout-to-your-cargotoml">7.1 Add Standout to your Cargo.toml</a></h3>
<pre><code class="language-toml">[dependencies]
standout = "2"
</code></pre>
<blockquote>
<p><strong>Verify:</strong> Run <code>cargo build</code> - dependencies should download and compile.</p>
</blockquote>
<h3 id="72-create-the-commands-enum-with-dispatch"><a class="header" href="#72-create-the-commands-enum-with-dispatch">7.2 Create the Commands enum with Dispatch</a></h3>
<p>Annotate your commands enum with the Dispatch derive macro. This tells Standout that the "list" command should be dispatched to the <code>list</code> handler. That's all Standout needs to know, and now it can manage the execution.</p>
<p>See <a href="guides/../crates/dispatch/topics/handler-contract.html">Handler Contract</a> for full handler API details.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout::cli::{Dispatch, CommandContext, HandlerResult, Output};
use clap::{ArgMatches, Subcommand};

// Define your commands enum with the Dispatch derive
#[derive(Subcommand, Dispatch)]
#[dispatch(handlers = handlers)]
pub enum Commands {
    List,
    Add,
}

// Your handlers module
mod handlers {
    use super::*;

    pub fn list(_matches: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;TodoResult&gt; {
        let todos = storage::list()?;
        Ok(Output::Render(TodoResult {
            message: None,
            todos,
        }))
    }

    pub fn add(matches: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;TodoResult&gt; {
        let title: &amp;String = matches.get_one("title").unwrap();
        let todo = storage::add(title)?;
        Ok(Output::Render(TodoResult {
            message: Some(format!("Added: {}", title)),
            todos: vec![todo],
        }))
    }
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Verify:</strong> Run <code>cargo build</code> - it should compile without errors.</p>
</blockquote>
<h3 id="73-configure-appbuilder"><a class="header" href="#73-configure-appbuilder">7.3 Configure AppBuilder</a></h3>
<p>Use AppBuilder to configure your app. Instantiate the builder, add the path for your templates. See <a href="guides/../topics/app-configuration.html">App Configuration</a> for all configuration options.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout::cli::App;
use standout::{embed_templates, embed_styles};

let app = App::builder()
    .templates(embed_templates!("src/templates"))   // Embeds all .jinja/.j2 files
    .commands(Commands::dispatch_config())          // Register handlers from derive macro
    .build()?;
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Verify:</strong> Run <code>cargo build</code> - it should compile without errors.</p>
</blockquote>
<h3 id="74-wire-up-main"><a class="header" href="#74-wire-up-main">7.4 Wire up main()</a></h3>
<p>The final bit: handling the dispatching off to Standout:</p>
<pre><pre class="playground"><code class="language-rust">use standout::cli::App;
use standout::embed_templates;

fn main() -&gt; anyhow::Result&lt;()&gt; {
    let app = App::builder()
        .templates(embed_templates!("src/templates"))
        .commands(Commands::dispatch_config())
        .build()?;

    // Run with auto dispatch - handles parsing and execution
    app.run(Cli::command(), std::env::args());
    Ok(())
}</code></pre></pre>
<p>If your app has other clap commands that are not managed by Standout, check for unhandled commands. See <a href="guides/../crates/dispatch/topics/partial-adoption.html">Partial Adoption</a> for details on incremental migration.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(matches) = app.run(Cli::command(), std::env::args()) {
    // Standout didn't handle this command, fall back to legacy
    legacy_dispatch(matches);
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Verify:</strong> Run <code>tdoo list</code> - it should work as before.
<strong>Verify:</strong> Run <code>tdoo list --output json</code> - you should get JSON output for free!</p>
</blockquote>
<p>And now you can remove the boilerplate: the orchestrator (<code>list_command</code>) and the rendering (<code>render_list</code>). You're pretty much at global optima: a single line of derive macro links your app logic to a command name, a few lines configure Standout, and auto dispatch handles all the boilerplate.</p>
<p>For the next commands you'd wish to migrate, this is even simpler. Say you have a "create" logic handler: add a "create.jinja" to that template dir, add the derive macro for the create function and that is it. By default the macro will match the command's name to the handlers and to the template files, but you can change these and map explicitly to your heart's content.</p>
<h3 id="intermezzo-c-welcome-to-standout"><a class="header" href="#intermezzo-c-welcome-to-standout">Intermezzo C: Welcome to Standout</a></h3>
<p><strong>What you achieved:</strong> Full dispatch pipeline with zero boilerplate.</p>
<p><strong>What's now possible:</strong></p>
<ul>
<li>Alter the template and re-run your CLI, without compilation, and the new template will be used</li>
<li>Your CLI just got multiple output modes via <code>--output</code> (see <a href="guides/../topics/output-modes.html">Output Modes</a>):
<ul>
<li><strong>term</strong>: rich shell formatting (more about this on the next step)</li>
<li><strong>term-debug</strong>: print formatting info for testing/debugging</li>
<li><strong>text</strong>: plain text, no styling</li>
<li><strong>auto</strong>: the default, rich term that degrades gracefully</li>
<li><strong>json, csv, yaml</strong>: automatic serialization of your data</li>
</ul>
</li>
</ul>
<p><strong>What's next:</strong> Adding rich styling to make the output beautiful.</p>
<p><strong>Your files now:</strong></p>
<pre><code class="language-text">src/
├── main.rs              # App::builder() setup
├── commands.rs          # Commands enum with #[derive(Dispatch)]
├── handlers.rs          # list(), add() returning HandlerResult
└── templates/
    ├── list.jinja
    └── add.jinja
</code></pre>
<h2 id="8-make-the-output-awesome"><a class="header" href="#8-make-the-output-awesome">8. Make the Output Awesome</a></h2>
<p>Let's transform that mono-typed, monochrome string into a richer and more useful UI. Borrowing from web apps setup, we keep the content in a template file, and we define styles in a stylesheet file.</p>
<p>See <a href="guides/../crates/render/topics/styling-system.html">Styling System</a> for full styling documentation.</p>
<h3 id="81-create-the-stylesheet"><a class="header" href="#81-create-the-stylesheet">8.1 Create the stylesheet</a></h3>
<p>Create <code>src/styles/default.css</code>:</p>
<pre><code class="language-css">/* Styles for completed todos */
.done {
    text-decoration: line-through;
    color: gray;
}

/* Style for todo index numbers */
.index {
    color: yellow;
}

/* Style for pending todos */
.pending {
    font-weight: bold;
    color: white;
}

/* Adaptive style for messages */
.message {
    color: cyan;
}

@media (prefers-color-scheme: light) {
    .pending { color: black; }
}

@media (prefers-color-scheme: dark) {
    .pending { color: white; }
}
</code></pre>
<p>Or if you prefer YAML (<code>src/styles/default.yaml</code>):</p>
<pre><code class="language-yaml">done: strikethrough, gray
index: yellow
pending:
  bold: true
  fg: white
  light:
    fg: black
  dark:
    fg: white
message: cyan
</code></pre>
<blockquote>
<p><strong>Verify:</strong> The file exists at <code>src/styles/default.css</code> or <code>src/styles/default.yaml</code>.</p>
</blockquote>
<h3 id="82-add-style-tags-to-your-template"><a class="header" href="#82-add-style-tags-to-your-template">8.2 Add style tags to your template</a></h3>
<p>Update <code>src/templates/list.jinja</code> with style tags:</p>
<pre><code class="language-jinja">{% if message %}[message]{{ message }}[/message]
{% endif %}
{% for todo in todos %}
[index]{{ loop.index }}.[/index] [{{ todo.status }}]{{ todo.title }}[/{{ todo.status }}]
{% endfor %}
</code></pre>
<p>The style tags use BBCode-like syntax: <code>[style-name]content[/style-name]</code></p>
<p>Notice how we use <code>[{{ todo.status }}]</code> dynamically - if <code>todo.status</code> is "done", it applies the <code>.done</code> style; if it's "pending", it applies the <code>.pending</code> style.</p>
<blockquote>
<p><strong>Verify:</strong> The template file is updated.</p>
</blockquote>
<h3 id="83-wire-up-styles-in-appbuilder"><a class="header" href="#83-wire-up-styles-in-appbuilder">8.3 Wire up styles in AppBuilder</a></h3>
<p>Add the styles to your app builder:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let app = App::builder()
    .templates(embed_templates!("src/templates"))
    .styles(embed_styles!("src/styles"))       // Load stylesheets
    .default_theme("default")                  // Use styles/default.css or default.yaml
    .commands(Commands::dispatch_config())
    .build()?;
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Verify:</strong> Run <code>cargo build</code> - it should compile without errors.
<strong>Verify:</strong> Run <code>tdoo list</code> - you should see colored, styled output!
<strong>Verify:</strong> Run <code>tdoo list --output text</code> - plain text, no colors.</p>
</blockquote>
<p>Now you're leveraging the core rendering design of Standout:</p>
<ul>
<li>File-based templates for content, and stylesheets for styles</li>
<li>Custom template syntax with BBCode for markup styles <code>[style][/style]</code></li>
<li>Live reload: iterate through content and styling without recompiling</li>
</ul>
<h3 id="intermezzo-d-the-full-setup-is-done"><a class="header" href="#intermezzo-d-the-full-setup-is-done">Intermezzo D: The Full Setup Is Done</a></h3>
<p><strong>What you achieved:</strong> A fully styled, testable, multi-format CLI.</p>
<p><strong>What's now possible:</strong></p>
<ul>
<li>Rich terminal output with colors, bold, strikethrough</li>
<li>Automatic light/dark mode adaptation</li>
<li>JSON/YAML/CSV output for scripting and testing</li>
<li>Hot reload of templates and styles during development</li>
<li>Unit testable logic handlers</li>
</ul>
<p><strong>Your final files:</strong></p>
<pre><code class="language-text">src/
├── main.rs              # App::builder() setup
├── commands.rs          # Commands enum with #[derive(Dispatch)]
├── handlers.rs          # list(), add() returning HandlerResult
├── templates/
│   ├── list.jinja       # with [style] tags
│   └── add.jinja
└── styles/
    └── default.css      # or default.yaml
</code></pre>
<p>For brevity's sake, we've ignored a bunch of finer and relevant points:</p>
<ul>
<li>The derive macros can set name mapping explicitly: <code>#[dispatch(handler = custom_fn, template = "custom.jinja")]</code></li>
<li>There are pre-dispatch, post-dispatch and post-render hooks (see <a href="guides/../crates/dispatch/topics/execution-model.html">Execution Model</a>)</li>
<li>Standout exposes its primitives as standalone crates (see <a href="guides/../crates/render/guides/intro-to-rendering.html">standout-render</a>, <a href="guides/../crates/dispatch/guides/intro-to-dispatch.html">standout-dispatch</a>)</li>
<li>Powerful tabular layouts via the <code>col</code> filter (see <a href="guides/../crates/render/guides/intro-to-tabular.html">Tabular Layout</a>)</li>
<li>A help topics system for rich documentation (see <a href="guides/../topics/topics-system.html">Topics System</a>)</li>
</ul>
<p>Aside from exposing the library primitives, Standout leverages best-in-breed crates like MiniJinja and console::Style under the hood. The lock-in is really negligible: you can use Standout's BB parser or swap it, manually dispatch handlers, and use the renderers directly in your clap dispatch.</p>
<h2 id="mutable-handlers-localapp"><a class="header" href="#mutable-handlers-localapp">Mutable Handlers (LocalApp)</a></h2>
<p>If your application logic uses <code>&amp;mut self</code> methods—common with database connections, file caches, or in-memory indices—you can use <code>LocalApp</code> instead of <code>App</code>:</p>
<pre><pre class="playground"><code class="language-rust">use standout::cli::{LocalApp, Output};
use standout::embed_templates;

struct PadStore {
    index: HashMap&lt;Uuid, Metadata&gt;,
}

impl PadStore {
    fn complete(&amp;mut self, id: Uuid) -&gt; Result&lt;()&gt; {
        // This needs &amp;mut self
        self.index.get_mut(&amp;id).unwrap().completed = true;
        Ok(())
    }
}

fn main() -&gt; anyhow::Result&lt;()&gt; {
    let mut store = PadStore::load()?;

    LocalApp::builder()
        .templates(embed_templates!("src/templates"))
        .command("complete", |m, ctx| {
            let id = m.get_one::&lt;Uuid&gt;("id").unwrap();
            store.complete(*id)?;  // &amp;mut store works!
            Ok(Output::Silent)
        }, "")
        .command("list", |m, ctx| {
            // Even read-only handlers work with LocalApp
            Ok(Output::Render(store.list()))
        }, "{{ items }}")
        .build()?
        .run(Cli::command(), std::env::args());
    Ok(())
}</code></pre></pre>
<p><strong>Key differences from <code>App</code>:</strong></p>
<ul>
<li><code>LocalApp::builder()</code> accepts <code>FnMut</code> closures (not just <code>Fn</code>)</li>
<li>Handlers can capture <code>&amp;mut</code> references to state</li>
<li>No <code>Send + Sync</code> requirement on handlers</li>
<li><code>app.run()</code> takes <code>&amp;mut self</code> instead of <code>&amp;self</code></li>
</ul>
<p>Use <code>LocalApp</code> when:</p>
<ul>
<li>Your API has <code>&amp;mut self</code> methods</li>
<li>You want to avoid <code>Arc&lt;Mutex&lt;_&gt;&gt;</code> wrappers</li>
<li>Your CLI is single-threaded (the common case)</li>
</ul>
<p>See <a href="guides/../crates/dispatch/topics/handler-contract.html">Handler Contract</a> for the full comparison.</p>
<h2 id="appendix-common-errors-and-troubleshooting"><a class="header" href="#appendix-common-errors-and-troubleshooting">Appendix: Common Errors and Troubleshooting</a></h2>
<ul>
<li>Template not found
<ul>
<li><strong>Error:</strong> <code>template 'list' not found</code></li>
<li><strong>Cause:</strong> The template path in <code>embed_templates!</code> doesn't match your file structure.</li>
<li><strong>Fix:</strong> Ensure the path is relative to your <code>Cargo.toml</code>, e.g., <code>embed_templates!("src/templates")</code> and that the file is named <code>list.jinja</code>, <code>list.j2</code>, or <code>list.txt</code>.</li>
</ul>
</li>
<li>Style not applied
<ul>
<li><strong>Symptom:</strong> Text appears but without colors/formatting.</li>
<li><strong>Cause:</strong> Style name in template doesn't match stylesheet.</li>
<li><strong>Fix:</strong> Check that <code>[mystyle]</code> in your template matches <code>.mystyle</code> in CSS or <code>mystyle:</code> in YAML. Run with <code>--output term-debug</code> to see style tag names.</li>
</ul>
</li>
<li>Handler not called
<ul>
<li><strong>Symptom:</strong> Command runs but nothing happens or wrong handler runs.</li>
<li><strong>Cause:</strong> Command name mismatch between clap enum variant and handler function.</li>
<li><strong>Fix:</strong> Ensure enum variant <code>List</code> maps to function <code>handlers::list</code> (snake_case conversion). Or use explicit mapping: <code>#[dispatch(handler = my_custom_handler)]</code></li>
</ul>
</li>
<li>JSON output is empty or wrong
<ul>
<li><strong>Symptom:</strong> <code>--output json</code> produces unexpected results.</li>
<li><strong>Cause:</strong> <code>Serialize</code> derive is missing or field names don't match template expectations.</li>
<li><strong>Fix:</strong> Ensure all types in your result implement <code>Serialize</code>. Use <code>#[serde(rename_all = "lowercase")]</code> for consistent naming.</li>
</ul>
</li>
<li>Styles not loading
<ul>
<li><strong>Error:</strong> <code>theme not found: default</code></li>
<li><strong>Cause:</strong> Stylesheet file missing or wrong path.</li>
<li><strong>Fix:</strong> Ensure <code>src/styles/default.css</code> or <code>default.yaml</code> exists. Check <code>embed_styles!</code> path matches your file structure.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-rendering"><a class="header" href="#introduction-to-rendering">Introduction to Rendering</a></h1>
<p>Terminal outputs have significant limitations: single font, single size, no graphics. But modern terminals provide many facilities like true colors, light/dark mode support, adaptive sizing, and more. Rich, helpful, and clear outputs are within reach.</p>
<p>The development reality explains why such output remains rare. From a primitive syntax born in the 1970s to the scattered ecosystem support, it's been a major effort to craft great outputs—and logically, it rarely makes sense to invest that time.</p>
<p><code>standout-render</code> is designed to make crafting polished outputs a breeze by leveraging ideas, tools, and workflows from web applications—a domain in which rich interface authoring has evolved into the best model we've got. (But none of the JavaScript ecosystem chaos, rest assured.)</p>
<p>In this guide, we'll explore what makes great outputs and how <code>standout-render</code> helps you get there.</p>
<p><strong>See Also:</strong></p>
<ul>
<li><a href="crates/render/guides/../topics/styling-system.html">Styling System</a> - themes, adaptive attributes, CSS syntax</li>
<li><a href="crates/render/guides/../topics/templating.html">Templating</a> - MiniJinja, style tags, processing modes</li>
<li><a href="crates/render/guides/intro-to-tabular.html">Introduction to Tabular</a> - column layouts and tables</li>
</ul>
<hr />
<h2 id="what-polished-output-entails"><a class="header" href="#what-polished-output-entails">What Polished Output Entails</a></h2>
<p>If you're building your CLI in Rust, chances are it's not a throwaway grep-formatting script—if that were the case, nothing beats shells. More likely, your program deals with complex data, logic, and computation, and the full power of Rust matters. In the same way, clear, well-presented, and designed outputs improve your users' experience when parsing that information.</p>
<p>Creating good results depends on discipline, consistency, and above all, experimentation—from exploring options to fine-tuning small details. Unlike code, good layout is experimental and takes many iterations: change, view result, change again, judge the new change, and so on.</p>
<p>The classical setup for shell UIs is anything but conducive to this. All presentation is mixed with code, often with complicated logic, if not coupled to it. Additionally, from escape codes to whitespace handling to spreading visual information across many lines of code, it becomes hard to visualize and change things.</p>
<p>The edit-code-compile-run cycle makes small tweaks take minutes. Sometimes a full hour for a minor change. In that scenario, it's no surprise that people don't bother.</p>
<hr />
<h2 id="our-example-a-report-generator"><a class="header" href="#our-example-a-report-generator">Our Example: A Report Generator</a></h2>
<p>We'll use a simple report generator to demonstrate the rendering layer. Here's our data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::Serialize;

#[derive(Clone, Serialize)]
#[serde(rename_all = "lowercase")]
pub enum Status { Pending, Done }

#[derive(Clone, Serialize)]
pub struct Task {
    pub title: String,
    pub status: Status,
}

#[derive(Serialize)]
pub struct Report {
    pub message: Option&lt;String&gt;,
    pub tasks: Vec&lt;Task&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>Our goal: transform this raw data into polished, readable output that adapts to the terminal, respects user preferences, and takes minutes to iterate on—not hours.</p>
<hr />
<h2 id="the-separation-principle"><a class="header" href="#the-separation-principle">The Separation Principle</a></h2>
<p><code>standout-render</code> is designed around a strict separation of data and presentation. This isn't just architectural nicety—it unlocks a fundamentally better workflow.</p>
<h3 id="without-separation"><a class="header" href="#without-separation">Without Separation</a></h3>
<p>Here's the typical approach, tangling logic and output:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_report(tasks: &amp;[Task]) {
    println!("\x1b[1;36mYour Tasks\x1b[0m");
    println!("──────────");
    for (i, task) in tasks.iter().enumerate() {
        let marker = if matches!(task.status, Status::Done) { "[x]" } else { "[ ]" };
        println!("{}. {} {}", i + 1, marker, task.title);
    }
    println!("\n{} tasks total", tasks.len());
}
<span class="boring">}</span></code></pre></pre>
<p>Problems:</p>
<ul>
<li>Escape codes are cryptic and error-prone</li>
<li>Changes require recompilation</li>
<li>Logic and presentation are intertwined</li>
<li>Testing is brittle</li>
<li>No easy way to support multiple output formats</li>
</ul>
<h3 id="with-separation"><a class="header" href="#with-separation">With Separation</a></h3>
<p>The same output, properly separated:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_render::{render, Theme};
use console::Style;

// Data preparation (your logic layer)
let report = Report {
    message: Some(format!("{} tasks total", tasks.len())),
    tasks,
};

// Theme definition (can be in a separate CSS/YAML file)
let theme = Theme::new()
    .add("title", Style::new().cyan().bold())
    .add("done", Style::new().green())
    .add("pending", Style::new().yellow())
    .add("muted", Style::new().dim());

// Template (can be in a separate .jinja file)
let template = r#"
[title]Your Tasks[/title]
──────────
{% for task in tasks %}
[{{ task.status }}]{{ task.status }}[/{{ task.status }}]  {{ task.title }}
{% endfor %}

{% if message %}[muted]{{ message }}[/muted]{% endif %}
"#;

let output = render(template, &amp;report, &amp;theme)?;
print!("{}", output);
<span class="boring">}</span></code></pre></pre>
<p>Now:</p>
<ul>
<li>Logic is testable without output concerns</li>
<li>Presentation is declarative and readable</li>
<li>Styles are centralized and named semantically</li>
<li>Changes to appearance don't require recompilation (with file-based templates)</li>
</ul>
<hr />
<h2 id="quick-iteration-and-workflow"><a class="header" href="#quick-iteration-and-workflow">Quick Iteration and Workflow</a></h2>
<p>The separation principle enables a radically better workflow. Here's what <code>standout-render</code> provides:</p>
<h3 id="1-file-based-flow"><a class="header" href="#1-file-based-flow">1. File-Based Flow</a></h3>
<p>Dedicated files for templates and styles:</p>
<ul>
<li>Lower risk of breaking code—especially relevant for non-developer types like technical designers</li>
<li>Simpler diffs and easier navigation</li>
<li>Trivial to experiment with variations (duplicate files, swap names)</li>
</ul>
<p><strong>Directory structure:</strong></p>
<pre><code class="language-text">src/
├── main.rs
└── templates/
    └── report.jinja
styles/
└── default.css
</code></pre>
<h3 id="2-hot-live-reload"><a class="header" href="#2-hot-live-reload">2. Hot Live Reload</a></h3>
<p>During development, you edit the template or styles and re-run. No compilation. No long turnaround.</p>
<p>This changes the entire experience. You can make and verify small adjustments in seconds. You can extensively fine-tune output quickly, then polish the full app in a focused session. Time efficiency aside, the quick iterative cycles encourage caring about smaller details, consistency—the things you forgo when iteration is painful.</p>
<p>(When released, files can be compiled into the binary using embedded macros, costing no performance or path-handling headaches in distribution.)</p>
<p>See <a href="crates/render/guides/../topics/file-system-resources.html">File System Resources</a> for details on how hot reload works.</p>
<hr />
<h2 id="best-of-breed-specialized-formats"><a class="header" href="#best-of-breed-specialized-formats">Best-of-Breed Specialized Formats</a></h2>
<h3 id="templates-minijinja"><a class="header" href="#templates-minijinja">Templates: MiniJinja</a></h3>
<p><code>standout-render</code> uses MiniJinja templates—a Rust implementation of Jinja2, a de facto standard for rich and powerful templating. The simple syntax and powerful features let you map template text to actual output much easier than <code>println!</code> spreads.</p>
<pre><code class="language-jinja">{% if message %}[accent]{{ message }}[/accent]{% endif %}

{% for task in tasks %}
[{{ task.status }}]{{ task.status | upper }}[/{{ task.status }}]  {{ task.title }}
{% endfor %}
</code></pre>
<p>Benefits:</p>
<ul>
<li>Simple, readable syntax</li>
<li>Powerful control flow (loops, conditionals, filters)</li>
<li><strong>Partials support</strong>: templates can include other templates, enabling reuse</li>
<li><strong>Custom filters</strong>: for complex presentation needs, write small bits of code and keep templates clean</li>
</ul>
<p>See <a href="crates/render/guides/../topics/templating.html">Templating</a> for template filters and advanced usage.</p>
<h3 id="styles-css-themes"><a class="header" href="#styles-css-themes">Styles: CSS Themes</a></h3>
<p>The styling layer uses CSS files with the familiar syntax you already know, but with simpler semantics tailored for terminals:</p>
<pre><code class="language-css">.title {
    color: cyan;
    font-weight: bold;
}

.done { color: green; }
.blocked { color: red; }
.pending { color: yellow; }

/* Adaptive for light/dark mode */
@media (prefers-color-scheme: light) {
    .panel { color: black; }
}

@media (prefers-color-scheme: dark) {
    .panel { color: white; }
}
</code></pre>
<p>Features:</p>
<ul>
<li><strong>Adaptive attributes</strong>: a style can render different values for light and dark modes</li>
<li><strong>Theming support</strong>: swap the entire visual appearance at once</li>
<li><strong>True color</strong>: RGB values for precise colors (<code>#ff6b35</code> or <code>[255, 107, 53]</code>)</li>
<li><strong>Aliases</strong>: semantic names resolve to visual styles (<code>commit-message: title</code>)</li>
</ul>
<p>YAML syntax is also supported as an alternative. See <a href="crates/render/guides/../topics/styling-system.html">Styling System</a> for complete style options.</p>
<hr />
<h2 id="template-integration-with-styling"><a class="header" href="#template-integration-with-styling">Template Integration with Styling</a></h2>
<p>Styles are applied with BBCode-like syntax: <code>[style]content[/style]</code>. A familiar, simple, and accessible form.</p>
<pre><code class="language-jinja">[title]Your Tasks[/title]
{% for task in tasks %}
[{{ task.status }}]{{ task.title }}[/{{ task.status }}]
{% endfor %}
</code></pre>
<p>Style tags:</p>
<ul>
<li>Nest properly: <code>[outer][inner]text[/inner][/outer]</code></li>
<li>Can span multiple lines</li>
<li>Can contain template logic: <code>[title]{% if x %}{{ x }}{% endif %}[/title]</code></li>
</ul>
<h3 id="output-modes-rich-plain-and-debug"><a class="header" href="#output-modes-rich-plain-and-debug">Output Modes: Rich, Plain, and Debug</a></h3>
<p><code>standout-render</code> processes style tags differently based on the output mode:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_render::{render_with_output, OutputMode};

// Rich terminal output (ANSI codes)
let rich = render_with_output(template, &amp;data, &amp;theme, OutputMode::Term)?;

// Plain text (strips style tags)
let plain = render_with_output(template, &amp;data, &amp;theme, OutputMode::Text)?;

// Debug mode (keeps tags visible)
let debug = render_with_output(template, &amp;data, &amp;theme, OutputMode::TermDebug)?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Single template for rich and plain text.</strong> The same template serves both—no duplication needed.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Auto-detect based on terminal capabilities
let output = render_with_output(template, &amp;data, &amp;theme, OutputMode::Auto)?;
<span class="boring">}</span></code></pre></pre>
<p>In auto mode:</p>
<ul>
<li>TTY with color support → rich output</li>
<li>Pipe or redirect → plain text</li>
</ul>
<blockquote>
<p><strong>For standout framework users:</strong> The framework's <code>--output</code> flag automatically sets the output mode. See the standout documentation for CLI integration.</p>
</blockquote>
<h3 id="debug-mode"><a class="header" href="#debug-mode">Debug Mode</a></h3>
<p>Use <code>OutputMode::TermDebug</code> for debugging:</p>
<pre><code class="language-text">[title]Your Tasks[/title]
[pending]pending[/pending]  Implement auth
[done]done[/done]  Fix tests
</code></pre>
<p>Style tags remain visible, making it easy to verify correct placement. Useful for testing and automation tools.</p>
<hr />
<h2 id="tabular-layout"><a class="header" href="#tabular-layout">Tabular Layout</a></h2>
<p>Many outputs are lists of things—log entries, servers, tasks. These benefit from vertically aligned layouts. Aligning fields seems simple at first, but when you factor in ANSI awareness, flexible size ranges, wrapping behavior, truncation, justification, and expanding cells, it becomes really hard.</p>
<p>Tabular gives you a declarative API, both in Rust and in templates, that handles all of this:</p>
<pre><code class="language-jinja">{% set t = tabular([
    {"name": "index", "width": 4},
    {"name": "status", "width": 10},
    {"name": "title", "width": "fill"}
], separator="  ") %}

{% for task in tasks %}
{{ t.row([loop.index, task.status | style_as(task.status), task.title]) }}
{% endfor %}
</code></pre>
<p>Output adapts to terminal width:</p>
<pre><code class="language-text">1.    pending     Implement user authentication
2.    done        Review pull request #142
3.    pending     Update dependencies
</code></pre>
<p>Features:</p>
<ul>
<li>Fixed, range, fill, and fractional widths</li>
<li>Truncation (start, middle, end) with custom ellipsis</li>
<li>Word wrapping for long content</li>
<li>Per-column styling</li>
<li>Automatic field extraction from structs</li>
</ul>
<p>See <a href="crates/render/guides/intro-to-tabular.html">Introduction to Tabular</a> for a comprehensive walkthrough.</p>
<hr />
<h2 id="structured-output"><a class="header" href="#structured-output">Structured Output</a></h2>
<p>Beyond textual output, <code>standout-render</code> supports structured formats:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_render::{render_auto, OutputMode};

// For Term/Text: renders template
// For Json/Yaml/etc: serializes data directly
let json_output = render_auto(template, &amp;data, &amp;theme, OutputMode::Json)?;
let yaml_output = render_auto(template, &amp;data, &amp;theme, OutputMode::Yaml)?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Structured output for free.</strong> Because your data is <code>Serialize</code>-able, JSON/YAML outputs work automatically. Automation (tests, scripts, other programs) no longer needs to reverse-engineer data from formatted output.</p>
<p>Same data types—different output format. This enables API-like behavior from CLI apps without writing separate code paths.</p>
<hr />
<h2 id="putting-it-all-together"><a class="header" href="#putting-it-all-together">Putting It All Together</a></h2>
<p>Here's a complete example:</p>
<pre><pre class="playground"><code class="language-rust">use standout_render::{render, Theme};
use console::Style;
use serde::Serialize;

#[derive(Clone, Serialize)]
#[serde(rename_all = "lowercase")]
pub enum Status { Pending, Done }

#[derive(Clone, Serialize)]
pub struct Task {
    pub title: String,
    pub status: Status,
}

#[derive(Serialize)]
pub struct Report {
    pub message: Option&lt;String&gt;,
    pub tasks: Vec&lt;Task&gt;,
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let theme = Theme::from_yaml(r#"
        title: { fg: cyan, bold: true }
        done: green
        pending: yellow
        muted: { dim: true }
    "#)?;

    let tasks = vec![
        Task { title: "Implement user authentication".into(), status: Status::Pending },
        Task { title: "Review pull request #142".into(), status: Status::Done },
        Task { title: "Update dependencies".into(), status: Status::Pending },
    ];

    let pending_count = tasks.iter()
        .filter(|t| matches!(t.status, Status::Pending))
        .count();

    let report = Report {
        message: Some(format!("{} pending", pending_count)),
        tasks,
    };

    let template = r#"
[title]My Tasks[/title]

{% for task in tasks %}
{{ loop.index }}.  [{{ task.status }}]{{ task.status }}[/{{ task.status }}]  {{ task.title }}
{% endfor %}

{% if message %}[muted]{{ message }}[/muted]{% endif %}
"#;

    let output = render(template, &amp;report, &amp;theme)?;
    print!("{}", output);
    Ok(())
}</code></pre></pre>
<p><strong>Output (terminal):</strong></p>
<pre><code class="language-text">My Tasks

1.  pending  Implement user authentication
2.  done     Review pull request #142
3.  pending  Update dependencies

2 pending
</code></pre>
<p>With colors, "pending" appears yellow, "done" appears green.</p>
<hr />
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p><code>standout-render</code> transforms CLI output from a chore into a pleasure:</p>
<ol>
<li>
<p><strong>Separation of concerns</strong>: Data stays separate from templates. Templates define structure. Styles control appearance.</p>
</li>
<li>
<p><strong>Fast iteration</strong>: Hot reload means edit-and-see in seconds, not minutes. This changes what's practical.</p>
</li>
<li>
<p><strong>Familiar tools</strong>: MiniJinja for templates (Jinja2 syntax), CSS or YAML for styles. No new languages to learn.</p>
</li>
<li>
<p><strong>Graceful degradation</strong>: One template serves rich terminals, plain pipes, and everything in between.</p>
</li>
<li>
<p><strong>Structured output for free</strong>: JSON, YAML outputs work automatically from your serializable types.</p>
</li>
<li>
<p><strong>Tabular layouts</strong>: Declarative column definitions handle alignment, wrapping, truncation, and ANSI-awareness.</p>
</li>
</ol>
<p>The rendering system makes it practical to care about details. When iteration is fast and changes are safe, polish becomes achievable—not aspirational.</p>
<p>For complete API details, see the <a href="https://docs.rs/standout-render">API documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-tabular"><a class="header" href="#introduction-to-tabular">Introduction to Tabular</a></h1>
<p>Polished terminal output requires two things: good formatting (see <a href="crates/render/guides/intro-to-rendering.html">Rendering Introduction</a>) and good layouts. For text-only, non-interactive output, layout mostly means aligning things vertically and controlling how multiple pieces of information are presented together.</p>
<p>Tabular provides a declarative column system with powerful primitives for sizing (fixed, range, fill, fractions), positioning (anchor to right), overflow handling (clip, wrap, truncate), cell alignment, and automated per-column styling.</p>
<p>Tabular is not only about tables. Any listing where items have multiple fields that benefit from vertical alignment is a good candidate—log entries with authors, timestamps, and messages; file listings with names, sizes, and dates; task lists with IDs, titles, and statuses. Add headers, separators, and borders to a tabular layout, and you have a table.</p>
<p><strong>Key capabilities:</strong></p>
<ul>
<li><strong>Flexible sizing</strong>: Fixed widths, min/max ranges, fill remaining space, fractional proportions</li>
<li><strong>Smart truncation</strong>: Truncate at start, middle, or end with custom ellipsis</li>
<li><strong>Word wrapping</strong>: Wrap long content across multiple lines with proper alignment</li>
<li><strong>Unicode-aware</strong>: CJK characters, combining marks, and ANSI codes handled correctly</li>
<li><strong>Dynamic styling</strong>: Style columns or individual values based on content</li>
</ul>
<p>In this guide, we will walk from a simple listing to a polished table, exploring the available features.</p>
<p><strong>See Also:</strong></p>
<ul>
<li><a href="crates/render/guides/intro-to-rendering.html">Introduction to Rendering</a> - templates and styles overview</li>
<li><a href="crates/render/guides/../topics/styling-system.html">Styling System</a> - themes and adaptive styles</li>
</ul>
<hr />
<h2 id="our-example-task-list"><a class="header" href="#our-example-task-list">Our Example: Task List</a></h2>
<p>We'll build the output for a task list. This is a perfect Tabular use case: each task has an index, title, and status. We want them aligned, readable, and visually clear at a glance.</p>
<p>Here's our data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::Serialize;

#[derive(Clone, Serialize)]
#[serde(rename_all = "lowercase")]
pub enum Status { Pending, Done }

#[derive(Clone, Serialize)]
struct Task {
    title: String,
    status: Status,
}

let tasks = vec![
    Task { title: "Implement user authentication".into(), status: Status::Pending },
    Task { title: "Fix payment gateway timeout".into(), status: Status::Pending },
    Task { title: "Update documentation for API v2".into(), status: Status::Done },
    Task { title: "Review pull request #142".into(), status: Status::Pending },
];
<span class="boring">}</span></code></pre></pre>
<p>Let's progressively build this from raw output to a polished, professional listing.</p>
<hr />
<h2 id="step-1-the-problem-with-plain-output"><a class="header" href="#step-1-the-problem-with-plain-output">Step 1: The Problem with Plain Output</a></h2>
<p>Without any formatting, a naive approach might look like this:</p>
<pre><code class="language-jinja">{% for task in tasks %}
{{ loop.index }}. {{ task.title }} {{ task.status }}
{% endfor %}
</code></pre>
<p>Output:</p>
<pre><code class="language-text">1. Implement user authentication pending
2. Fix payment gateway timeout pending
3. Update documentation for API v2 done
4. Review pull request #142 pending
</code></pre>
<p>This is barely readable. Fields run together, nothing aligns, and scanning the list requires mental parsing of each line. Let's fix that.</p>
<hr />
<h2 id="step-2-basic-column-alignment-with-col"><a class="header" href="#step-2-basic-column-alignment-with-col">Step 2: Basic Column Alignment with <code>col</code></a></h2>
<p>The simplest improvement is the <code>col</code> filter. It pads (or truncates) each value to a fixed width:</p>
<pre><code class="language-jinja">{% for task in tasks %}
{{ loop.index | col(4) }}  {{ task.status | col(10) }}  {{ task.title | col(40) }}
{% endfor %}
</code></pre>
<p>Output:</p>
<pre><code class="language-text">1.    pending     Implement user authentication
2.    pending     Fix payment gateway timeout
3.    done        Update documentation for API v2
4.    pending     Review pull request #142
</code></pre>
<p>Already much better. Each column aligns vertically, making it easy to scan. But we've hardcoded widths, and if a title is too long, it gets truncated with <code>...</code>.</p>
<blockquote>
<p><strong>Key insight:</strong> The <code>col</code> filter handles Unicode correctly. CJK characters count as 2 columns, combining marks don't add width, and ANSI escape codes are preserved but not counted.</p>
</blockquote>
<hr />
<h2 id="step-3-structured-layout-with-tabular"><a class="header" href="#step-3-structured-layout-with-tabular">Step 3: Structured Layout with <code>tabular()</code></a></h2>
<p>For more control, use the <code>tabular()</code> function. This creates a formatter that you configure once and use for all rows:</p>
<pre><code class="language-jinja">{% set t = tabular([
    {"name": "index", "width": 4},
    {"name": "status", "width": 10},
    {"name": "title", "width": 40}
], separator="  ") %}

{% for task in tasks %}
{{ t.row([loop.index, task.status, task.title]) }}
{% endfor %}
</code></pre>
<p>The output looks the same, but now the column definitions are centralized. This becomes powerful when we start adding features.</p>
<hr />
<h2 id="step-4-flexible-widths"><a class="header" href="#step-4-flexible-widths">Step 4: Flexible Widths</a></h2>
<p>Hardcoded widths are fragile. What if the terminal is wider or narrower? Tabular offers flexible width strategies:</p>
<div class="table-wrapper"><table><thead><tr><th>Width</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>8</code></td><td>Exactly 8 columns (fixed)</td></tr>
<tr><td><code>{"min": 10}</code></td><td>At least 10, grows to fit content</td></tr>
<tr><td><code>{"min": 10, "max": 30}</code></td><td>Between 10 and 30</td></tr>
<tr><td><code>"fill"</code></td><td>Takes all remaining space</td></tr>
<tr><td><code>"2fr"</code></td><td>2 parts of remaining (proportional)</td></tr>
</tbody></table>
</div>
<p>Let's make the title column expand to fill available space:</p>
<pre><code class="language-jinja">{% set t = tabular([
    {"name": "index", "width": 4},
    {"name": "status", "width": 10},
    {"name": "title", "width": "fill"}
], separator="  ") %}
</code></pre>
<p>Now on an 80-column terminal:</p>
<pre><code class="language-text">1.    pending     Implement user authentication
2.    pending     Fix payment gateway timeout
3.    done        Update documentation for API v2
4.    pending     Review pull request #142
</code></pre>
<p>On a 120-column terminal, the title column automatically expands to use the extra space.</p>
<p>The layout adapts to the available space.</p>
<hr />
<h2 id="step-5-right-align-numbers"><a class="header" href="#step-5-right-align-numbers">Step 5: Right-Align Numbers</a></h2>
<p>Numbers and indices look better right-aligned. Use the <code>align</code> option:</p>
<pre><code class="language-jinja">{% set t = tabular([
    {"name": "index", "width": 4, "align": "right"},
    {"name": "status", "width": 10},
    {"name": "title", "width": "fill"}
], separator="  ") %}
</code></pre>
<p>Output:</p>
<pre><code class="language-text">  1.  pending     Implement user authentication
  2.  pending     Fix payment gateway timeout
  3.  done        Update documentation for API v2
  4.  pending     Review pull request #142
</code></pre>
<p>The indices now align on the right edge of their column.</p>
<hr />
<h2 id="step-6-anchoring-columns"><a class="header" href="#step-6-anchoring-columns">Step 6: Anchoring Columns</a></h2>
<p>Sometimes you want a column pinned to the terminal's right edge, regardless of how other columns resize. Use <code>anchor</code>:</p>
<pre><code class="language-jinja">{% set t = tabular([
    {"name": "index", "width": 4},
    {"name": "title", "width": "fill"},
    {"name": "status", "width": 10, "anchor": "right"}
], separator="  ") %}
</code></pre>
<p>Now the status column is always at the right edge. If the terminal is 100 columns or 200, the status stays anchored. The fill column absorbs the extra space between fixed columns and anchored columns.</p>
<hr />
<h2 id="step-7-handling-long-content"><a class="header" href="#step-7-handling-long-content">Step 7: Handling Long Content</a></h2>
<p>What happens when a title is longer than its column? By default, Tabular truncates at the end with <code>...</code>. But you have options:</p>
<h3 id="truncate-at-different-positions"><a class="header" href="#truncate-at-different-positions">Truncate at Different Positions</a></h3>
<pre><code class="language-jinja">{"name": "title", "width": 30, "overflow": "truncate"}                        {# "Very long title th..." #}
{"name": "title", "width": 30, "overflow": {"truncate": {"at": "start"}}}     {# "...itle that is long" #}
{"name": "title", "width": 30, "overflow": {"truncate": {"at": "middle"}}}    {# "Very long...is long" #}
</code></pre>
<p>Middle truncation is perfect for file paths where both the start and end matter: <code>/home/user/.../important.txt</code></p>
<h3 id="wrap-to-multiple-lines"><a class="header" href="#wrap-to-multiple-lines">Wrap to Multiple Lines</a></h3>
<p>For descriptions or messages, wrapping is often better than truncating:</p>
<pre><code class="language-jinja">{% set t = tabular([
    {"name": "index", "width": 4},
    {"name": "title", "width": 40, "overflow": "wrap"},
    {"name": "status", "width": 10}
], separator="  ") %}
</code></pre>
<p>If a title exceeds 40 columns, it wraps:</p>
<pre><code class="language-text">1.    Implement comprehensive error handling    pending
      for all API endpoints with proper
      logging and user feedback
2.    Quick fix                                 done
</code></pre>
<p>The wrapped lines are indented to align with the column.</p>
<hr />
<h2 id="step-8-dynamic-styling-based-on-values"><a class="header" href="#step-8-dynamic-styling-based-on-values">Step 8: Dynamic Styling Based on Values</a></h2>
<p>Here's where Tabular shines for task lists. We want status colors: green for done, yellow for pending.</p>
<p>First, define styles in your theme:</p>
<pre><code class="language-css">/* styles/default.css */
.done { color: green; }
.pending { color: yellow; }
</code></pre>
<p>Then use the <code>style_as</code> filter to apply styles based on the value itself:</p>
<pre><code class="language-jinja">{% set t = tabular([
    {"name": "index", "width": 4},
    {"name": "status", "width": 10},
    {"name": "title", "width": "fill"}
], separator="  ") %}

{% for task in tasks %}
{{ t.row([loop.index, task.status | style_as(task.status), task.title]) }}
{% endfor %}
</code></pre>
<p>The <code>style_as</code> filter wraps the value in style tags: <code>[done]done[/done]</code>. The rendering system then applies the green color.</p>
<p>Output (with colors):</p>
<pre><code class="language-text">1.    [yellow]pending[/yellow]   Implement user authentication
2.    [yellow]pending[/yellow]   Fix payment gateway timeout
3.    [green]done[/green]        Update documentation for API v2
4.    [yellow]pending[/yellow]   Review pull request #142
</code></pre>
<p>In the terminal, statuses appear in their respective colors, making it instantly clear which tasks need attention.</p>
<hr />
<h2 id="step-9-column-level-styles"><a class="header" href="#step-9-column-level-styles">Step 9: Column-Level Styles</a></h2>
<p>Instead of styling individual values, you can style entire columns. This is useful for de-emphasizing certain information:</p>
<pre><code class="language-jinja">{% set t = tabular([
    {"name": "index", "width": 4, "style": "muted"},
    {"name": "status", "width": 10},
    {"name": "title", "width": "fill"}
], separator="  ") %}
</code></pre>
<p>Now indices appear in a muted style (typically gray), while titles and statuses remain prominent. This creates visual hierarchy.</p>
<hr />
<h2 id="step-10-automatic-field-extraction"><a class="header" href="#step-10-automatic-field-extraction">Step 10: Automatic Field Extraction</a></h2>
<p>Tired of manually listing <code>[task.title, task.status, ...]</code>? If your column names match your struct fields, use <code>row_from()</code>:</p>
<pre><code class="language-jinja">{% set t = tabular([
    {"name": "title", "width": "fill"},
    {"name": "status", "width": 10}
]) %}

{% for task in tasks %}
{{ t.row_from(task) }}
{% endfor %}
</code></pre>
<p>Tabular extracts <code>task.title</code>, <code>task.status</code>, etc. automatically. For nested fields, use <code>key</code>:</p>
<pre><code class="language-jinja">{"name": "Author", "key": "author.name", "width": 20}
{"name": "Email", "key": "author.email", "width": 30}
</code></pre>
<hr />
<h2 id="step-11-adding-headers-and-borders"><a class="header" href="#step-11-adding-headers-and-borders">Step 11: Adding Headers and Borders</a></h2>
<p>For a proper table with headers, switch from <code>tabular()</code> to <code>table()</code>:</p>
<pre><code class="language-jinja">{% set t = table([
    {"name": "#", "width": 4},
    {"name": "Status", "width": 10},
    {"name": "Title", "width": "fill"}
], border="rounded", header_style="bold") %}

{{ t.header_row() }}
{{ t.separator_row() }}
{% for task in tasks %}
{{ t.row([loop.index, task.status, task.title]) }}
{% endfor %}
{{ t.bottom_border() }}
</code></pre>
<p>Output:</p>
<pre><code class="language-text">╭──────┬────────────┬────────────────────────────────────────╮
│ #    │ Status     │ Title                                  │
├──────┼────────────┼────────────────────────────────────────┤
│ 1    │ pending    │ Implement user authentication          │
│ 2    │ pending    │ Fix payment gateway timeout            │
│ 3    │ done       │ Update documentation for API v2        │
│ 4    │ pending    │ Review pull request #142               │
╰──────┴────────────┴────────────────────────────────────────╯
</code></pre>
<h3 id="border-styles"><a class="header" href="#border-styles">Border Styles</a></h3>
<p>Choose from six border styles:</p>
<div class="table-wrapper"><table><thead><tr><th>Style</th><th>Look</th></tr></thead><tbody>
<tr><td><code>"none"</code></td><td>No borders</td></tr>
<tr><td><code>"ascii"</code></td><td><code>+--+--+</code> (ASCII compatible)</td></tr>
<tr><td><code>"light"</code></td><td><code>┌──┬──┐</code></td></tr>
<tr><td><code>"heavy"</code></td><td><code>┏━━┳━━┓</code></td></tr>
<tr><td><code>"double"</code></td><td><code>╔══╦══╗</code></td></tr>
<tr><td><code>"rounded"</code></td><td><code>╭──┬──╮</code></td></tr>
</tbody></table>
</div>
<h3 id="row-separators"><a class="header" href="#row-separators">Row Separators</a></h3>
<p>For dense data, add lines between rows:</p>
<pre><code class="language-jinja">{% set t = table(columns, border="light", row_separator=true) %}
</code></pre>
<pre><code class="language-text">┌──────┬────────────────────────────────────╮
│ #    │ Title                              │
├──────┼────────────────────────────────────┤
│ 1    │ Implement user authentication      │
├──────┼────────────────────────────────────┤
│ 2    │ Fix payment gateway timeout        │
└──────┴────────────────────────────────────┘
</code></pre>
<hr />
<h2 id="step-12-the-complete-example"><a class="header" href="#step-12-the-complete-example">Step 12: The Complete Example</a></h2>
<p>Putting it all together, here's a polished task list:</p>
<pre><code class="language-jinja">{% set t = table([
    {"name": "#", "width": 4, "style": "muted"},
    {"name": "Status", "width": 10},
    {"name": "Title", "width": "fill", "overflow": {"truncate": {"at": "middle"}}}
], border="rounded", header_style="bold", separator=" | ") %}

{{ t.header_row() }}
{{ t.separator_row() }}
{% for task in tasks %}
{{ t.row([loop.index, task.status | style_as(task.status), task.title]) }}
{% endfor %}
{{ t.bottom_border() }}
</code></pre>
<p>Output (80 columns, with styling):</p>
<pre><code class="language-text">╭──────┬────────────┬───────────────────────────────────────────────────────╮
│ #    │ Status     │ Title                                                 │
├──────┼────────────┼───────────────────────────────────────────────────────┤
│ 1    │ pending    │ Implement user authentication                         │
│ 2    │ pending    │ Fix payment gateway timeout                           │
│ 3    │ done       │ Update documentation for API v2                       │
│ 4    │ pending    │ Review pull request #142                              │
╰──────┴────────────┴───────────────────────────────────────────────────────╯
</code></pre>
<p>Features in use:</p>
<ul>
<li><strong>Rounded borders</strong> for a modern look</li>
<li><strong>Muted styling</strong> on index column for visual hierarchy</li>
<li><strong>Fill width</strong> on title to use available space</li>
<li><strong>Middle truncation</strong> for titles that exceed the column</li>
<li><strong>Dynamic status colors</strong> via <code>style_as</code></li>
</ul>
<hr />
<h2 id="using-tabular-from-rust"><a class="header" href="#using-tabular-from-rust">Using Tabular from Rust</a></h2>
<p>Everything shown in templates is also available in Rust:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_render::tabular::{TabularFormatter, ColumnSpec, Overflow, Alignment};

let columns = vec![
    ColumnSpec::fixed(4).header("#").style("muted"),
    ColumnSpec::fixed(10).header("Status"),
    ColumnSpec::fill().header("Title").overflow(Overflow::truncate_middle()),
];

let formatter = TabularFormatter::new(columns)
    .separator(" | ")
    .terminal_width(80);

// Format individual rows
for (i, task) in tasks.iter().enumerate() {
    let row = formatter.format_row(&amp;[
        &amp;(i + 1).to_string(),
        &amp;task.status.to_string(),
        &amp;task.title,
    ]);
    println!("{}", row);
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>Tabular transforms raw data into polished, scannable output with minimal effort:</p>
<ol>
<li><strong>Start simple</strong> - use <code>col</code> filter for quick alignment</li>
<li><strong>Structure with <code>tabular()</code></strong> - centralize column definitions</li>
<li><strong>Flex with widths</strong> - use <code>fill</code>, bounded ranges, and fractions</li>
<li><strong>Align content</strong> - right-align numbers and dates</li>
<li><strong>Anchor columns</strong> - pin important data to edges</li>
<li><strong>Handle overflow</strong> - truncate intelligently or wrap</li>
<li><strong>Add visual hierarchy</strong> - style columns and values dynamically</li>
<li><strong>Extract automatically</strong> - let <code>row_from()</code> pull fields from structs</li>
<li><strong>Decorate as tables</strong> - add borders, headers, and separators</li>
</ol>
<p>The declarative approach means your layout adapts to terminal width, handles Unicode correctly, and remains maintainable as your data evolves.</p>
<p>For complete API details, see the <a href="https://docs.rs/standout-render">API documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-styling-system"><a class="header" href="#the-styling-system">The Styling System</a></h1>
<p><code>standout-render</code> uses a theme-based styling system where named styles are applied to content through bracket notation tags. Instead of embedding ANSI codes in your templates, you define semantic style names (<code>error</code>, <code>title</code>, <code>muted</code>) and let the theme decide the visual representation.</p>
<p>This separation provides several benefits:</p>
<ul>
<li><strong>Readability</strong>: Templates use meaningful names, not escape codes</li>
<li><strong>Maintainability</strong>: Change colors in one place, update everywhere</li>
<li><strong>Adaptability</strong>: Themes can respond to light/dark mode automatically</li>
<li><strong>Consistency</strong>: Enforce visual hierarchy across your application</li>
</ul>
<hr />
<h2 id="themes"><a class="header" href="#themes">Themes</a></h2>
<p>A <code>Theme</code> is a named collection of styles. Each style maps a name (like <code>title</code> or <code>error</code>) to visual attributes (bold cyan, dim red, etc.).</p>
<h3 id="programmatic-themes"><a class="header" href="#programmatic-themes">Programmatic Themes</a></h3>
<p>Build themes in code using the builder pattern:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_render::Theme;
use console::Style;

let theme = Theme::new()
    .add("title", Style::new().bold().cyan())
    .add("error", Style::new().red().bold())
    .add("muted", Style::new().dim())
    .add("success", Style::new().green());
<span class="boring">}</span></code></pre></pre>
<h3 id="yaml-themes"><a class="header" href="#yaml-themes">YAML Themes</a></h3>
<p>For file-based configuration, YAML provides a concise syntax:</p>
<pre><code class="language-yaml"># theme.yaml
title:
  fg: cyan
  bold: true

error:
  fg: red
  bold: true

muted:
  dim: true

success:
  fg: green

# Shorthand: single attribute or space-separated
warning: yellow
emphasis: "bold italic"
</code></pre>
<p>Load YAML themes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_render::Theme;

// From string
let theme = Theme::from_yaml(yaml_content)?;

// From file (with hot reload in debug builds)
let theme = Theme::from_yaml_file("styles/theme.yaml")?;
<span class="boring">}</span></code></pre></pre>
<h3 id="css-themes"><a class="header" href="#css-themes">CSS Themes</a></h3>
<p>For developers who prefer standard CSS syntax, <code>standout-render</code> supports a subset of CSS Level 3 tailored for terminals:</p>
<pre><code class="language-css">/* theme.css */
.title {
    color: cyan;
    font-weight: bold;
}

.error {
    color: red;
    font-weight: bold;
}

.muted {
    opacity: 0.5;  /* maps to dim */
}

.success {
    color: green;
}

/* Shorthand works too */
.warning { color: yellow; }
</code></pre>
<p>Load CSS themes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_render::Theme;

let theme = Theme::from_css(css_content)?;
let theme = Theme::from_css_file("styles/theme.css")?;
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>CSS is the recommended format for new projects. It enables syntax highlighting in editors, linting tools, and familiarity for web developers.</p>
</blockquote>
<hr />
<h2 id="supported-attributes"><a class="header" href="#supported-attributes">Supported Attributes</a></h2>
<h3 id="colors"><a class="header" href="#colors">Colors</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Attribute</th><th>CSS Property</th><th>Description</th></tr></thead><tbody>
<tr><td><code>fg</code></td><td><code>color</code></td><td>Foreground (text) color</td></tr>
<tr><td><code>bg</code></td><td><code>background</code></td><td>Background color</td></tr>
</tbody></table>
</div>
<h3 id="color-formats"><a class="header" href="#color-formats">Color Formats</a></h3>
<pre><code class="language-yaml"># Named colors (16 ANSI colors)
fg: red
fg: green
fg: blue
fg: cyan
fg: magenta
fg: yellow
fg: white
fg: black

# Bright variants
fg: bright_red
fg: bright_green

# 256-color palette (0-255)
fg: 208

# RGB hex
fg: "#ff6b35"
fg: "#f63"      # shorthand

# RGB array
fg: [255, 107, 53]
</code></pre>
<h3 id="text-attributes"><a class="header" href="#text-attributes">Text Attributes</a></h3>
<div class="table-wrapper"><table><thead><tr><th>YAML</th><th>CSS</th><th>Effect</th></tr></thead><tbody>
<tr><td><code>bold: true</code></td><td><code>font-weight: bold</code></td><td>Bold text</td></tr>
<tr><td><code>dim: true</code></td><td><code>opacity: 0.5</code></td><td>Dimmed/faint text</td></tr>
<tr><td><code>italic: true</code></td><td><code>font-style: italic</code></td><td>Italic text</td></tr>
<tr><td><code>underline: true</code></td><td><code>text-decoration: underline</code></td><td>Underlined text</td></tr>
<tr><td><code>blink: true</code></td><td><code>text-decoration: blink</code></td><td>Blinking text</td></tr>
<tr><td><code>reverse: true</code></td><td>—</td><td>Swap fg/bg colors</td></tr>
<tr><td><code>hidden: true</code></td><td><code>visibility: hidden</code></td><td>Hidden text</td></tr>
<tr><td><code>strikethrough: true</code></td><td><code>text-decoration: line-through</code></td><td>Strikethrough</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="adaptive-styles-lightdark-mode"><a class="header" href="#adaptive-styles-lightdark-mode">Adaptive Styles (Light/Dark Mode)</a></h2>
<p>Terminal applications run in both light and dark environments. A color that looks great on a dark background may be illegible on a light one. <code>standout-render</code> solves this with adaptive styles.</p>
<h3 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h3>
<p>Instead of defining separate "light theme" and "dark theme" files, you define mode-specific overrides at the style level:</p>
<pre><code class="language-yaml">panel:
  bold: true          # Shared across all modes
  fg: gray            # Default/fallback
  light:
    fg: black         # Override for light mode
  dark:
    fg: white         # Override for dark mode
</code></pre>
<p>When resolving <code>panel</code> in dark mode:</p>
<ol>
<li>Start with base attributes (<code>bold: true</code>, <code>fg: gray</code>)</li>
<li>Merge dark overrides (<code>fg: white</code> replaces <code>fg: gray</code>)</li>
<li>Result: bold white text</li>
</ol>
<p>This is efficient: most styles (bold, italic, semantic colors like green/red) look fine in both modes. Only a handful need adjustment—typically foreground colors for contrast.</p>
<h3 id="css-syntax"><a class="header" href="#css-syntax">CSS Syntax</a></h3>
<pre><code class="language-css">.panel {
    font-weight: bold;
    color: gray;
}

@media (prefers-color-scheme: light) {
    .panel { color: black; }
}

@media (prefers-color-scheme: dark) {
    .panel { color: white; }
}
</code></pre>
<h3 id="programmatic-api"><a class="header" href="#programmatic-api">Programmatic API</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_render::Theme;
use console::{Style, Color};

let theme = Theme::new()
    .add_adaptive(
        "panel",
        Style::new().bold(),                     // Base (shared)
        Some(Style::new().fg(Color::Black)),     // Light mode
        Some(Style::new().fg(Color::White)),     // Dark mode
    );
<span class="boring">}</span></code></pre></pre>
<h3 id="color-mode-detection"><a class="header" href="#color-mode-detection">Color Mode Detection</a></h3>
<p><code>standout-render</code> auto-detects the OS color scheme:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_render::{detect_color_mode, ColorMode};

let mode = detect_color_mode();
match mode {
    ColorMode::Light =&gt; println!("Light mode"),
    ColorMode::Dark =&gt; println!("Dark mode"),
}
<span class="boring">}</span></code></pre></pre>
<p>Override for testing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_render::set_theme_detector;

set_theme_detector(|| ColorMode::Dark);  // Force dark mode
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="style-aliasing"><a class="header" href="#style-aliasing">Style Aliasing</a></h2>
<p>Aliases let semantic names resolve to visual styles. This is useful when multiple concepts share the same appearance:</p>
<pre><code class="language-yaml"># Define the visual style once
title:
  fg: cyan
  bold: true

# Aliases
commit-message: title
section-header: title
heading: title
</code></pre>
<p>Now <code>[commit-message]</code>, <code>[section-header]</code>, and <code>[heading]</code> all render identically to <code>[title]</code>.</p>
<p>Benefits:</p>
<ul>
<li>Templates use meaningful, context-specific names</li>
<li>Visual changes propagate automatically</li>
<li>Refactoring visual design doesn't touch templates</li>
</ul>
<p>Aliases can chain: <code>a</code> → <code>b</code> → <code>c</code> → concrete style. Cycles are detected and rejected at load time.</p>
<hr />
<h2 id="unknown-style-tags"><a class="header" href="#unknown-style-tags">Unknown Style Tags</a></h2>
<p>When a template references a style not defined in the theme, <code>standout-render</code> handles it gracefully:</p>
<div class="table-wrapper"><table><thead><tr><th>Output Mode</th><th>Behavior</th></tr></thead><tbody>
<tr><td><code>Term</code></td><td>Unknown tags get a <code>?</code> marker: <code>[unknown?]text[/unknown?]</code></td></tr>
<tr><td><code>Text</code></td><td>Tags stripped (plain text)</td></tr>
<tr><td><code>TermDebug</code></td><td>Tags preserved as-is</td></tr>
</tbody></table>
</div>
<p>The <code>?</code> marker helps catch typos during development without crashing production apps.</p>
<h3 id="validation"><a class="header" href="#validation">Validation</a></h3>
<p>For strict checking at startup:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_render::validate_template;

let errors = validate_template(template, &amp;sample_data, &amp;theme);
if !errors.is_empty() {
    for error in errors {
        eprintln!("Unknown style: {}", error.tag_name);
    }
    std::process::exit(1);
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="semantic-presentation-and-visual-layers"><a class="header" href="#semantic-presentation-and-visual-layers">Semantic, Presentation, and Visual Layers</a></h3>
<p>Organize your styles in three conceptual layers:</p>
<p><strong>1. Visual primitives</strong> (low-level appearance):</p>
<pre><code class="language-yaml">_cyan-bold:
  fg: cyan
  bold: true

_dim:
  dim: true

_red-bold:
  fg: red
  bold: true
</code></pre>
<p><strong>2. Presentation roles</strong> (UI concepts):</p>
<pre><code class="language-yaml">heading: _cyan-bold
secondary: _dim
danger: _red-bold
</code></pre>
<p><strong>3. Semantic names</strong> (domain concepts):</p>
<pre><code class="language-yaml"># In templates, use these
task-title: heading
task-status-done: success
task-status-pending: warning
error-message: danger
</code></pre>
<p>Templates use semantic names (<code>task-title</code>), which resolve to presentation roles (<code>heading</code>), which resolve to visual primitives (<code>_cyan-bold</code>).</p>
<p>This layering lets you:</p>
<ul>
<li>Refactor visuals without touching templates</li>
<li>Maintain consistency across domains</li>
<li>Document the purpose of each style</li>
</ul>
<h3 id="naming-conventions"><a class="header" href="#naming-conventions">Naming Conventions</a></h3>
<pre><code class="language-yaml"># Good: descriptive, semantic
error-message: ...
file-path: ...
command-name: ...

# Avoid: visual descriptions
red-text: ...
bold-cyan: ...
</code></pre>
<h3 id="keep-themes-focused"><a class="header" href="#keep-themes-focused">Keep Themes Focused</a></h3>
<p>One theme per "look". Don't mix concerns:</p>
<pre><code class="language-yaml"># theme-default.yaml - your app's default look
# theme-colorblind.yaml - accessibility variant
# theme-monochrome.yaml - for piped output
</code></pre>
<hr />
<h2 id="api-reference"><a class="header" href="#api-reference">API Reference</a></h2>
<h3 id="theme-creation"><a class="header" href="#theme-creation">Theme Creation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Empty theme
let theme = Theme::new();

// From YAML string
let theme = Theme::from_yaml(yaml_str)?;

// From CSS string
let theme = Theme::from_css(css_str)?;

// From files (hot reload in debug)
let theme = Theme::from_yaml_file(path)?;
let theme = Theme::from_css_file(path)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="adding-styles"><a class="header" href="#adding-styles">Adding Styles</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Static style
theme.add("name", Style::new().bold());

// Adaptive style
theme.add_adaptive("name", base_style, light_override, dark_override);

// Alias
theme.add("alias", "target_style");
<span class="boring">}</span></code></pre></pre>
<h3 id="resolving-styles"><a class="header" href="#resolving-styles">Resolving Styles</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get resolved style for current color mode
let style: Option&lt;Style&gt; = theme.get("title");

// Get style for specific mode
let style = theme.get_for_mode("panel", ColorMode::Dark);
<span class="boring">}</span></code></pre></pre>
<h3 id="color-mode"><a class="header" href="#color-mode">Color Mode</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_render::{detect_color_mode, set_theme_detector, ColorMode};

// Auto-detect
let mode = detect_color_mode();

// Override (for testing)
set_theme_detector(|| ColorMode::Light);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="templating"><a class="header" href="#templating">Templating</a></h1>
<p><code>standout-render</code> uses a two-pass templating system that combines the power of MiniJinja for logic and data binding with a custom BBCode-like syntax for styling. This separation keeps templates readable while providing full control over both content and presentation.</p>
<hr />
<h2 id="two-pass-rendering-pipeline"><a class="header" href="#two-pass-rendering-pipeline">Two-Pass Rendering Pipeline</a></h2>
<p>Templates are processed in two distinct passes:</p>
<pre><code class="language-text">Template + Data → [Pass 1: MiniJinja] → Text with style tags → [Pass 2: BBParser] → Final output
</code></pre>
<p><strong>Pass 1 - MiniJinja</strong>: Standard template processing. Variables are substituted, control flow executes, filters apply.</p>
<p><strong>Pass 2 - BBParser</strong>: Style tag processing. Bracket-notation tags are converted to ANSI escape codes (or stripped, depending on output mode).</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<pre><code class="language-text">Template:     [title]{{ name }}[/title] has {{ count }} items
Data:         { name: "Report", count: 42 }

After Pass 1: [title]Report[/title] has 42 items
After Pass 2: \x1b[1;36mReport\x1b[0m has 42 items  (or plain: "Report has 42 items")
</code></pre>
<p>This separation means:</p>
<ul>
<li>Template logic (loops, conditionals) is handled by MiniJinja—a mature, well-documented engine</li>
<li>Style application is a simple, predictable transformation</li>
<li>You can debug each pass independently</li>
</ul>
<hr />
<h2 id="minijinja-basics"><a class="header" href="#minijinja-basics">MiniJinja Basics</a></h2>
<p>MiniJinja implements Jinja2 syntax, a widely-used templating language. Here's a quick overview:</p>
<h3 id="variables"><a class="header" href="#variables">Variables</a></h3>
<pre><code class="language-jinja">{{ variable }}
{{ object.field }}
{{ list[0] }}
</code></pre>
<h3 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h3>
<pre><code class="language-jinja">{% if condition %}
  Show this
{% elif other_condition %}
  Show that
{% else %}
  Default
{% endif %}

{% for item in items %}
  {{ loop.index }}. {{ item.name }}
{% endfor %}
</code></pre>
<h3 id="filters"><a class="header" href="#filters">Filters</a></h3>
<pre><code class="language-jinja">{{ name | upper }}
{{ list | length }}
{{ value | default("N/A") }}
{{ text | truncate(20) }}
</code></pre>
<h3 id="comments"><a class="header" href="#comments">Comments</a></h3>
<pre><code class="language-jinja">{# This is a comment and won't appear in output #}
</code></pre>
<p>For comprehensive MiniJinja documentation, see the <a href="https://docs.rs/minijinja">MiniJinja documentation</a>.</p>
<hr />
<h2 id="style-tags"><a class="header" href="#style-tags">Style Tags</a></h2>
<p>Style tags use BBCode-like bracket notation to apply named styles from your theme:</p>
<pre><code class="language-jinja">[style-name]content to style[/style-name]
</code></pre>
<h3 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h3>
<pre><code class="language-jinja">[title]Report Summary[/title]
[error]Something went wrong![/error]
[muted]Last updated: {{ timestamp }}[/muted]
</code></pre>
<h3 id="nesting"><a class="header" href="#nesting">Nesting</a></h3>
<p>Tags can nest properly:</p>
<pre><code class="language-jinja">[outer][inner]nested content[/inner][/outer]
</code></pre>
<h3 id="spanning-lines"><a class="header" href="#spanning-lines">Spanning Lines</a></h3>
<p>Tags can span multiple lines:</p>
<pre><code class="language-jinja">[panel]
This is a multi-line
block of styled content
[/panel]
</code></pre>
<h3 id="with-template-logic"><a class="header" href="#with-template-logic">With Template Logic</a></h3>
<p>Style tags and MiniJinja work together seamlessly:</p>
<pre><code class="language-jinja">[title]{% if custom_title %}{{ custom_title }}{% else %}Default Title{% endif %}[/title]

{% for task in tasks %}
[{{ task.status }}]{{ task.title }}[/{{ task.status }}]
{% endfor %}
</code></pre>
<p>The second example shows dynamic style names—the style applied depends on the value of <code>task.status</code>.</p>
<hr />
<h2 id="processing-modes"><a class="header" href="#processing-modes">Processing Modes</a></h2>
<p>Pass 2 (BBParser) processes style tags differently based on the output mode:</p>
<div class="table-wrapper"><table><thead><tr><th>Mode</th><th>Behavior</th><th>Use Case</th></tr></thead><tbody>
<tr><td><code>Term</code></td><td>Replace tags with ANSI escape codes</td><td>Rich terminal output</td></tr>
<tr><td><code>Text</code></td><td>Strip tags completely</td><td>Plain text, pipes, files</td></tr>
<tr><td><code>TermDebug</code></td><td>Keep tags as literal text</td><td>Debugging, testing</td></tr>
</tbody></table>
</div>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<p>Template: <code>[title]Hello[/title]</code></p>
<ul>
<li><strong>Term</strong>: <code>\x1b[1;36mHello\x1b[0m</code> (rendered as cyan bold)</li>
<li><strong>Text</strong>: <code>Hello</code></li>
<li><strong>TermDebug</strong>: <code>[title]Hello[/title]</code></li>
</ul>
<h3 id="setting-the-mode"><a class="header" href="#setting-the-mode">Setting the Mode</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_render::{render_with_output, OutputMode};

// Rich terminal
let output = render_with_output(template, &amp;data, &amp;theme, OutputMode::Term)?;

// Plain text
let output = render_with_output(template, &amp;data, &amp;theme, OutputMode::Text)?;

// Debug (tags visible)
let output = render_with_output(template, &amp;data, &amp;theme, OutputMode::TermDebug)?;

// Auto-detect based on TTY
let output = render_with_output(template, &amp;data, &amp;theme, OutputMode::Auto)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="auto-mode"><a class="header" href="#auto-mode">Auto Mode</a></h3>
<p><code>OutputMode::Auto</code> detects the appropriate mode:</p>
<ul>
<li>If stdout is a TTY with color support → <code>Term</code></li>
<li>If stdout is a pipe or redirect → <code>Text</code></li>
</ul>
<blockquote>
<p><strong>For standout framework users:</strong> The framework's <code>--output</code> CLI flag automatically sets the output mode. See standout documentation for details.</p>
</blockquote>
<hr />
<h2 id="built-in-filters"><a class="header" href="#built-in-filters">Built-in Filters</a></h2>
<p>Beyond MiniJinja's standard filters, <code>standout-render</code> provides formatting filters:</p>
<h3 id="column-formatting"><a class="header" href="#column-formatting">Column Formatting</a></h3>
<pre><code class="language-jinja">{{ value | col(10) }}                              {# pad/truncate to 10 chars #}
{{ value | col(20, align="right") }}               {# right-align in 20 chars #}
{{ value | col(15, truncate="middle") }}           {# truncate in middle #}
{{ value | col(15, truncate="start", ellipsis="...") }}
</code></pre>
<h3 id="padding"><a class="header" href="#padding">Padding</a></h3>
<pre><code class="language-jinja">{{ "42" | pad_left(8) }}      {# "      42" #}
{{ "hi" | pad_right(8) }}     {# "hi      " #}
{{ "hi" | pad_center(8) }}    {# "   hi   " #}
</code></pre>
<h3 id="truncation"><a class="header" href="#truncation">Truncation</a></h3>
<pre><code class="language-jinja">{{ long_text | truncate_at(20) }}                   {# "Very long text th..." #}
{{ path | truncate_at(30, "middle", "...") }}      {# "/home/.../file.txt" #}
{{ text | truncate_at(20, "start") }}              {# "...end of the text" #}
</code></pre>
<h3 id="display-width"><a class="header" href="#display-width">Display Width</a></h3>
<pre><code class="language-jinja">{% if value | display_width &gt; 20 %}
  {{ value | truncate_at(20) }}
{% else %}
  {{ value }}
{% endif %}
</code></pre>
<p>Returns visual width (handles Unicode—CJK characters count as 2).</p>
<h3 id="style-application"><a class="header" href="#style-application">Style Application</a></h3>
<pre><code class="language-jinja">{{ value | style_as("error") }}                    {# wraps in [error]...[/error] #}
{{ task.status | style_as(task.status) }}         {# dynamic: [pending]pending[/pending] #}
</code></pre>
<hr />
<h2 id="template-registry"><a class="header" href="#template-registry">Template Registry</a></h2>
<p>When using the <code>Renderer</code> struct, templates are resolved by name through a registry:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_render::Renderer;

let mut renderer = Renderer::new(theme)?;

// Add inline template
renderer.add_template("greeting", "Hello, [name]{{ name }}[/name]!")?;

// Add directory of templates
renderer.add_template_dir("./templates")?;

// Render by name
let output = renderer.render("greeting", &amp;data)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="resolution-priority"><a class="header" href="#resolution-priority">Resolution Priority</a></h3>
<ol>
<li><strong>Inline templates</strong> (added via <code>add_template()</code>)</li>
<li><strong>Directory templates</strong> (from <code>add_template_dir()</code>)</li>
</ol>
<h3 id="file-extensions"><a class="header" href="#file-extensions">File Extensions</a></h3>
<p>Supported extensions (in priority order): <code>.jinja</code>, <code>.jinja2</code>, <code>.j2</code>, <code>.txt</code></p>
<p>When you request <code>"report"</code>, the registry checks:</p>
<ul>
<li>Inline template named <code>"report"</code></li>
<li><code>report.jinja</code> in registered directories</li>
<li><code>report.jinja2</code>, <code>report.j2</code>, <code>report.txt</code> (lower priority)</li>
</ul>
<h3 id="template-names"><a class="header" href="#template-names">Template Names</a></h3>
<p>Template names are derived from relative paths:</p>
<pre><code class="language-text">templates/
├── greeting.jinja       → "greeting"
├── reports/
│   └── summary.jinja    → "reports/summary"
└── errors/
    └── 404.jinja        → "errors/404"
</code></pre>
<hr />
<h2 id="including-templates"><a class="header" href="#including-templates">Including Templates</a></h2>
<p>Templates can include other templates using MiniJinja's include syntax:</p>
<pre><code class="language-jinja">{# main.jinja #}
[title]{{ title }}[/title]

{% include "partials/header.jinja" %}

{% for item in items %}
  {% include "partials/item.jinja" %}
{% endfor %}

{% include "partials/footer.jinja" %}
</code></pre>
<p>This enables reusable components across your application.</p>
<hr />
<h2 id="context-variables"><a class="header" href="#context-variables">Context Variables</a></h2>
<p>Beyond your data, you can inject additional context into templates:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_render::{render_with_vars, OutputMode};
use std::collections::HashMap;

let mut vars = HashMap::new();
vars.insert("version", "1.0.0");
vars.insert("app_name", "MyApp");

let output = render_with_vars(
    "{{ app_name }} v{{ version }}: {{ message }}",
    &amp;data,
    &amp;theme,
    OutputMode::Term,
    vars,
)?;
<span class="boring">}</span></code></pre></pre>
<p>When handler data and context variables have the same key, <strong>handler data wins</strong>. Context is supplementary.</p>
<hr />
<h2 id="structured-output-1"><a class="header" href="#structured-output-1">Structured Output</a></h2>
<p>For machine-readable output (JSON, YAML, CSV), templates are bypassed entirely:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_render::{render_auto, OutputMode};

// Template is used for Term/Text modes
// Data is serialized directly for Json/Yaml/Csv
let output = render_auto(template, &amp;data, &amp;theme, OutputMode::Json)?;
<span class="boring">}</span></code></pre></pre>
<div class="table-wrapper"><table><thead><tr><th>Mode</th><th>Behavior</th></tr></thead><tbody>
<tr><td><code>Term</code></td><td>Render template, apply styles</td></tr>
<tr><td><code>Text</code></td><td>Render template, strip styles</td></tr>
<tr><td><code>TermDebug</code></td><td>Render template, keep style tags</td></tr>
<tr><td><code>Json</code></td><td><code>serde_json::to_string_pretty(data)</code></td></tr>
<tr><td><code>Yaml</code></td><td><code>serde_yaml::to_string(data)</code></td></tr>
<tr><td><code>Csv</code></td><td>Flatten and format as CSV</td></tr>
</tbody></table>
</div>
<p>This means your serializable data types automatically support structured output without additional code.</p>
<hr />
<h2 id="validation-1"><a class="header" href="#validation-1">Validation</a></h2>
<p>Check templates for unknown style tags before deploying:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_render::validate_template;

let errors = validate_template(template, &amp;sample_data, &amp;theme);
if !errors.is_empty() {
    for error in &amp;errors {
        eprintln!("Unknown style tag: [{}]", error.tag_name);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Validation catches:</p>
<ul>
<li>Misspelled style names</li>
<li>References to undefined styles</li>
<li>Mismatched opening/closing tags</li>
</ul>
<hr />
<h2 id="api-reference-1"><a class="header" href="#api-reference-1">API Reference</a></h2>
<h3 id="render-functions"><a class="header" href="#render-functions">Render Functions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_render::{
    render,                  // Basic: template + data + theme
    render_with_output,      // With explicit output mode
    render_with_mode,        // With output mode + color mode
    render_with_vars,        // With extra context variables
    render_auto,             // Auto-dispatch template vs serialize
    render_auto_with_context,
};

// Basic
let output = render(template, &amp;data, &amp;theme)?;

// With output mode
let output = render_with_output(template, &amp;data, &amp;theme, OutputMode::Term)?;

// With color mode override (for testing)
let output = render_with_mode(template, &amp;data, &amp;theme, OutputMode::Term, ColorMode::Dark)?;

// Auto (template for text modes, serialize for structured)
let output = render_auto(template, &amp;data, &amp;theme, OutputMode::Json)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="renderer-struct"><a class="header" href="#renderer-struct">Renderer Struct</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_render::Renderer;

let mut renderer = Renderer::new(theme)?;
renderer.add_template("name", "content")?;
renderer.add_template_dir("./templates")?;

let output = renderer.render("name", &amp;data)?;
let output = renderer.render_with_mode("name", &amp;data, OutputMode::Text)?;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="file-system-resources"><a class="header" href="#file-system-resources">File System Resources</a></h1>
<p><code>standout-render</code> supports file-based templates and stylesheets that can be hot-reloaded during development and embedded into release binaries. This workflow combines the rapid iteration of interpreted languages with the distribution simplicity of compiled binaries.</p>
<hr />
<h2 id="the-development-workflow"><a class="header" href="#the-development-workflow">The Development Workflow</a></h2>
<p>During development, you want to:</p>
<ol>
<li>Edit a template or stylesheet</li>
<li>Re-run your program</li>
<li>See changes immediately</li>
</ol>
<p>During release, you want:</p>
<ol>
<li>A single binary with no external dependencies</li>
<li>No file paths to manage</li>
<li>No risk of missing assets</li>
</ol>
<p><code>standout-render</code> supports both modes with the same code.</p>
<hr />
<h2 id="hot-reload"><a class="header" href="#hot-reload">Hot Reload</a></h2>
<p>In debug builds (<code>debug_assertions</code> enabled), file-based resources are re-read from disk on each render. This means:</p>
<ul>
<li>Edit <code>templates/report.jinja</code> → re-run → see changes</li>
<li>Edit <code>styles/theme.css</code> → re-run → see new styles</li>
<li>No recompilation needed</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_render::Renderer;

let mut renderer = Renderer::new(theme)?;
renderer.add_template_dir("./templates")?;

// In debug: reads from disk each time
// In release: uses cached content
let output = renderer.render("report", &amp;data)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="how-it-works-1"><a class="header" href="#how-it-works-1">How It Works</a></h3>
<p>The <code>Renderer</code> tracks the source of each template:</p>
<ul>
<li><strong>Inline</strong>: Content provided as a string (always cached)</li>
<li><strong>File-based</strong>: Path recorded, content read on demand</li>
</ul>
<p>In debug builds, file-based templates are re-read before each render. In release builds, content is cached after first load.</p>
<hr />
<h2 id="file-registries"><a class="header" href="#file-registries">File Registries</a></h2>
<p>Both templates and stylesheets use a registry pattern: a map from names to content.</p>
<h3 id="template-registry-1"><a class="header" href="#template-registry-1">Template Registry</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_render::TemplateRegistry;

let mut registry = TemplateRegistry::new();

// Add from directory
registry.add_dir("./templates")?;

// Add inline
registry.add("greeting", "Hello, {{ name }}!")?;

// Resolve by name
let content = registry.get("report")?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Name resolution from paths:</strong></p>
<pre><code class="language-text">./templates/
├── greeting.jinja       → "greeting"
├── reports/
│   ├── summary.jinja    → "reports/summary"
│   └── detail.jinja     → "reports/detail"
└── partials/
    └── header.jinja     → "partials/header"
</code></pre>
<p>Names are relative paths without extensions.</p>
<h3 id="stylesheet-registry"><a class="header" href="#stylesheet-registry">Stylesheet Registry</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_render::StylesheetRegistry;

let mut registry = StylesheetRegistry::new();
registry.add_dir("./styles")?;

let theme = registry.get("default")?;  // loads default.css or default.yaml
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="supported-extensions"><a class="header" href="#supported-extensions">Supported Extensions</a></h2>
<h3 id="templates"><a class="header" href="#templates">Templates</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Extension</th><th>Priority</th></tr></thead><tbody>
<tr><td><code>.jinja</code></td><td>1 (highest)</td></tr>
<tr><td><code>.jinja2</code></td><td>2</td></tr>
<tr><td><code>.j2</code></td><td>3</td></tr>
<tr><td><code>.txt</code></td><td>4 (lowest)</td></tr>
</tbody></table>
</div>
<p>If both <code>report.jinja</code> and <code>report.txt</code> exist, <code>report.jinja</code> is used.</p>
<h3 id="stylesheets"><a class="header" href="#stylesheets">Stylesheets</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Extension</th><th>Format</th></tr></thead><tbody>
<tr><td><code>.css</code></td><td>CSS syntax</td></tr>
<tr><td><code>.yaml</code></td><td>YAML syntax</td></tr>
<tr><td><code>.yml</code></td><td>YAML syntax</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="embedding-resources"><a class="header" href="#embedding-resources">Embedding Resources</a></h2>
<p>For release builds, embed resources directly into the binary using the provided macros:</p>
<h3 id="embedding-templates"><a class="header" href="#embedding-templates">Embedding Templates</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_render::{embed_templates, EmbeddedTemplates};

// Embed all .jinja files from a directory
let templates: EmbeddedTemplates = embed_templates!("src/templates");

// Use with Renderer
let mut renderer = Renderer::new(theme)?;
renderer.add_embedded_templates(templates)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="embedding-stylesheets"><a class="header" href="#embedding-stylesheets">Embedding Stylesheets</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_render::{embed_styles, EmbeddedStyles};

// Embed all .css/.yaml files from a directory
let styles: EmbeddedStyles = embed_styles!("src/styles");

// Load a specific theme
let theme = styles.get("default")?;
<span class="boring">}</span></code></pre></pre>
<h3 id="hybrid-approach"><a class="header" href="#hybrid-approach">Hybrid Approach</a></h3>
<p>Combine embedded defaults with optional file overrides:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_render::{Renderer, embed_templates};

let embedded = embed_templates!("src/templates");

let mut renderer = Renderer::new(theme)?;

// Add embedded first (lower priority)
renderer.add_embedded_templates(embedded)?;

// Add file directory (higher priority, overrides embedded)
if Path::new("./templates").exists() {
    renderer.add_template_dir("./templates")?;
}
<span class="boring">}</span></code></pre></pre>
<p>This pattern lets users customize templates without modifying the binary.</p>
<hr />
<h2 id="resolution-priority-1"><a class="header" href="#resolution-priority-1">Resolution Priority</a></h2>
<p>When resolving a template or stylesheet name, sources are checked in priority order:</p>
<ol>
<li><strong>Inline</strong> (added via <code>add()</code> or <code>add_template()</code>)</li>
<li><strong>File-based directories</strong> (in order added, later = higher priority)</li>
<li><strong>Embedded</strong> (lowest priority)</li>
</ol>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>renderer.add_embedded_templates(embedded)?;  // Priority 1 (lowest)
renderer.add_template_dir("./vendor")?;      // Priority 2
renderer.add_template_dir("./templates")?;   // Priority 3 (highest)
renderer.add_template("report", "inline")?;  // Priority 4 (always wins)
<span class="boring">}</span></code></pre></pre>
<p>If "report" exists in all sources, the inline version is used.</p>
<hr />
<h2 id="directory-structure"><a class="header" href="#directory-structure">Directory Structure</a></h2>
<p>Recommended project layout:</p>
<pre><code class="language-text">my-cli/
├── src/
│   ├── main.rs
│   ├── templates/           # Templates for embedding
│   │   ├── list.jinja
│   │   ├── detail.jinja
│   │   └── partials/
│   │       └── header.jinja
│   └── styles/              # Stylesheets for embedding
│       ├── default.css
│       └── colorblind.css
├── templates/               # Development overrides (gitignored)
└── styles/                  # Development overrides (gitignored)
</code></pre>
<p>In <code>main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let embedded_templates = embed_templates!("src/templates");
let embedded_styles = embed_styles!("src/styles");

let mut renderer = Renderer::new(theme)?;
renderer.add_embedded_templates(embedded_templates)?;

// In debug, also check local directories for overrides
#[cfg(debug_assertions)]
{
    if Path::new("./templates").exists() {
        renderer.add_template_dir("./templates")?;
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<h3 id="missing-templates"><a class="header" href="#missing-templates">Missing Templates</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match renderer.render("nonexistent", &amp;data) {
    Ok(output) =&gt; println!("{}", output),
    Err(e) =&gt; {
        // Template not found in any source
        eprintln!("Template error: {}", e);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="name-collisions"><a class="header" href="#name-collisions">Name Collisions</a></h3>
<p>Same-directory collisions use extension priority (<code>.jinja</code> &gt; <code>.txt</code>).</p>
<p>Cross-directory collisions are resolved by priority order (later directories win).</p>
<h3 id="invalid-content"><a class="header" href="#invalid-content">Invalid Content</a></h3>
<p>Template syntax errors are reported with line numbers:</p>
<pre><code class="language-text">Template 'report' error at line 15:
  unexpected end of template, expected 'endif'
</code></pre>
<hr />
<h2 id="api-reference-2"><a class="header" href="#api-reference-2">API Reference</a></h2>
<h3 id="templateregistry"><a class="header" href="#templateregistry">TemplateRegistry</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_render::TemplateRegistry;

let mut registry = TemplateRegistry::new();

// Add sources
registry.add("name", "content")?;
registry.add_dir("./templates")?;
registry.add_embedded(embedded_templates)?;

// Query
let content: Option&lt;&amp;str&gt; = registry.get("name");
let names: Vec&lt;&amp;str&gt; = registry.names();
let exists: bool = registry.contains("name");
<span class="boring">}</span></code></pre></pre>
<h3 id="stylesheetregistry"><a class="header" href="#stylesheetregistry">StylesheetRegistry</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_render::StylesheetRegistry;

let mut registry = StylesheetRegistry::new();

// Add sources
registry.add_dir("./styles")?;
registry.add_embedded(embedded_styles)?;

// Get parsed theme
let theme: Theme = registry.get("default")?;
let names: Vec&lt;&amp;str&gt; = registry.names();
<span class="boring">}</span></code></pre></pre>
<h3 id="embed-macros"><a class="header" href="#embed-macros">Embed Macros</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_render::{embed_templates, embed_styles};

// At compile time, reads all matching files and embeds content
let templates = embed_templates!("path/to/templates");
let styles = embed_styles!("path/to/styles");
<span class="boring">}</span></code></pre></pre>
<h3 id="renderer-integration"><a class="header" href="#renderer-integration">Renderer Integration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_render::Renderer;

let mut renderer = Renderer::new(theme)?;

// Templates
renderer.add_template("name", "content")?;
renderer.add_template_dir("./templates")?;
renderer.add_embedded_templates(embedded)?;

// Render
let output = renderer.render("name", &amp;data)?;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-dispatch"><a class="header" href="#introduction-to-dispatch">Introduction to Dispatch</a></h1>
<p>CLI applications typically mix business logic with output formatting: database queries interleaved with <code>println!</code>, validation tangled with ANSI codes, error handling scattered across presentation. The result is code that's hard to test, hard to change, and impossible to reuse.</p>
<p><code>standout-dispatch</code> enforces a clean separation:</p>
<pre><code class="language-text">CLI args → Handler (logic) → Data → Renderer (presentation) → Output
</code></pre>
<ul>
<li><strong>Handlers</strong> receive parsed arguments, return serializable data</li>
<li><strong>Renderers</strong> are pluggable callbacks you provide</li>
<li><strong>Hooks</strong> intercept execution at defined points</li>
</ul>
<p>This isn't just architectural nicety—it unlocks:</p>
<ul>
<li><strong>Testable handlers</strong> — Pure functions with explicit inputs and outputs</li>
<li><strong>Swappable renderers</strong> — JSON, templates, plain text from the same handler</li>
<li><strong>Cross-cutting concerns</strong> — Auth, logging, transformation via hooks</li>
<li><strong>Incremental adoption</strong> — Migrate one command at a time</li>
</ul>
<hr />
<h2 id="the-problem-1"><a class="header" href="#the-problem-1">The Problem</a></h2>
<p>Here's a typical CLI command implementation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn list_command(matches: &amp;ArgMatches) {
    let verbose = matches.get_flag("verbose");
    let items = storage::list().expect("failed to list");

    println!("\x1b[1;36mItems\x1b[0m");
    println!("──────");
    for item in &amp;items {
        if verbose {
            println!("{}: {} (created: {})", item.id, item.name, item.created);
        } else {
            println!("{}: {}", item.id, item.name);
        }
    }
    println!("\n{} items total", items.len());
}
<span class="boring">}</span></code></pre></pre>
<p>Problems with this approach:</p>
<ol>
<li><strong>Testing is painful</strong> — You have to capture stdout and parse it</li>
<li><strong>No format flexibility</strong> — Want JSON output? Write a whole new function</li>
<li><strong>Error handling is crude</strong> — <code>expect</code> or scattered error messages</li>
<li><strong>Logic and presentation intertwined</strong> — Can't reuse the logic elsewhere</li>
<li><strong>Cross-cutting concerns require duplication</strong> — Auth checks in every command</li>
</ol>
<hr />
<h2 id="the-solution-handlers-return-data"><a class="header" href="#the-solution-handlers-return-data">The Solution: Handlers Return Data</a></h2>
<p>With <code>standout-dispatch</code>, handlers focus purely on logic:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_dispatch::{Handler, Output, CommandContext, HandlerResult};
use serde::Serialize;

#[derive(Serialize)]
struct ListResult {
    items: Vec&lt;Item&gt;,
    total: usize,
}

fn list_handler(matches: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;ListResult&gt; {
    let items = storage::list()?;  // Errors propagate naturally
    Ok(Output::Render(ListResult {
        total: items.len(),
        items,
    }))
}
<span class="boring">}</span></code></pre></pre>
<p>The handler:</p>
<ul>
<li>Receives parsed arguments (<code>&amp;ArgMatches</code>) and execution context</li>
<li>Returns a <code>Result</code> with serializable data</li>
<li>Contains zero presentation logic</li>
</ul>
<p>Rendering is handled separately:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_dispatch::from_fn;

// Simple JSON renderer
let render = from_fn(|data, _view| {
    Ok(serde_json::to_string_pretty(data)?)
});
<span class="boring">}</span></code></pre></pre>
<p>Or use a full template engine:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let render = from_fn(move |data, view| {
    my_renderer::render_template(view, data, &amp;theme)
});
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="quick-start-1"><a class="header" href="#quick-start-1">Quick Start</a></h2>
<pre><code class="language-toml">[dependencies]
standout-dispatch = "2.1"
clap = { version = "4", features = ["derive"] }
serde = { version = "1", features = ["derive"] }
serde_json = "1"
anyhow = "1"
</code></pre>
<pre><pre class="playground"><code class="language-rust">use standout_dispatch::{
    FnHandler, Output, CommandContext, HandlerResult,
    from_fn, extract_command_path, path_to_string,
};
use clap::{Command, Arg};
use serde::Serialize;

#[derive(Serialize)]
struct Greeting { message: String }

fn main() -&gt; anyhow::Result&lt;()&gt; {
    // 1. Define clap command
    let cmd = Command::new("myapp")
        .subcommand(
            Command::new("greet")
                .arg(Arg::new("name").required(true))
        );

    // 2. Create handler
    let greet_handler = FnHandler::new(|matches, _ctx| {
        let name: &amp;String = matches.get_one("name").unwrap();
        Ok(Output::Render(Greeting {
            message: format!("Hello, {}!", name),
        }))
    });

    // 3. Create render function
    let render = from_fn(|data, _view| {
        Ok(serde_json::to_string_pretty(data)?)
    });

    // 4. Parse and dispatch
    let matches = cmd.get_matches();
    let path = extract_command_path(&amp;matches);

    if path_to_string(&amp;path) == "greet" {
        let ctx = CommandContext { command_path: path };
        let result = greet_handler.handle(&amp;matches, &amp;ctx)?;

        if let Output::Render(data) = result {
            let json = serde_json::to_value(&amp;data)?;
            let output = render(&amp;json, "greet")?;
            println!("{}", output);
        }
    }

    Ok(())
}</code></pre></pre>
<hr />
<h2 id="the-output-enum"><a class="header" href="#the-output-enum">The Output Enum</a></h2>
<p>Handlers return one of three output types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Output&lt;T: Serialize&gt; {
    Render(T),          // Data for rendering
    Silent,             // No output (side-effect commands)
    Binary {            // Raw bytes (file exports)
        data: Vec&lt;u8&gt;,
        filename: String,
    },
}
<span class="boring">}</span></code></pre></pre>
<h3 id="outputrendert"><a class="header" href="#outputrendert">Output::Render(T)</a></h3>
<p>The common case. Data is passed to your render function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn list_handler(_m: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;Vec&lt;Item&gt;&gt; {
    let items = storage::list()?;
    Ok(Output::Render(items))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="outputsilent"><a class="header" href="#outputsilent">Output::Silent</a></h3>
<p>For commands with side effects only:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn delete_handler(matches: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;()&gt; {
    let id: &amp;String = matches.get_one("id").unwrap();
    storage::delete(id)?;
    Ok(Output::Silent)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="outputbinary"><a class="header" href="#outputbinary">Output::Binary</a></h3>
<p>For generating files:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn export_handler(_m: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;()&gt; {
    let data = generate_report()?;
    let csv_bytes = format_as_csv(&amp;data)?;

    Ok(Output::Binary {
        data: csv_bytes.into_bytes(),
        filename: "report.csv".into(),
    })
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="hooks-cross-cutting-concerns"><a class="header" href="#hooks-cross-cutting-concerns">Hooks: Cross-Cutting Concerns</a></h2>
<p>Hooks let you intercept execution without modifying handler logic:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_dispatch::{Hooks, HookError, RenderedOutput};

let hooks = Hooks::new()
    // Before handler: validation, auth
    .pre_dispatch(|matches, ctx| {
        if !is_authenticated() {
            return Err(HookError::pre_dispatch("auth required"));
        }
        Ok(())
    })
    // After handler, before render: transform data
    .post_dispatch(|_m, _ctx, mut data| {
        if let Some(obj) = data.as_object_mut() {
            obj.insert("timestamp".into(), json!(Utc::now().to_rfc3339()));
        }
        Ok(data)
    })
    // After render: transform output
    .post_output(|_m, _ctx, output| {
        if let RenderedOutput::Text(s) = output {
            Ok(RenderedOutput::Text(format!("{}\n-- footer", s)))
        } else {
            Ok(output)
        }
    });
<span class="boring">}</span></code></pre></pre>
<h3 id="hook-phases"><a class="header" href="#hook-phases">Hook Phases</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Phase</th><th>Timing</th><th>Receives</th><th>Can</th></tr></thead><tbody>
<tr><td><code>pre_dispatch</code></td><td>Before handler</td><td>ArgMatches, Context</td><td>Abort execution</td></tr>
<tr><td><code>post_dispatch</code></td><td>After handler, before render</td><td>ArgMatches, Context, Data</td><td>Transform data</td></tr>
<tr><td><code>post_output</code></td><td>After render</td><td>ArgMatches, Context, Output</td><td>Transform output</td></tr>
</tbody></table>
</div>
<h3 id="hook-chaining"><a class="header" href="#hook-chaining">Hook Chaining</a></h3>
<p>Multiple hooks per phase run sequentially:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Hooks::new()
    .post_dispatch(add_metadata)      // Runs first
    .post_dispatch(filter_sensitive)  // Receives add_metadata's output
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="handler-types"><a class="header" href="#handler-types">Handler Types</a></h2>
<h3 id="closure-handlers"><a class="header" href="#closure-handlers">Closure Handlers</a></h3>
<p>Most handlers are simple closures:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let handler = FnHandler::new(|matches, ctx| {
    let name: &amp;String = matches.get_one("name").unwrap();
    Ok(Output::Render(Data { name: name.clone() }))
});
<span class="boring">}</span></code></pre></pre>
<h3 id="trait-implementations"><a class="header" href="#trait-implementations">Trait Implementations</a></h3>
<p>For handlers with internal state:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct DbHandler {
    pool: DatabasePool,
}

impl Handler for DbHandler {
    type Output = Vec&lt;Row&gt;;

    fn handle(&amp;self, matches: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;Vec&lt;Row&gt;&gt; {
        let query: &amp;String = matches.get_one("query").unwrap();
        let rows = self.pool.query(query)?;
        Ok(Output::Render(rows))
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="local-handlers-mutable-state"><a class="header" href="#local-handlers-mutable-state">Local Handlers (Mutable State)</a></h3>
<p>When handlers need <code>&amp;mut self</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl LocalHandler for Cache {
    type Output = Data;

    fn handle(&amp;mut self, matches: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;Data&gt; {
        self.invalidate();  // &amp;mut self works
        Ok(Output::Render(self.get()?))
    }
}
<span class="boring">}</span></code></pre></pre>
<p>See <a href="crates/dispatch/guides/../topics/handler-contract.html">Handler Contract</a> for full details.</p>
<hr />
<h2 id="command-routing-utilities"><a class="header" href="#command-routing-utilities">Command Routing Utilities</a></h2>
<p>Extract and navigate clap's <code>ArgMatches</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_dispatch::{
    extract_command_path,
    get_deepest_matches,
    has_subcommand,
    path_to_string,
};

// myapp db migrate --steps 5
let path = extract_command_path(&amp;matches);  // ["db", "migrate"]
let path_str = path_to_string(&amp;path);       // "db.migrate"
let deep = get_deepest_matches(&amp;matches);   // ArgMatches for "migrate"
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="testing-handlers"><a class="header" href="#testing-handlers">Testing Handlers</a></h2>
<p>Because handlers are pure functions, testing is straightforward:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_list_handler() {
    let cmd = Command::new("test")
        .arg(Arg::new("verbose").long("verbose").action(ArgAction::SetTrue));
    let matches = cmd.try_get_matches_from(["test", "--verbose"]).unwrap();

    let ctx = CommandContext {
        command_path: vec!["list".into()],
    };

    let result = list_handler(&amp;matches, &amp;ctx);

    assert!(result.is_ok());
    if let Ok(Output::Render(data)) = result {
        assert!(data.verbose);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>No mocking needed—construct <code>ArgMatches</code> with clap, call your handler, assert on the result.</p>
<hr />
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p><code>standout-dispatch</code> provides:</p>
<ol>
<li><strong>Clean separation</strong> — Handlers return data, renderers produce output</li>
<li><strong>Pluggable rendering</strong> — Use any output format without changing handlers</li>
<li><strong>Hook system</strong> — Cross-cutting concerns without code duplication</li>
<li><strong>Testable design</strong> — Handlers are pure functions with explicit contracts</li>
<li><strong>Incremental adoption</strong> — Migrate one command at a time</li>
</ol>
<p>For complete API details, see the <a href="https://docs.rs/standout-dispatch">API documentation</a>.</p>
<blockquote>
<p><strong>For standout framework users:</strong> The framework provides full integration with templates and themes. See the standout documentation for the <code>App</code> and <code>AppBuilder</code> APIs that wire dispatch and render together automatically.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-handler-contract"><a class="header" href="#the-handler-contract">The Handler Contract</a></h1>
<p>Handlers are where your application logic lives. The handler contract is designed to be <strong>explicit</strong> rather than permissive. By enforcing serializable return types and clear ownership semantics, the library guarantees that your code remains testable and decoupled from output formatting.</p>
<hr />
<h2 id="handler-modes"><a class="header" href="#handler-modes">Handler Modes</a></h2>
<p><code>standout-dispatch</code> supports two handler modes:</p>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th><code>Handler</code> (default)</th><th><code>LocalHandler</code></th></tr></thead><tbody>
<tr><td>Self reference</td><td><code>&amp;self</code></td><td><code>&amp;mut self</code></td></tr>
<tr><td>Closure type</td><td><code>Fn</code></td><td><code>FnMut</code></td></tr>
<tr><td>Thread bounds</td><td><code>Send + Sync</code></td><td>None</td></tr>
<tr><td>State mutation</td><td>Via interior mutability</td><td>Direct</td></tr>
<tr><td>Use case</td><td>Libraries, async, multi-threaded</td><td>Simple CLIs with mutable state</td></tr>
</tbody></table>
</div>
<p>Choose based on your needs:</p>
<ul>
<li>
<p><strong><code>Handler</code></strong>: Default. Use when handlers are stateless or use interior mutability (<code>Arc&lt;Mutex&lt;_&gt;&gt;</code>). Required for potential multi-threading.</p>
</li>
<li>
<p><strong><code>LocalHandler</code></strong>: Use when your handlers need <code>&amp;mut self</code> access without wrapper types. Ideal for single-threaded CLIs.</p>
</li>
</ul>
<hr />
<h2 id="the-handler-trait-thread-safe"><a class="header" href="#the-handler-trait-thread-safe">The Handler Trait (Thread-safe)</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Handler: Send + Sync {
    type Output: Serialize;
    fn handle(&amp;self, matches: &amp;ArgMatches, ctx: &amp;CommandContext) -&gt; HandlerResult&lt;Self::Output&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>Key constraints:</p>
<ul>
<li><strong>Send + Sync required</strong>: Handlers may be called from multiple threads</li>
<li><strong>Output must be Serialize</strong>: Needed for JSON/YAML modes and template context</li>
<li><strong>Immutable references</strong>: Handlers cannot modify arguments or context</li>
</ul>
<p>Implementing the trait directly is useful when your handler needs internal state—database connections, configuration, etc.</p>
<h3 id="example-struct-handler"><a class="header" href="#example-struct-handler">Example: Struct Handler</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_dispatch::{Handler, Output, CommandContext, HandlerResult};
use clap::ArgMatches;
use serde::Serialize;

struct DbHandler {
    pool: DatabasePool,
    config: Config,
}

impl Handler for DbHandler {
    type Output = Vec&lt;Row&gt;;

    fn handle(&amp;self, matches: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;Vec&lt;Row&gt;&gt; {
        let query: &amp;String = matches.get_one("query").unwrap();
        let rows = self.pool.query(query)?;
        Ok(Output::Render(rows))
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="closure-handlers-1"><a class="header" href="#closure-handlers-1">Closure Handlers</a></h2>
<p>Most handlers are simple closures using <code>FnHandler</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_dispatch::{FnHandler, Output, HandlerResult};

let handler = FnHandler::new(|matches, ctx| {
    let verbose = matches.get_flag("verbose");
    let items = storage::list()?;
    Ok(Output::Render(ListResult { items, verbose }))
});
<span class="boring">}</span></code></pre></pre>
<p>The closure signature:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn(&amp;ArgMatches, &amp;CommandContext) -&gt; HandlerResult&lt;T&gt;
where T: Serialize + Send + Sync
<span class="boring">}</span></code></pre></pre>
<p>Closures must be <code>Fn</code> (not <code>FnMut</code> or <code>FnOnce</code>) for thread safety.</p>
<hr />
<h2 id="the-localhandler-trait-mutable-state"><a class="header" href="#the-localhandler-trait-mutable-state">The LocalHandler Trait (Mutable State)</a></h2>
<p>When your handlers need <code>&amp;mut self</code> access—common with database connections, file caches, or in-memory indices:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait LocalHandler {
    type Output: Serialize;
    fn handle(&amp;mut self, matches: &amp;ArgMatches, ctx: &amp;CommandContext) -&gt; HandlerResult&lt;Self::Output&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>Key differences from <code>Handler</code>:</p>
<ul>
<li><strong>No Send + Sync</strong>: Handlers don't need to be thread-safe</li>
<li><strong>Mutable self</strong>: <code>&amp;mut self</code> allows direct state modification</li>
<li><strong>FnMut closures</strong>: Captured variables can be mutated</li>
</ul>
<h3 id="when-to-use-localhandler"><a class="header" href="#when-to-use-localhandler">When to Use LocalHandler</a></h3>
<p>Use <code>LocalHandler</code> when:</p>
<ul>
<li>Your API uses <code>&amp;mut self</code> methods (common for file/database operations)</li>
<li>You want to avoid <code>Arc&lt;Mutex&lt;_&gt;&gt;</code> wrappers</li>
<li>Your CLI is single-threaded (the typical case)</li>
</ul>
<h3 id="example-localhandler-with-cache"><a class="header" href="#example-localhandler-with-cache">Example: LocalHandler with Cache</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_dispatch::{LocalHandler, Output, CommandContext, HandlerResult};

struct CachingDatabase {
    connection: Connection,
    cache: HashMap&lt;String, Record&gt;,
}

impl CachingDatabase {
    fn query_with_cache(&amp;mut self, sql: &amp;str) -&gt; Result&lt;Vec&lt;Row&gt;, Error&gt; {
        if let Some(cached) = self.cache.get(sql) {
            return Ok(cached.clone());
        }
        let result = self.connection.execute(sql)?;
        self.cache.insert(sql.to_string(), result.clone());
        Ok(result)
    }
}

impl LocalHandler for CachingDatabase {
    type Output = Vec&lt;Row&gt;;

    fn handle(&amp;mut self, matches: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;Vec&lt;Row&gt;&gt; {
        let query: &amp;String = matches.get_one("query").unwrap();
        let rows = self.query_with_cache(query)?;
        Ok(Output::Render(rows))
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="local-closure-handlers"><a class="header" href="#local-closure-handlers">Local Closure Handlers</a></h3>
<p><code>LocalFnHandler</code> accepts <code>FnMut</code> closures:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_dispatch::LocalFnHandler;

let mut counter = 0;

let handler = LocalFnHandler::new(move |_matches, _ctx| {
    counter += 1;  // Mutation works!
    Ok(Output::Render(counter))
});
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="handlerresult"><a class="header" href="#handlerresult">HandlerResult</a></h2>
<p><code>HandlerResult&lt;T&gt;</code> is a standard <code>Result</code> type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type HandlerResult&lt;T&gt; = Result&lt;Output&lt;T&gt;, anyhow::Error&gt;;
<span class="boring">}</span></code></pre></pre>
<p>The <code>?</code> operator works naturally for error propagation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn list_handler(matches: &amp;ArgMatches, ctx: &amp;CommandContext) -&gt; HandlerResult&lt;Items&gt; {
    let items = storage::load()?;           // Propagates errors
    let filtered = filter_items(&amp;items)?;   // Propagates errors
    Ok(Output::Render(Items { filtered }))
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="the-output-enum-1"><a class="header" href="#the-output-enum-1">The Output Enum</a></h2>
<p><code>Output&lt;T&gt;</code> represents what a handler produces:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Output&lt;T: Serialize&gt; {
    Render(T),
    Silent,
    Binary { data: Vec&lt;u8&gt;, filename: String },
}
<span class="boring">}</span></code></pre></pre>
<h3 id="outputrendert-1"><a class="header" href="#outputrendert-1">Output::Render(T)</a></h3>
<p>The common case. Data is passed to the render function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize)]
struct ListResult {
    items: Vec&lt;Item&gt;,
    total: usize,
}

fn list_handler(_m: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;ListResult&gt; {
    let items = storage::list()?;
    Ok(Output::Render(ListResult {
        total: items.len(),
        items,
    }))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="outputsilent-1"><a class="header" href="#outputsilent-1">Output::Silent</a></h3>
<p>No output produced. Useful for commands with side effects only:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn delete_handler(matches: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;()&gt; {
    let id: &amp;String = matches.get_one("id").unwrap();
    storage::delete(id)?;
    Ok(Output::Silent)
}
<span class="boring">}</span></code></pre></pre>
<p>Silent behavior:</p>
<ul>
<li>Post-output hooks still receive <code>RenderedOutput::Silent</code></li>
<li>Render function is not called</li>
<li>Nothing prints to stdout</li>
</ul>
<h3 id="outputbinary-1"><a class="header" href="#outputbinary-1">Output::Binary</a></h3>
<p>Raw bytes for file output:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn export_handler(matches: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;()&gt; {
    let data = generate_report()?;
    let pdf_bytes = render_to_pdf(&amp;data)?;

    Ok(Output::Binary {
        data: pdf_bytes,
        filename: "report.pdf".into(),
    })
}
<span class="boring">}</span></code></pre></pre>
<p>Binary output bypasses the render function entirely.</p>
<hr />
<h2 id="commandcontext"><a class="header" href="#commandcontext">CommandContext</a></h2>
<p><code>CommandContext</code> provides execution environment information:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CommandContext {
    pub command_path: Vec&lt;String&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>command_path</strong>: The subcommand chain as a vector, e.g., <code>["db", "migrate"]</code>. Useful for logging or conditional logic.</p>
<p><code>CommandContext</code> is intentionally minimal. Application-specific context (config, connections) should be captured in struct handlers or closures:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyHandler {
    db: DatabasePool,
    config: AppConfig,
}

impl Handler for MyHandler {
    type Output = Data;

    fn handle(&amp;self, matches: &amp;ArgMatches, ctx: &amp;CommandContext) -&gt; HandlerResult&lt;Data&gt; {
        let result = self.db.query(...)?;
        Ok(Output::Render(result))
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="accessing-cli-arguments"><a class="header" href="#accessing-cli-arguments">Accessing CLI Arguments</a></h2>
<p>The <code>ArgMatches</code> parameter provides access to parsed arguments through clap's standard API:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handler(matches: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;Data&gt; {
    // Flags
    let verbose = matches.get_flag("verbose");

    // Required options
    let name: &amp;String = matches.get_one("name").unwrap();

    // Optional values
    let limit: Option&lt;&amp;u32&gt; = matches.get_one("limit");

    // Multiple values
    let tags: Vec&lt;&amp;String&gt; = matches.get_many("tags")
        .map(|v| v.collect())
        .unwrap_or_default();

    Ok(Output::Render(Data { ... }))
}
<span class="boring">}</span></code></pre></pre>
<p>For subcommands, you work with the <code>ArgMatches</code> for your specific command level.</p>
<hr />
<h2 id="testing-handlers-1"><a class="header" href="#testing-handlers-1">Testing Handlers</a></h2>
<p>Because handlers are pure functions with explicit inputs and outputs, they're straightforward to test:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_list_handler() {
    let cmd = Command::new("test")
        .arg(Arg::new("verbose").long("verbose").action(ArgAction::SetTrue));
    let matches = cmd.try_get_matches_from(["test", "--verbose"]).unwrap();

    let ctx = CommandContext {
        command_path: vec!["list".into()],
    };

    let result = list_handler(&amp;matches, &amp;ctx);

    assert!(result.is_ok());
    if let Ok(Output::Render(data)) = result {
        assert!(data.verbose);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>No mocking frameworks needed—construct <code>ArgMatches</code> with clap, create a <code>CommandContext</code>, call your handler, assert on the result.</p>
<h3 id="testing-localhandlers"><a class="header" href="#testing-localhandlers">Testing LocalHandlers</a></h3>
<p><code>LocalHandler</code> tests work the same way, but use <code>&amp;mut self</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_local_handler_state_mutation() {
    struct Counter { count: u32 }

    impl LocalHandler for Counter {
        type Output = u32;
        fn handle(&amp;mut self, _m: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;u32&gt; {
            self.count += 1;
            Ok(Output::Render(self.count))
        }
    }

    let mut handler = Counter { count: 0 };
    let cmd = Command::new("test");
    let matches = cmd.try_get_matches_from(["test"]).unwrap();
    let ctx = CommandContext {
        command_path: vec!["count".into()],
    };

    // State accumulates across calls
    let _ = handler.handle(&amp;matches, &amp;ctx);
    let _ = handler.handle(&amp;matches, &amp;ctx);
    let result = handler.handle(&amp;matches, &amp;ctx);

    assert!(matches!(result, Ok(Output::Render(3))));
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="choosing-between-handler-and-localhandler"><a class="header" href="#choosing-between-handler-and-localhandler">Choosing Between Handler and LocalHandler</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Your situation</th><th>Use</th></tr></thead><tbody>
<tr><td>Stateless handlers</td><td><code>FnHandler</code> + closures</td></tr>
<tr><td>State with <code>Arc&lt;Mutex&lt;_&gt;&gt;</code> already</td><td><code>Handler</code> trait</td></tr>
<tr><td>API with <code>&amp;mut self</code> methods</td><td><code>LocalHandler</code> trait</td></tr>
<tr><td>Building a library</td><td><code>Handler</code> (consumers might need thread safety)</td></tr>
<tr><td>Simple single-threaded CLI</td><td>Either works; <code>LocalHandler</code> avoids wrapper types</td></tr>
</tbody></table>
</div>
<p>The key insight: CLIs are fundamentally single-threaded (parse → run one handler → output → exit). The <code>Send + Sync</code> requirement in <code>Handler</code> is conventional, not strictly necessary. <code>LocalHandler</code> removes this requirement for simpler code when thread safety isn't needed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="execution-model"><a class="header" href="#execution-model">Execution Model</a></h1>
<p><code>standout-dispatch</code> manages a strict linear pipeline from CLI input to rendered output. This explicitly separated flow ensures that logic (handlers) remains decoupled from presentation (renderers) and side-effects (hooks).</p>
<hr />
<h2 id="the-pipeline"><a class="header" href="#the-pipeline">The Pipeline</a></h2>
<pre><code class="language-text">Clap Parsing → Pre-dispatch Hook → Handler → Post-dispatch Hook → Renderer → Post-output Hook → Output
</code></pre>
<p>Each stage has a clear responsibility:</p>
<p><strong>Clap Parsing</strong>: Your <code>clap::Command</code> definition is parsed normally. <code>standout-dispatch</code> doesn't replace clap—it works with the resulting <code>ArgMatches</code>.</p>
<p><strong>Pre-dispatch Hook</strong>: Runs before the handler. Can abort execution (e.g., auth checks).</p>
<p><strong>Handler</strong>: Your logic function executes. It receives <code>ArgMatches</code> and <code>CommandContext</code>, returning a <code>HandlerResult&lt;T&gt;</code>—either data to render, a silent marker, or binary content.</p>
<p><strong>Post-dispatch Hook</strong>: Runs after the handler, before rendering. Can transform data.</p>
<p><strong>Renderer</strong>: Your render function receives the data and produces output (string or binary).</p>
<p><strong>Post-output Hook</strong>: Runs after rendering. Can transform the final output.</p>
<p><strong>Output</strong>: The result is returned or written to stdout.</p>
<hr />
<h2 id="command-paths"><a class="header" href="#command-paths">Command Paths</a></h2>
<p>A command path is a vector of strings representing the subcommand chain:</p>
<pre><code class="language-bash">myapp db migrate --steps 5
</code></pre>
<p>The command path is <code>["db", "migrate"]</code>.</p>
<h3 id="extracting-command-paths"><a class="header" href="#extracting-command-paths">Extracting Command Paths</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_dispatch::{extract_command_path, path_to_string, get_deepest_matches};

let matches = cmd.get_matches();

// Get the full path
let path = extract_command_path(&amp;matches);  // ["db", "migrate"]

// Convert to dot notation
let path_str = path_to_string(&amp;path);  // "db.migrate"

// Get ArgMatches for the deepest command
let deep = get_deepest_matches(&amp;matches);  // ArgMatches for "migrate"
<span class="boring">}</span></code></pre></pre>
<h3 id="command-path-utilities"><a class="header" href="#command-path-utilities">Command Path Utilities</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Purpose</th></tr></thead><tbody>
<tr><td><code>extract_command_path</code></td><td>Get subcommand chain as <code>Vec&lt;String&gt;</code></td></tr>
<tr><td><code>path_to_string</code></td><td>Convert path to dot notation (<code>"db.migrate"</code>)</td></tr>
<tr><td><code>string_to_path</code></td><td>Convert dot notation to path</td></tr>
<tr><td><code>get_deepest_matches</code></td><td>Get <code>ArgMatches</code> for deepest subcommand</td></tr>
<tr><td><code>has_subcommand</code></td><td>Check if any subcommand was invoked</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="the-hooks-system"><a class="header" href="#the-hooks-system">The Hooks System</a></h2>
<p>Hooks are functions that run at specific points in the pipeline. They let you intercept, validate, or transform without touching handler logic—keeping concerns separated.</p>
<h3 id="three-phases"><a class="header" href="#three-phases">Three Phases</a></h3>
<p><strong>Pre-dispatch</strong>: Runs before the handler. Can abort execution.</p>
<p>Use for: authentication checks, input validation, logging start time.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_dispatch::{Hooks, HookError};

Hooks::new().pre_dispatch(|matches, ctx| {
    if !is_authenticated() {
        return Err(HookError::pre_dispatch("authentication required"));
    }
    Ok(())
})
<span class="boring">}</span></code></pre></pre>
<p><strong>Post-dispatch</strong>: Runs after the handler, before rendering. Can transform data.</p>
<p>Use for: adding timestamps, filtering sensitive fields, data enrichment. The hook receives handler output as <code>serde_json::Value</code>, allowing generic transformations regardless of the handler's output type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Hooks::new().post_dispatch(|_matches, _ctx, mut data| {
    if let Some(obj) = data.as_object_mut() {
        obj.insert("generated_at".into(), json!(Utc::now().to_rfc3339()));
    }
    Ok(data)
})
<span class="boring">}</span></code></pre></pre>
<p><strong>Post-output</strong>: Runs after rendering. Can transform the final string.</p>
<p>Use for: adding headers/footers, logging, metrics. The hook receives <code>RenderedOutput</code>—an enum of <code>Text(String)</code>, <code>Binary(Vec&lt;u8&gt;, String)</code>, or <code>Silent</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_dispatch::RenderedOutput;

Hooks::new().post_output(|_matches, _ctx, output| {
    match output {
        RenderedOutput::Text(s) =&gt; {
            Ok(RenderedOutput::Text(format!("{}\n-- Generated by MyApp", s)))
        }
        other =&gt; Ok(other),
    }
})
<span class="boring">}</span></code></pre></pre>
<h3 id="hook-chaining-1"><a class="header" href="#hook-chaining-1">Hook Chaining</a></h3>
<p>Multiple hooks per phase are supported. Pre-dispatch hooks run sequentially—first error aborts. Post-dispatch and post-output hooks <em>chain</em>: each receives the output of the previous, enabling composable transformations.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Hooks::new()
    .post_dispatch(add_metadata)      // Runs first
    .post_dispatch(filter_sensitive)  // Receives add_metadata's output
<span class="boring">}</span></code></pre></pre>
<p>Order matters: <code>filter_sensitive</code> sees the metadata that <code>add_metadata</code> inserted.</p>
<h3 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h3>
<p>When a hook returns <code>Err(HookError)</code>:</p>
<ul>
<li>Execution stops immediately</li>
<li>Remaining hooks in that phase don't run</li>
<li>For pre-dispatch: the handler never executes</li>
<li>For post phases: the rendered output is discarded</li>
<li>The error message is returned</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_dispatch::HookError;

// Create error with phase context
HookError::pre_dispatch("database connection failed")

// With source error for debugging
HookError::post_dispatch("transformation failed")
    .with_source(underlying_error)
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="render-handlers"><a class="header" href="#render-handlers">Render Handlers</a></h2>
<p>The render handler is a pluggable callback that converts data to output:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_dispatch::{from_fn, RenderFn};

// Simple JSON renderer
let render: RenderFn = from_fn(|data, _view| {
    Ok(serde_json::to_string_pretty(data)?)
});
<span class="boring">}</span></code></pre></pre>
<h3 id="render-function-signature"><a class="header" href="#render-function-signature">Render Function Signature</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn(&amp;serde_json::Value, &amp;str) -&gt; Result&lt;String, RenderError&gt;
<span class="boring">}</span></code></pre></pre>
<p>Parameters:</p>
<ul>
<li><code>data</code>: The serialized handler output</li>
<li><code>view</code>: A view/template name hint (can be ignored)</li>
</ul>
<h3 id="using-view-names"><a class="header" href="#using-view-names">Using View Names</a></h3>
<p>The <code>view</code> parameter enables template-based rendering:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let render = from_fn(move |data, view| {
    match view {
        "list" =&gt; format_as_list(data),
        "detail" =&gt; format_as_detail(data),
        _ =&gt; Ok(serde_json::to_string_pretty(data)?),
    }
});
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>For standout framework users:</strong> The framework automatically maps view names to template files. See standout documentation for details.</p>
</blockquote>
<h3 id="local-render-functions"><a class="header" href="#local-render-functions">Local Render Functions</a></h3>
<p>For render functions that need mutable state:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_dispatch::{from_fn_mut, LocalRenderFn};

let render: LocalRenderFn = from_fn_mut(|data, view| {
    // Can capture and mutate state
    Ok(format_data(data))
});
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="default-command-support"><a class="header" href="#default-command-support">Default Command Support</a></h2>
<p>Handle the case when no subcommand is specified:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_dispatch::{has_subcommand, insert_default_command};

let matches = cmd.get_matches_from(args);

if !has_subcommand(&amp;matches) {
    // Re-parse with default command inserted
    let args_with_default = insert_default_command(std::env::args(), "list");
    let matches = cmd.get_matches_from(args_with_default);
    // Now dispatch to "list"
}
<span class="boring">}</span></code></pre></pre>
<p><code>insert_default_command</code> inserts the command name after the binary name but before any flags.</p>
<hr />
<h2 id="putting-it-together"><a class="header" href="#putting-it-together">Putting It Together</a></h2>
<p>A complete dispatch flow:</p>
<pre><pre class="playground"><code class="language-rust">use standout_dispatch::{
    FnHandler, Output, CommandContext, Hooks, HookError,
    from_fn, extract_command_path, get_deepest_matches, path_to_string,
};

fn main() -&gt; anyhow::Result&lt;()&gt; {
    // 1. Define clap command
    let cmd = Command::new("myapp")
        .subcommand(Command::new("list"))
        .subcommand(Command::new("delete").arg(Arg::new("id").required(true)));

    // 2. Create handlers
    let list_handler = FnHandler::new(|_m, _ctx| {
        Ok(Output::Render(storage::list()?))
    });

    let delete_handler = FnHandler::new(|matches, _ctx| {
        let id: &amp;String = matches.get_one("id").unwrap();
        storage::delete(id)?;
        Ok(Output::Silent)
    });

    // 3. Create render function
    let render = from_fn(|data, _view| {
        Ok(serde_json::to_string_pretty(data)?)
    });

    // 4. Create hooks
    let hooks = Hooks::new()
        .pre_dispatch(|_m, _ctx| {
            println!("Starting command...");
            Ok(())
        });

    // 5. Parse and dispatch
    let matches = cmd.get_matches();
    let path = extract_command_path(&amp;matches);
    let ctx = CommandContext { command_path: path.clone() };

    // Run pre-dispatch hooks
    hooks.run_pre_dispatch(&amp;matches, &amp;ctx)?;

    // Dispatch based on command
    let result = match path_to_string(&amp;path).as_str() {
        "list" =&gt; {
            let output = list_handler.handle(&amp;matches, &amp;ctx)?;
            if let Output::Render(data) = output {
                let json = serde_json::to_value(&amp;data)?;
                let rendered = render(&amp;json, "list")?;
                println!("{}", rendered);
            }
        }
        "delete" =&gt; {
            let deep = get_deepest_matches(&amp;matches);
            delete_handler.handle(deep, &amp;ctx)?;
            println!("Deleted.");
        }
        _ =&gt; eprintln!("Unknown command"),
    };

    Ok(())
}</code></pre></pre>
<hr />
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<p>The execution model provides:</p>
<ol>
<li><strong>Clear pipeline</strong> — Each stage has defined inputs and outputs</li>
<li><strong>Hook points</strong> — Intercept before, after handler, and after render</li>
<li><strong>Command routing</strong> — Utilities for navigating subcommand hierarchies</li>
<li><strong>Pluggable rendering</strong> — Render functions are separate from handlers</li>
<li><strong>Testable stages</strong> — Each component can be tested in isolation</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="partial-adoption"><a class="header" href="#partial-adoption">Partial Adoption</a></h1>
<p>One of the key benefits of <code>standout-dispatch</code> is that you don't need to adopt it all at once. You can migrate one command at a time, keeping existing code alongside dispatch-managed commands.</p>
<hr />
<h2 id="the-problem-with-all-or-nothing-frameworks"><a class="header" href="#the-problem-with-all-or-nothing-frameworks">The Problem with All-or-Nothing Frameworks</a></h2>
<p>Many CLI frameworks require a complete rewrite:</p>
<ul>
<li>All commands must use the framework's patterns</li>
<li>Existing code can't coexist with framework code</li>
<li>Migration is a massive undertaking</li>
<li>Risk is concentrated in a single change</li>
</ul>
<p><code>standout-dispatch</code> is designed differently. It's a library, not a framework—you call it, it doesn't call you.</p>
<hr />
<h2 id="strategy-migrate-one-command-at-a-time"><a class="header" href="#strategy-migrate-one-command-at-a-time">Strategy: Migrate One Command at a Time</a></h2>
<h3 id="step-1-identify-a-good-starting-command"><a class="header" href="#step-1-identify-a-good-starting-command">Step 1: Identify a Good Starting Command</a></h3>
<p>Pick a command that:</p>
<ul>
<li>Is self-contained (few dependencies on other commands)</li>
<li>Has clear inputs and outputs</li>
<li>Would benefit from structured output (JSON, etc.)</li>
<li>Has existing tests you can update</li>
</ul>
<h3 id="step-2-create-the-handler"><a class="header" href="#step-2-create-the-handler">Step 2: Create the Handler</a></h3>
<p>Convert the command's logic to a handler:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Before: mixed logic and output
fn list_command(matches: &amp;ArgMatches) {
    let items = storage::list().unwrap();
    for item in items {
        println!("{}: {}", item.id, item.name);
    }
}

// After: handler returns data
fn list_handler(_m: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;Vec&lt;Item&gt;&gt; {
    let items = storage::list()?;
    Ok(Output::Render(items))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="step-3-set-up-dispatch-for-that-command"><a class="header" href="#step-3-set-up-dispatch-for-that-command">Step 3: Set Up Dispatch for That Command</a></h3>
<pre><pre class="playground"><code class="language-rust">use standout_dispatch::{FnHandler, from_fn, extract_command_path, path_to_string};

fn main() {
    let cmd = build_clap_command();  // Your existing clap definition
    let matches = cmd.get_matches();
    let path = extract_command_path(&amp;matches);

    // Dispatch-managed command
    if path_to_string(&amp;path) == "list" {
        let handler = FnHandler::new(list_handler);
        let render = from_fn(|data, _| Ok(serde_json::to_string_pretty(data)?));

        let ctx = CommandContext { command_path: path };
        if let Ok(Output::Render(data)) = handler.handle(&amp;matches, &amp;ctx) {
            let json = serde_json::to_value(&amp;data).unwrap();
            println!("{}", render(&amp;json, "list").unwrap());
        }
        return;
    }

    // Fall back to existing code for other commands
    match matches.subcommand() {
        Some(("add", sub)) =&gt; add_command(sub),
        Some(("delete", sub)) =&gt; delete_command(sub),
        _ =&gt; {}
    }
}</code></pre></pre>
<h3 id="step-4-repeat"><a class="header" href="#step-4-repeat">Step 4: Repeat</a></h3>
<p>Migrate one command at a time. Each migration:</p>
<ul>
<li>Is a small, reviewable change</li>
<li>Can be tested independently</li>
<li>Doesn't affect other commands</li>
<li>Is easy to roll back if needed</li>
</ul>
<hr />
<h2 id="coexistence-patterns"><a class="header" href="#coexistence-patterns">Coexistence Patterns</a></h2>
<h3 id="pattern-1-check-path-first"><a class="header" href="#pattern-1-check-path-first">Pattern 1: Check Path First</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let path = extract_command_path(&amp;matches);

// Dispatch-managed commands
let dispatch_commands = ["list", "show", "export"];
if dispatch_commands.contains(&amp;path_to_string(&amp;path).as_str()) {
    dispatch_command(&amp;matches, &amp;path);
    return;
}

// Legacy commands
legacy_dispatch(&amp;matches);
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-2-try-dispatch-fall-back"><a class="header" href="#pattern-2-try-dispatch-fall-back">Pattern 2: Try Dispatch, Fall Back</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(result) = try_dispatch(&amp;matches) {
    handle_dispatch_result(result);
} else {
    // Not a dispatch-managed command
    legacy_dispatch(&amp;matches);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-3-wrapper-function"><a class="header" href="#pattern-3-wrapper-function">Pattern 3: Wrapper Function</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_command(matches: &amp;ArgMatches) {
    let path = extract_command_path(matches);

    match path_to_string(&amp;path).as_str() {
        // New dispatch-based handlers
        "list" =&gt; run_with_dispatch(list_handler, matches, &amp;path),
        "show" =&gt; run_with_dispatch(show_handler, matches, &amp;path),

        // Legacy handlers (unchanged)
        "add" =&gt; add_command(get_deepest_matches(matches)),
        "delete" =&gt; delete_command(get_deepest_matches(matches)),

        _ =&gt; eprintln!("Unknown command"),
    }
}

fn run_with_dispatch&lt;T: Serialize&gt;(
    handler: impl Fn(&amp;ArgMatches, &amp;CommandContext) -&gt; HandlerResult&lt;T&gt;,
    matches: &amp;ArgMatches,
    path: &amp;[String],
) {
    let ctx = CommandContext { command_path: path.to_vec() };
    match handler(matches, &amp;ctx) {
        Ok(Output::Render(data)) =&gt; {
            let json = serde_json::to_value(&amp;data).unwrap();
            println!("{}", serde_json::to_string_pretty(&amp;json).unwrap());
        }
        Ok(Output::Silent) =&gt; {}
        Ok(Output::Binary { data, filename }) =&gt; {
            std::fs::write(&amp;filename, &amp;data).unwrap();
        }
        Err(e) =&gt; eprintln!("Error: {}", e),
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="benefits-during-migration"><a class="header" href="#benefits-during-migration">Benefits During Migration</a></h2>
<h3 id="immediate-benefits-per-command"><a class="header" href="#immediate-benefits-per-command">Immediate Benefits per Command</a></h3>
<p>Each migrated command gains:</p>
<ol>
<li><strong>Structured output</strong> — JSON/YAML support</li>
<li><strong>Testable logic</strong> — Handler is a pure function</li>
<li><strong>Error handling</strong> — <code>?</code> operator, proper error types</li>
<li><strong>Hook points</strong> — Add logging, auth without touching handler</li>
</ol>
<h3 id="progressive-enhancement"><a class="header" href="#progressive-enhancement">Progressive Enhancement</a></h3>
<p>As you migrate more commands:</p>
<ol>
<li><strong>Shared hooks</strong> — Apply auth check to all migrated commands</li>
<li><strong>Consistent output</strong> — Same renderer for all commands</li>
<li><strong>Unified error handling</strong> — Errors formatted consistently</li>
</ol>
<hr />
<h2 id="migration-checklist"><a class="header" href="#migration-checklist">Migration Checklist</a></h2>
<p>For each command:</p>
<ul>
<li><input disabled="" type="checkbox"/>
Create data types (<code>#[derive(Serialize)]</code>)</li>
<li><input disabled="" type="checkbox"/>
Write handler function</li>
<li><input disabled="" type="checkbox"/>
Add to dispatch routing</li>
<li><input disabled="" type="checkbox"/>
Update tests to test handler directly</li>
<li><input disabled="" type="checkbox"/>
Verify existing behavior unchanged</li>
<li><input disabled="" type="checkbox"/>
Document the migration</li>
</ul>
<hr />
<h2 id="example-full-migration"><a class="header" href="#example-full-migration">Example: Full Migration</a></h2>
<p>Before (monolithic):</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let matches = build_cli().get_matches();

    match matches.subcommand() {
        Some(("list", sub)) =&gt; list_command(sub),
        Some(("add", sub)) =&gt; add_command(sub),
        Some(("delete", sub)) =&gt; delete_command(sub),
        Some(("export", sub)) =&gt; export_command(sub),
        _ =&gt; {}
    }
}</code></pre></pre>
<p>After (gradual migration):</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let matches = build_cli().get_matches();
    let path = extract_command_path(&amp;matches);

    // Dispatch-managed (migrated)
    if let Some(result) = dispatch_if_managed(&amp;matches, &amp;path) {
        return;
    }

    // Legacy (not yet migrated)
    match matches.subcommand() {
        Some(("add", sub)) =&gt; add_command(sub),
        Some(("delete", sub)) =&gt; delete_command(sub),
        _ =&gt; {}
    }
}

fn dispatch_if_managed(matches: &amp;ArgMatches, path: &amp;[String]) -&gt; Option&lt;()&gt; {
    let ctx = CommandContext { command_path: path.to_vec() };
    let render = from_fn(|data, _| Ok(serde_json::to_string_pretty(data)?));

    let result = match path_to_string(path).as_str() {
        "list" =&gt; list_handler(matches, &amp;ctx),
        "export" =&gt; export_handler(matches, &amp;ctx),
        _ =&gt; return None,  // Not managed by dispatch
    };

    match result {
        Ok(Output::Render(data)) =&gt; {
            let json = serde_json::to_value(&amp;data).ok()?;
            println!("{}", render(&amp;json, "").ok()?);
        }
        Ok(Output::Silent) =&gt; {}
        Ok(Output::Binary { data, filename }) =&gt; {
            std::fs::write(&amp;filename, &amp;data).ok()?;
        }
        Err(e) =&gt; eprintln!("Error: {}", e),
    }

    Some(())
}</code></pre></pre>
<hr />
<h2 id="summary-4"><a class="header" href="#summary-4">Summary</a></h2>
<p>Partial adoption lets you:</p>
<ol>
<li><strong>Start small</strong> — Migrate one command at a time</li>
<li><strong>Reduce risk</strong> — Each migration is independent</li>
<li><strong>Maintain velocity</strong> — Keep shipping while migrating</li>
<li><strong>Validate benefits</strong> — See the value before full commitment</li>
</ol>
<p>The goal is pragmatic improvement, not architectural purity. Migrate what benefits most, leave what works alone.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="output-modes-1"><a class="header" href="#output-modes-1">Output Modes</a></h1>
<p>Standout supports multiple output formats through a single handler because modern CLI tools serve two masters: human operators and machine automation.</p>
<p>The same handler logic produces styled terminal output for eyes, plain text for logs, or structured JSON for <code>jq</code> pipelines—controlled entirely by the user's <code>--output</code> flag. This frees you from writing separate "API" and "CLI" logic.</p>
<h2 id="the-outputmode-enum"><a class="header" href="#the-outputmode-enum">The OutputMode Enum</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum OutputMode {
    Auto,       // Auto-detect terminal capabilities
    Term,       // Always use ANSI escape codes
    Text,       // Never use ANSI codes (plain text)
    TermDebug,  // Keep style tags as [name]...[/name]
    Json,       // Serialize as JSON (skip template)
    Yaml,       // Serialize as YAML (skip template)
    Xml,        // Serialize as XML (skip template)
    Csv,        // Serialize as CSV (skip template)
}
<span class="boring">}</span></code></pre></pre>
<p>Three categories:</p>
<p><strong>Templated modes</strong> (Auto, Term, Text): Render the template, vary ANSI handling.</p>
<p><strong>Debug mode</strong> (TermDebug): Render the template, keep tags as literals for inspection.</p>
<p><strong>Structured modes</strong> (Json, Yaml, Xml, Csv): Skip the template entirely, serialize handler data directly.</p>
<h2 id="auto-mode-1"><a class="header" href="#auto-mode-1">Auto Mode</a></h2>
<p><code>Auto</code> is the default. It queries the terminal for color support:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Term::stdout().features().colors_supported()
<span class="boring">}</span></code></pre></pre>
<p>If colors are supported, Auto behaves like Term (ANSI codes applied). If not, Auto behaves like Text (tags stripped).</p>
<p>This detection happens at render time, not startup. Piping output to a file or another process typically disables color support, so:</p>
<pre><code class="language-bash">myapp list              # Colors (if terminal supports)
myapp list &gt; file.txt   # No colors (not a TTY)
myapp list | less       # No colors (pipe)
</code></pre>
<h2 id="the---output-flag"><a class="header" href="#the---output-flag">The --output Flag</a></h2>
<p>Standout adds a global <code>--output</code> flag accepting these values:</p>
<pre><code class="language-bash">myapp list --output=auto        # Default
myapp list --output=term        # Force ANSI codes
myapp list --output=text        # Force plain text
myapp list --output=term-debug  # Show style tags
myapp list --output=json        # JSON serialization
myapp list --output=yaml        # YAML serialization
myapp list --output=xml         # XML serialization
myapp list --output=csv         # CSV serialization
</code></pre>
<p>The flag is global—it applies to all subcommands.</p>
<h2 id="term-vs-text"><a class="header" href="#term-vs-text">Term vs Text</a></h2>
<p><strong>Term</strong>: Always applies ANSI escape codes, even when piping:</p>
<pre><code class="language-bash">myapp list --output=term &gt; colored.txt
</code></pre>
<p>Useful when you want to preserve colors for later display (e.g., <code>less -R</code>).</p>
<p><strong>Text</strong>: Never applies ANSI codes:</p>
<pre><code class="language-bash">myapp list --output=text
</code></pre>
<p>Useful for clean output regardless of terminal capabilities, or when processing output with other tools.</p>
<h2 id="termdebug-mode"><a class="header" href="#termdebug-mode">TermDebug Mode</a></h2>
<p>TermDebug preserves style tags instead of converting them:</p>
<pre><code class="language-text">Template: [title]Hello[/title]
Output:   [title]Hello[/title]
</code></pre>
<p>Use cases:</p>
<ul>
<li>Debugging template issues</li>
<li>Verifying style tag placement</li>
<li>Automated testing of template output</li>
</ul>
<p>Unlike Term mode, unknown tags don't get the <code>?</code> marker in TermDebug.</p>
<h2 id="structured-modes"><a class="header" href="#structured-modes">Structured Modes</a></h2>
<p>Structured modes bypass the template entirely. Handler data is serialized directly:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize)]
struct ListOutput {
    items: Vec&lt;Item&gt;,
    total: usize,
}

fn list_handler(...) -&gt; HandlerResult&lt;ListOutput&gt; {
    Ok(Output::Render(ListOutput { items, total: items.len() }))
}
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-bash">myapp list --output=json
</code></pre>
<pre><code class="language-json">{
  "items": [...],
  "total": 42
}
</code></pre>
<p>Same handler, same types—different output format. This enables:</p>
<ul>
<li>Machine-readable output for scripts</li>
<li>Integration with other tools (<code>jq</code>, etc.)</li>
<li>API-like behavior from CLI apps</li>
</ul>
<h3 id="csv-output"><a class="header" href="#csv-output">CSV Output</a></h3>
<p>CSV mode flattens nested JSON automatically. For more control, use <code>FlatDataSpec</code>.</p>
<p>See <a href="topics/tabular.html">Tabular Layout</a> for detailed CSV configuration.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let spec = FlatDataSpec::builder()
    .column(Column::new(Width::Fixed(10)).key("name").header("Name"))
    .column(Column::new(Width::Fixed(10)).key("meta.role").header("Role"))
    .build();

render_auto_with_spec(template, &amp;data, &amp;theme, OutputMode::Csv, Some(&amp;spec))?
<span class="boring">}</span></code></pre></pre>
<p>The <code>key</code> field uses dot notation for nested paths (<code>"meta.role"</code> extracts <code>data["meta"]["role"]</code>).</p>
<h2 id="file-output"><a class="header" href="#file-output">File Output</a></h2>
<p>The <code>--output-file-path</code> flag redirects output to a file:</p>
<pre><code class="language-bash">myapp list --output-file-path=results.txt
myapp list --output=json --output-file-path=data.json
</code></pre>
<p>Behavior:</p>
<ul>
<li>Text output: written to file, nothing printed to stdout</li>
<li>Binary output: written to file (same as without flag)</li>
<li>Silent output: no-op</li>
</ul>
<p>After writing to file, stdout output is suppressed to prevent double-printing.</p>
<h2 id="customizing-flags"><a class="header" href="#customizing-flags">Customizing Flags</a></h2>
<p>Rename or disable the flags via <code>AppBuilder</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::builder()
    .output_flag(Some("format"))       // --format instead of --output
    .output_file_flag(Some("out"))     // --out instead of --output-file-path
    .build()?
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::builder()
    .no_output_flag()                  // Disable --output entirely
    .no_output_file_flag()             // Disable file output
    .build()?
<span class="boring">}</span></code></pre></pre>
<h2 id="accessing-outputmode-in-handlers"><a class="header" href="#accessing-outputmode-in-handlers">Accessing OutputMode in Handlers</a></h2>
<p><code>CommandContext</code> carries the resolved output mode:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handler(matches: &amp;ArgMatches, ctx: &amp;CommandContext) -&gt; HandlerResult&lt;Data&gt; {
    if ctx.output_mode.is_structured() {
        // Skip interactive prompts in JSON mode
    }

    if ctx.output_mode == OutputMode::Csv {
        // Maybe adjust data structure for flat output
    }

    Ok(Output::Render(data))
}
<span class="boring">}</span></code></pre></pre>
<p>Helper methods:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ctx.output_mode.should_use_color()  // True for Term, depends on terminal for Auto
ctx.output_mode.is_structured()     // True for Json, Yaml, Xml, Csv
ctx.output_mode.is_debug()          // True for TermDebug
<span class="boring">}</span></code></pre></pre>
<h2 id="rendering-without-cli"><a class="header" href="#rendering-without-cli">Rendering Without CLI</a></h2>
<p>For standalone rendering with explicit mode:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout::{render_auto, OutputMode};

// Renders template for Term/Text, serializes for Json/Yaml
let output = render_auto(template, &amp;data, &amp;theme, OutputMode::Json)?;
<span class="boring">}</span></code></pre></pre>
<p>The "auto" in <code>render_auto</code> refers to template-vs-serialize dispatch, not color detection.</p>
<p>For full control over both output mode and color mode:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout::{render_with_mode, ColorMode};

let output = render_with_mode(
    template,
    &amp;data,
    &amp;theme,
    OutputMode::Term,
    ColorMode::Dark,
)?;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="app-configuration"><a class="header" href="#app-configuration">App Configuration</a></h1>
<p><code>AppBuilder</code> is the unified entry point for configuring your application. Instead of scattering configuration across multiple structs (<code>Standout</code>, <code>RenderSetup</code>, <code>Theme</code>), everything from command registration to theme selection happens in one fluent interface.</p>
<p>This design ensures that your application defines its entire environment—commands, styles, templates, and hooks—before the runtime starts, preventing configuration race conditions and simplifying testing.</p>
<p>This guide covers the full setup: embedding resources, registering commands, configuring themes, and customizing behavior.</p>
<p>See also:</p>
<ul>
<li><a href="topics/rendering-system.html">Rendering System</a> for details on templates and styles.</li>
<li><a href="topics/topics-system.html">Topics System</a> for help topics.</li>
</ul>
<h2 id="basic-setup"><a class="header" href="#basic-setup">Basic Setup</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout::cli::App;
use standout_macros::{embed_templates, embed_styles};

let app = App::builder()
    .templates(embed_templates!("src/templates"))
    .styles(embed_styles!("src/styles"))
    .default_theme("default")
    .command("list", list_handler, "list.j2")
    .build()?;

app.run(Cli::command(), std::env::args());
<span class="boring">}</span></code></pre></pre>
<h2 id="embedding-resources-1"><a class="header" href="#embedding-resources-1">Embedding Resources</a></h2>
<h3 id="templates-1"><a class="header" href="#templates-1">Templates</a></h3>
<p><code>embed_templates!</code> embeds template files at compile time:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.templates(embed_templates!("src/templates"))
<span class="boring">}</span></code></pre></pre>
<p>Collects files matching: <code>.jinja</code>, <code>.jinja2</code>, <code>.j2</code>, <code>.txt</code> (in priority order).</p>
<p>Directory structure:</p>
<pre><code class="language-text">src/templates/
  list.j2
  add.j2
  db/
    migrate.j2
    status.j2
</code></pre>
<p>Templates are referenced by path without extension: <code>"list"</code>, <code>"db/migrate"</code>.</p>
<h3 id="styles"><a class="header" href="#styles">Styles</a></h3>
<p><code>embed_styles!</code> embeds stylesheet files:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.styles(embed_styles!("src/styles"))
<span class="boring">}</span></code></pre></pre>
<p>Collects files matching: <code>.yaml</code>, <code>.yml</code>.</p>
<pre><code class="language-text">src/styles/
  default.yaml
  dark.yaml
  light.yaml
</code></pre>
<p>Themes are referenced by filename without extension: <code>"default"</code>, <code>"dark"</code>.</p>
<h3 id="hot-reloading"><a class="header" href="#hot-reloading">Hot Reloading</a></h3>
<p>In debug builds, embedded resources are re-read from disk on each render—edit without recompiling. In release builds, embedded content is used directly.</p>
<p>This is automatic when the source path exists on disk.</p>
<h2 id="runtime-overrides"><a class="header" href="#runtime-overrides">Runtime Overrides</a></h2>
<p>Users can override embedded resources with local files:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::builder()
    .templates(embed_templates!("src/templates"))
    .templates_dir("~/.myapp/templates")  // Overrides embedded
    .styles(embed_styles!("src/styles"))
    .styles_dir("~/.myapp/themes")        // Overrides embedded
<span class="boring">}</span></code></pre></pre>
<p>Local directories take precedence. This enables user customization without recompiling.</p>
<h2 id="theme-selection"><a class="header" href="#theme-selection">Theme Selection</a></h2>
<h3 id="from-stylesheet-registry"><a class="header" href="#from-stylesheet-registry">From Stylesheet Registry</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    .styles(embed_styles!("src/styles"))
    // Optional: set explicit default name
    // If omitted, tries "default", "theme", then "base"
    .default_theme("dark")
<span class="boring">}</span></code></pre></pre>
<p>If <code>.default_theme()</code> is not called, <code>AppBuilder</code> attempts to load a theme from the registry in this order:</p>
<ol>
<li><code>default</code></li>
<li><code>theme</code></li>
<li><code>base</code></li>
</ol>
<p>This allows you to provide a standard <code>base.yaml</code> or <code>theme.yaml</code> without requiring explicit configuration code. If the explicit theme isn't found, <code>build()</code> returns <code>SetupError::ThemeNotFound</code>.</p>
<h3 id="explicit-theme"><a class="header" href="#explicit-theme">Explicit Theme</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let theme = Theme::new()
    .add("title", Style::new().bold().cyan())
    .add("muted", Style::new().dim());

App::builder()
    .theme(theme)  // Overrides stylesheet registry
<span class="boring">}</span></code></pre></pre>
<p>Explicit <code>.theme()</code> takes precedence over <code>.default_theme()</code>.</p>
<h2 id="command-registration"><a class="header" href="#command-registration">Command Registration</a></h2>
<h3 id="simple-commands"><a class="header" href="#simple-commands">Simple Commands</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::builder()
    .command("list", list_handler, "list.j2")
    .command("add", add_handler, "add.j2")
<span class="boring">}</span></code></pre></pre>
<p>Arguments: command name, handler function, template path.</p>
<h3 id="with-configuration"><a class="header" href="#with-configuration">With Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::builder()
    .command_with("delete", delete_handler, |cfg| cfg
        .template("delete.j2")
        .pre_dispatch(require_confirmation)
        .post_dispatch(log_deletion))
<span class="boring">}</span></code></pre></pre>
<p>Inline hook attachment without separate <code>.hooks()</code> call.</p>
<h3 id="nested-groups"><a class="header" href="#nested-groups">Nested Groups</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::builder()
    .group("db", |g| g
        .command("migrate", migrate_handler, "db/migrate.j2")
        .command("status", status_handler, "db/status.j2")
        .group("backup", |b| b
            .command("create", backup_create, "db/backup/create.j2")
            .command("restore", backup_restore, "db/backup/restore.j2")))
<span class="boring">}</span></code></pre></pre>
<p>Creates command paths: <code>db.migrate</code>, <code>db.status</code>, <code>db.backup.create</code>, <code>db.backup.restore</code>.</p>
<h3 id="from-dispatch-macro"><a class="header" href="#from-dispatch-macro">From Dispatch Macro</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Dispatch)]
enum Commands {
    List,
    Add,
    #[dispatch(nested)]
    Db(DbCommands),
}

App::builder()
    .commands(Commands::dispatch_config())
<span class="boring">}</span></code></pre></pre>
<p>The macro generates registration for all variants.</p>
<h2 id="default-command"><a class="header" href="#default-command">Default Command</a></h2>
<p>When a CLI is invoked without a subcommand (a "naked" invocation like <code>myapp</code> or <code>myapp --verbose</code>), you can specify a default command to run:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::builder()
    .default_command("list")
    .command("list", list_handler, "list.j2")
    .command("add", add_handler, "add.j2")
<span class="boring">}</span></code></pre></pre>
<p>With this configuration:</p>
<ul>
<li><code>myapp</code> becomes <code>myapp list</code></li>
<li><code>myapp --output=json</code> becomes <code>myapp list --output=json</code></li>
<li><code>myapp add foo</code> stays as <code>myapp add foo</code> (explicit command takes precedence)</li>
</ul>
<h3 id="with-dispatch-macro"><a class="header" href="#with-dispatch-macro">With Dispatch Macro</a></h3>
<p>Use the <code>#[dispatch(default)]</code> attribute to mark a variant as the default:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Dispatch)]
#[dispatch(handlers = handlers)]
enum Commands {
    #[dispatch(default)]
    List,
    Add,
}

App::builder()
    .commands(Commands::dispatch_config())
<span class="boring">}</span></code></pre></pre>
<p>Only one command can be marked as default. Multiple <code>#[dispatch(default)]</code> attributes will cause a compile error.</p>
<h2 id="hooks"><a class="header" href="#hooks">Hooks</a></h2>
<p>Attach hooks to specific command paths:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::builder()
    .command("migrate", migrate_handler, "migrate.j2")
    .hooks("db.migrate", Hooks::new()
        .pre_dispatch(require_admin)
        .post_dispatch(add_timestamp)
        .post_output(log_result))
<span class="boring">}</span></code></pre></pre>
<p>The path uses dot notation matching the command hierarchy.</p>
<h2 id="context-injection"><a class="header" href="#context-injection">Context Injection</a></h2>
<p>Add values available in all templates:</p>
<h3 id="static-context"><a class="header" href="#static-context">Static Context</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::builder()
    .context("version", "1.0.0")
    .context("app_name", "MyApp")
<span class="boring">}</span></code></pre></pre>
<h3 id="dynamic-context"><a class="header" href="#dynamic-context">Dynamic Context</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::builder()
    .context_fn("terminal_width", |ctx| {
        Value::from(ctx.terminal_width.unwrap_or(80))
    })
    .context_fn("timestamp", |_ctx| {
        Value::from(chrono::Utc::now().to_rfc3339())
    })
<span class="boring">}</span></code></pre></pre>
<p>Dynamic providers receive <code>RenderContext</code> with output mode, terminal width, and handler data.</p>
<h2 id="topics"><a class="header" href="#topics">Topics</a></h2>
<p>Add help topics:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::builder()
    .topics_dir("docs/topics")
    .add_topic(Topic::new("auth", "Authentication...", TopicType::Text, None))
<span class="boring">}</span></code></pre></pre>
<p>See <a href="topics/topics-system.html">Topics System</a> for details.</p>
<h2 id="flag-customization"><a class="header" href="#flag-customization">Flag Customization</a></h2>
<h3 id="output-flag"><a class="header" href="#output-flag">Output Flag</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::builder()
    .output_flag(Some("format"))  // --format instead of --output
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::builder()
    .no_output_flag()  // Disable entirely
<span class="boring">}</span></code></pre></pre>
<h3 id="file-output-flag"><a class="header" href="#file-output-flag">File Output Flag</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::builder()
    .output_file_flag(Some("out"))  // --out instead of --output-file-path
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::builder()
    .no_output_file_flag()  // Disable entirely
<span class="boring">}</span></code></pre></pre>
<h2 id="the-app-struct"><a class="header" href="#the-app-struct">The App Struct</a></h2>
<p><code>build()</code> produces an <code>App</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct App {
    registry: TopicRegistry,
    output_flag: Option&lt;String&gt;,
    output_file_flag: Option&lt;String&gt;,
    output_mode: OutputMode,
    theme: Option&lt;Theme&gt;,
    command_hooks: HashMap&lt;String, Hooks&gt;,
    template_registry: Option&lt;TemplateRegistry&gt;,
    stylesheet_registry: Option&lt;StylesheetRegistry&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="running-the-app"><a class="header" href="#running-the-app">Running the App</a></h2>
<h3 id="standard-execution"><a class="header" href="#standard-execution">Standard Execution</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(matches) = app.run(Cli::command(), std::env::args()) {
    // Standout didn't handle this command, fall back to legacy
    legacy_dispatch(matches);
}
<span class="boring">}</span></code></pre></pre>
<p>Parses args, dispatches to handler, prints output. Returns <code>Option&lt;ArgMatches&gt;</code>—<code>None</code> if handled, <code>Some(matches)</code> for fallback.</p>
<h3 id="capture-output"><a class="header" href="#capture-output">Capture Output</a></h3>
<p>For testing, post-processing, or when you need the output string:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match app.run_to_string(cmd, args) {
    RunResult::Handled(output) =&gt; { /* use output string */ }
    RunResult::Binary(bytes, filename) =&gt; { /* handle binary */ }
    RunResult::NoMatch(matches) =&gt; { /* fallback dispatch */ }
}
<span class="boring">}</span></code></pre></pre>
<p>Returns <code>RunResult</code> instead of printing.</p>
<h3 id="parse-only"><a class="header" href="#parse-only">Parse Only</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let matches = app.parse_with(cmd);
// Use matches for manual dispatch
<span class="boring">}</span></code></pre></pre>
<p>Parses with Standout's augmented command but doesn't dispatch.</p>
<h2 id="build-validation"><a class="header" href="#build-validation">Build Validation</a></h2>
<p><code>build()</code> validates:</p>
<ul>
<li>Theme exists if <code>.default_theme()</code> was called</li>
<li>Returns <code>SetupError::ThemeNotFound</code> if not found</li>
</ul>
<p>What's NOT validated at build time:</p>
<ul>
<li>Templates (resolved lazily at render time)</li>
<li>Command handlers</li>
<li>Hook signatures (verified at registration)</li>
</ul>
<h2 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h2>
<pre><pre class="playground"><code class="language-rust">use standout::cli::{App, HandlerResult, Output};
use standout_macros::{embed_templates, embed_styles};
use clap::{Command, Arg};
use serde::Serialize;

#[derive(Serialize)]
struct ListOutput {
    items: Vec&lt;String&gt;,
}

fn list_handler(matches: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;ListOutput&gt; {
    let items = vec!["one".into(), "two".into()];
    Ok(Output::Render(ListOutput { items }))
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let cli = Command::new("myapp")
        .subcommand(Command::new("list").about("List items"));

    let app = App::builder()
        .templates(embed_templates!("src/templates"))
        .styles(embed_styles!("src/styles"))
        .default_theme("default")
        .context("version", env!("CARGO_PKG_VERSION"))
        .command("list", list_handler, "list.j2")
        .topics_dir("docs/topics")
        .build()?;

    app.run(cli, std::env::args());
    Ok(())
}</code></pre></pre>
<p>Template <code>src/templates/list.j2</code>:</p>
<pre><code class="language-jinja">[header]Items[/header] ({{ items | length }} total)
{% for item in items %}
  - {{ item }}
{% endfor %}

[muted]v{{ version }}[/muted]
</code></pre>
<p>Style <code>src/styles/default.yaml</code>:</p>
<pre><code class="language-yaml">header:
  fg: cyan
  bold: true
muted:
  dim: true
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="assets/version-banner.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
