<!DOCTYPE HTML>
<html lang="en" class="rust" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Introduction to Rendering - Standout</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="A CLI framework for Rust that enforces separation between logic and presentation">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../../favicon.svg">
        <link rel="shortcut icon" href="../../../favicon.png">
        <link rel="stylesheet" href="../../../css/variables.css">
        <link rel="stylesheet" href="../../../css/general.css">
        <link rel="stylesheet" href="../../../css/chrome.css">
        <link rel="stylesheet" href="../../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../../highlight.css">
        <link rel="stylesheet" href="../../../tomorrow-night.css">
        <link rel="stylesheet" href="../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../../assets/version-banner.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('rust')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="../../../index.html">Introduction</a></li><li class="chapter-item affix "><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">Getting Started</li><li class="chapter-item "><a href="../../../guides/tldr-intro-to-standout.html"><strong aria-hidden="true">1.</strong> Quick Start</a></li><li class="chapter-item "><a href="../../../guides/intro-to-standout.html"><strong aria-hidden="true">2.</strong> Introduction to Standout</a></li><li class="chapter-item affix "><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">Rendering (standout-render)</li><li class="chapter-item expanded "><a href="../../../crates/render/guides/intro-to-rendering.html" class="active"><strong aria-hidden="true">3.</strong> Introduction to Rendering</a></li><li class="chapter-item "><a href="../../../crates/render/guides/intro-to-tabular.html"><strong aria-hidden="true">4.</strong> Introduction to Tabular</a></li><li class="chapter-item "><a href="../../../crates/render/topics/styling-system.html"><strong aria-hidden="true">5.</strong> Styling System</a></li><li class="chapter-item "><a href="../../../crates/render/topics/templating.html"><strong aria-hidden="true">6.</strong> Templating</a></li><li class="chapter-item "><a href="../../../crates/render/topics/file-system-resources.html"><strong aria-hidden="true">7.</strong> File System Resources</a></li><li class="chapter-item affix "><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">Dispatch (standout-dispatch)</li><li class="chapter-item "><a href="../../../crates/dispatch/guides/intro-to-dispatch.html"><strong aria-hidden="true">8.</strong> Introduction to Dispatch</a></li><li class="chapter-item "><a href="../../../crates/dispatch/topics/handler-contract.html"><strong aria-hidden="true">9.</strong> Handler Contract</a></li><li class="chapter-item "><a href="../../../crates/dispatch/topics/execution-model.html"><strong aria-hidden="true">10.</strong> Execution Model</a></li><li class="chapter-item "><a href="../../../crates/dispatch/topics/partial-adoption.html"><strong aria-hidden="true">11.</strong> Partial Adoption</a></li><li class="chapter-item affix "><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">Framework Topics</li><li class="chapter-item "><a href="../../../topics/output-modes.html"><strong aria-hidden="true">12.</strong> Output Modes</a></li><li class="chapter-item "><a href="../../../topics/app-configuration.html"><strong aria-hidden="true">13.</strong> App Configuration</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Standout</h1>

                    <div class="right-buttons">
                        <a href="../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/arthur-debert/standout" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/arthur-debert/standout/edit/main/docs/docs/crates/render/guides/intro-to-rendering.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction-to-rendering"><a class="header" href="#introduction-to-rendering">Introduction to Rendering</a></h1>
<p>Terminal outputs have significant limitations: single font, single size, no graphics. But modern terminals provide many facilities like true colors, light/dark mode support, adaptive sizing, and more. Rich, helpful, and clear outputs are within reach.</p>
<p>The development reality explains why such output remains rare. From a primitive syntax born in the 1970s to the scattered ecosystem support, it's been a major effort to craft great outputs—and logically, it rarely makes sense to invest that time.</p>
<p><code>standout-render</code> is designed to make crafting polished outputs a breeze by leveraging ideas, tools, and workflows from web applications—a domain in which rich interface authoring has evolved into the best model we've got. (But none of the JavaScript ecosystem chaos, rest assured.)</p>
<p>In this guide, we'll explore what makes great outputs and how <code>standout-render</code> helps you get there.</p>
<p><strong>See Also:</strong></p>
<ul>
<li><a href="../topics/styling-system.html">Styling System</a> - themes, adaptive attributes, CSS syntax</li>
<li><a href="../topics/templating.html">Templating</a> - MiniJinja, style tags, processing modes</li>
<li><a href="intro-to-tabular.html">Introduction to Tabular</a> - column layouts and tables</li>
</ul>
<hr />
<h2 id="what-polished-output-entails"><a class="header" href="#what-polished-output-entails">What Polished Output Entails</a></h2>
<p>If you're building your CLI in Rust, chances are it's not a throwaway grep-formatting script—if that were the case, nothing beats shells. More likely, your program deals with complex data, logic, and computation, and the full power of Rust matters. In the same way, clear, well-presented, and designed outputs improve your users' experience when parsing that information.</p>
<p>Creating good results depends on discipline, consistency, and above all, experimentation—from exploring options to fine-tuning small details. Unlike code, good layout is experimental and takes many iterations: change, view result, change again, judge the new change, and so on.</p>
<p>The classical setup for shell UIs is anything but conducive to this. All presentation is mixed with code, often with complicated logic, if not coupled to it. Additionally, from escape codes to whitespace handling to spreading visual information across many lines of code, it becomes hard to visualize and change things.</p>
<p>The edit-code-compile-run cycle makes small tweaks take minutes. Sometimes a full hour for a minor change. In that scenario, it's no surprise that people don't bother.</p>
<hr />
<h2 id="our-example-a-report-generator"><a class="header" href="#our-example-a-report-generator">Our Example: A Report Generator</a></h2>
<p>We'll use a simple report generator to demonstrate the rendering layer. Here's our data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::Serialize;

#[derive(Clone, Serialize)]
#[serde(rename_all = "lowercase")]
pub enum Status { Pending, Done }

#[derive(Clone, Serialize)]
pub struct Task {
    pub title: String,
    pub status: Status,
}

#[derive(Serialize)]
pub struct Report {
    pub message: Option&lt;String&gt;,
    pub tasks: Vec&lt;Task&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>Our goal: transform this raw data into polished, readable output that adapts to the terminal, respects user preferences, and takes minutes to iterate on—not hours.</p>
<hr />
<h2 id="the-separation-principle"><a class="header" href="#the-separation-principle">The Separation Principle</a></h2>
<p><code>standout-render</code> is designed around a strict separation of data and presentation. This isn't just architectural nicety—it unlocks a fundamentally better workflow.</p>
<h3 id="without-separation"><a class="header" href="#without-separation">Without Separation</a></h3>
<p>Here's the typical approach, tangling logic and output:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_report(tasks: &amp;[Task]) {
    println!("\x1b[1;36mYour Tasks\x1b[0m");
    println!("──────────");
    for (i, task) in tasks.iter().enumerate() {
        let marker = if matches!(task.status, Status::Done) { "[x]" } else { "[ ]" };
        println!("{}. {} {}", i + 1, marker, task.title);
    }
    println!("\n{} tasks total", tasks.len());
}
<span class="boring">}</span></code></pre></pre>
<p>Problems:</p>
<ul>
<li>Escape codes are cryptic and error-prone</li>
<li>Changes require recompilation</li>
<li>Logic and presentation are intertwined</li>
<li>Testing is brittle</li>
<li>No easy way to support multiple output formats</li>
</ul>
<h3 id="with-separation"><a class="header" href="#with-separation">With Separation</a></h3>
<p>The same output, properly separated:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_render::{render, Theme};
use console::Style;

// Data preparation (your logic layer)
let report = Report {
    message: Some(format!("{} tasks total", tasks.len())),
    tasks,
};

// Theme definition (can be in a separate CSS/YAML file)
let theme = Theme::new()
    .add("title", Style::new().cyan().bold())
    .add("done", Style::new().green())
    .add("pending", Style::new().yellow())
    .add("muted", Style::new().dim());

// Template (can be in a separate .jinja file)
let template = r#"
[title]Your Tasks[/title]
──────────
{% for task in tasks %}
[{{ task.status }}]{{ task.status }}[/{{ task.status }}]  {{ task.title }}
{% endfor %}

{% if message %}[muted]{{ message }}[/muted]{% endif %}
"#;

let output = render(template, &amp;report, &amp;theme)?;
print!("{}", output);
<span class="boring">}</span></code></pre></pre>
<p>Now:</p>
<ul>
<li>Logic is testable without output concerns</li>
<li>Presentation is declarative and readable</li>
<li>Styles are centralized and named semantically</li>
<li>Changes to appearance don't require recompilation (with file-based templates)</li>
</ul>
<hr />
<h2 id="quick-iteration-and-workflow"><a class="header" href="#quick-iteration-and-workflow">Quick Iteration and Workflow</a></h2>
<p>The separation principle enables a radically better workflow. Here's what <code>standout-render</code> provides:</p>
<h3 id="1-file-based-flow"><a class="header" href="#1-file-based-flow">1. File-Based Flow</a></h3>
<p>Dedicated files for templates and styles:</p>
<ul>
<li>Lower risk of breaking code—especially relevant for non-developer types like technical designers</li>
<li>Simpler diffs and easier navigation</li>
<li>Trivial to experiment with variations (duplicate files, swap names)</li>
</ul>
<p><strong>Directory structure:</strong></p>
<pre><code class="language-text">src/
├── main.rs
└── templates/
    └── report.jinja
styles/
└── default.css
</code></pre>
<h3 id="2-hot-live-reload"><a class="header" href="#2-hot-live-reload">2. Hot Live Reload</a></h3>
<p>During development, you edit the template or styles and re-run. No compilation. No long turnaround.</p>
<p>This changes the entire experience. You can make and verify small adjustments in seconds. You can extensively fine-tune output quickly, then polish the full app in a focused session. Time efficiency aside, the quick iterative cycles encourage caring about smaller details, consistency—the things you forgo when iteration is painful.</p>
<p>(When released, files can be compiled into the binary using embedded macros, costing no performance or path-handling headaches in distribution.)</p>
<p>See <a href="../topics/file-system-resources.html">File System Resources</a> for details on how hot reload works.</p>
<hr />
<h2 id="best-of-breed-specialized-formats"><a class="header" href="#best-of-breed-specialized-formats">Best-of-Breed Specialized Formats</a></h2>
<h3 id="templates-minijinja"><a class="header" href="#templates-minijinja">Templates: MiniJinja</a></h3>
<p><code>standout-render</code> uses MiniJinja templates—a Rust implementation of Jinja2, a de facto standard for rich and powerful templating. The simple syntax and powerful features let you map template text to actual output much easier than <code>println!</code> spreads.</p>
<pre><code class="language-jinja">{% if message %}[accent]{{ message }}[/accent]{% endif %}

{% for task in tasks %}
[{{ task.status }}]{{ task.status | upper }}[/{{ task.status }}]  {{ task.title }}
{% endfor %}
</code></pre>
<p>Benefits:</p>
<ul>
<li>Simple, readable syntax</li>
<li>Powerful control flow (loops, conditionals, filters)</li>
<li><strong>Partials support</strong>: templates can include other templates, enabling reuse</li>
<li><strong>Custom filters</strong>: for complex presentation needs, write small bits of code and keep templates clean</li>
</ul>
<p>See <a href="../topics/templating.html">Templating</a> for template filters and advanced usage.</p>
<h3 id="styles-css-themes"><a class="header" href="#styles-css-themes">Styles: CSS Themes</a></h3>
<p>The styling layer uses CSS files with the familiar syntax you already know, but with simpler semantics tailored for terminals:</p>
<pre><code class="language-css">.title {
    color: cyan;
    font-weight: bold;
}

.done { color: green; }
.blocked { color: red; }
.pending { color: yellow; }

/* Adaptive for light/dark mode */
@media (prefers-color-scheme: light) {
    .panel { color: black; }
}

@media (prefers-color-scheme: dark) {
    .panel { color: white; }
}
</code></pre>
<p>Features:</p>
<ul>
<li><strong>Adaptive attributes</strong>: a style can render different values for light and dark modes</li>
<li><strong>Theming support</strong>: swap the entire visual appearance at once</li>
<li><strong>True color</strong>: RGB values for precise colors (<code>#ff6b35</code> or <code>[255, 107, 53]</code>)</li>
<li><strong>Aliases</strong>: semantic names resolve to visual styles (<code>commit-message: title</code>)</li>
</ul>
<p>YAML syntax is also supported as an alternative. See <a href="../topics/styling-system.html">Styling System</a> for complete style options.</p>
<hr />
<h2 id="template-integration-with-styling"><a class="header" href="#template-integration-with-styling">Template Integration with Styling</a></h2>
<p>Styles are applied with BBCode-like syntax: <code>[style]content[/style]</code>. A familiar, simple, and accessible form.</p>
<pre><code class="language-jinja">[title]Your Tasks[/title]
{% for task in tasks %}
[{{ task.status }}]{{ task.title }}[/{{ task.status }}]
{% endfor %}
</code></pre>
<p>Style tags:</p>
<ul>
<li>Nest properly: <code>[outer][inner]text[/inner][/outer]</code></li>
<li>Can span multiple lines</li>
<li>Can contain template logic: <code>[title]{% if x %}{{ x }}{% endif %}[/title]</code></li>
</ul>
<h3 id="output-modes-rich-plain-and-debug"><a class="header" href="#output-modes-rich-plain-and-debug">Output Modes: Rich, Plain, and Debug</a></h3>
<p><code>standout-render</code> processes style tags differently based on the output mode:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_render::{render_with_output, OutputMode};

// Rich terminal output (ANSI codes)
let rich = render_with_output(template, &amp;data, &amp;theme, OutputMode::Term)?;

// Plain text (strips style tags)
let plain = render_with_output(template, &amp;data, &amp;theme, OutputMode::Text)?;

// Debug mode (keeps tags visible)
let debug = render_with_output(template, &amp;data, &amp;theme, OutputMode::TermDebug)?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Single template for rich and plain text.</strong> The same template serves both—no duplication needed.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Auto-detect based on terminal capabilities
let output = render_with_output(template, &amp;data, &amp;theme, OutputMode::Auto)?;
<span class="boring">}</span></code></pre></pre>
<p>In auto mode:</p>
<ul>
<li>TTY with color support → rich output</li>
<li>Pipe or redirect → plain text</li>
</ul>
<blockquote>
<p><strong>For standout framework users:</strong> The framework's <code>--output</code> flag automatically sets the output mode. See the standout documentation for CLI integration.</p>
</blockquote>
<h3 id="debug-mode"><a class="header" href="#debug-mode">Debug Mode</a></h3>
<p>Use <code>OutputMode::TermDebug</code> for debugging:</p>
<pre><code class="language-text">[title]Your Tasks[/title]
[pending]pending[/pending]  Implement auth
[done]done[/done]  Fix tests
</code></pre>
<p>Style tags remain visible, making it easy to verify correct placement. Useful for testing and automation tools.</p>
<hr />
<h2 id="tabular-layout"><a class="header" href="#tabular-layout">Tabular Layout</a></h2>
<p>Many outputs are lists of things—log entries, servers, tasks. These benefit from vertically aligned layouts. Aligning fields seems simple at first, but when you factor in ANSI awareness, flexible size ranges, wrapping behavior, truncation, justification, and expanding cells, it becomes really hard.</p>
<p>Tabular gives you a declarative API, both in Rust and in templates, that handles all of this:</p>
<pre><code class="language-jinja">{% set t = tabular([
    {"name": "index", "width": 4},
    {"name": "status", "width": 10},
    {"name": "title", "width": "fill"}
], separator="  ") %}

{% for task in tasks %}
{{ t.row([loop.index, task.status | style_as(task.status), task.title]) }}
{% endfor %}
</code></pre>
<p>Output adapts to terminal width:</p>
<pre><code class="language-text">1.    pending     Implement user authentication
2.    done        Review pull request #142
3.    pending     Update dependencies
</code></pre>
<p>Features:</p>
<ul>
<li>Fixed, range, fill, and fractional widths</li>
<li>Truncation (start, middle, end) with custom ellipsis</li>
<li>Word wrapping for long content</li>
<li>Per-column styling</li>
<li>Automatic field extraction from structs</li>
</ul>
<p>See <a href="intro-to-tabular.html">Introduction to Tabular</a> for a comprehensive walkthrough.</p>
<hr />
<h2 id="structured-output"><a class="header" href="#structured-output">Structured Output</a></h2>
<p>Beyond textual output, <code>standout-render</code> supports structured formats:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout_render::{render_auto, OutputMode};

// For Term/Text: renders template
// For Json/Yaml/etc: serializes data directly
let json_output = render_auto(template, &amp;data, &amp;theme, OutputMode::Json)?;
let yaml_output = render_auto(template, &amp;data, &amp;theme, OutputMode::Yaml)?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Structured output for free.</strong> Because your data is <code>Serialize</code>-able, JSON/YAML outputs work automatically. Automation (tests, scripts, other programs) no longer needs to reverse-engineer data from formatted output.</p>
<p>Same data types—different output format. This enables API-like behavior from CLI apps without writing separate code paths.</p>
<hr />
<h2 id="putting-it-all-together"><a class="header" href="#putting-it-all-together">Putting It All Together</a></h2>
<p>Here's a complete example:</p>
<pre><pre class="playground"><code class="language-rust">use standout_render::{render, Theme};
use console::Style;
use serde::Serialize;

#[derive(Clone, Serialize)]
#[serde(rename_all = "lowercase")]
pub enum Status { Pending, Done }

#[derive(Clone, Serialize)]
pub struct Task {
    pub title: String,
    pub status: Status,
}

#[derive(Serialize)]
pub struct Report {
    pub message: Option&lt;String&gt;,
    pub tasks: Vec&lt;Task&gt;,
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let theme = Theme::from_yaml(r#"
        title: { fg: cyan, bold: true }
        done: green
        pending: yellow
        muted: { dim: true }
    "#)?;

    let tasks = vec![
        Task { title: "Implement user authentication".into(), status: Status::Pending },
        Task { title: "Review pull request #142".into(), status: Status::Done },
        Task { title: "Update dependencies".into(), status: Status::Pending },
    ];

    let pending_count = tasks.iter()
        .filter(|t| matches!(t.status, Status::Pending))
        .count();

    let report = Report {
        message: Some(format!("{} pending", pending_count)),
        tasks,
    };

    let template = r#"
[title]My Tasks[/title]

{% for task in tasks %}
{{ loop.index }}.  [{{ task.status }}]{{ task.status }}[/{{ task.status }}]  {{ task.title }}
{% endfor %}

{% if message %}[muted]{{ message }}[/muted]{% endif %}
"#;

    let output = render(template, &amp;report, &amp;theme)?;
    print!("{}", output);
    Ok(())
}</code></pre></pre>
<p><strong>Output (terminal):</strong></p>
<pre><code class="language-text">My Tasks

1.  pending  Implement user authentication
2.  done     Review pull request #142
3.  pending  Update dependencies

2 pending
</code></pre>
<p>With colors, "pending" appears yellow, "done" appears green.</p>
<hr />
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p><code>standout-render</code> transforms CLI output from a chore into a pleasure:</p>
<ol>
<li>
<p><strong>Separation of concerns</strong>: Data stays separate from templates. Templates define structure. Styles control appearance.</p>
</li>
<li>
<p><strong>Fast iteration</strong>: Hot reload means edit-and-see in seconds, not minutes. This changes what's practical.</p>
</li>
<li>
<p><strong>Familiar tools</strong>: MiniJinja for templates (Jinja2 syntax), CSS or YAML for styles. No new languages to learn.</p>
</li>
<li>
<p><strong>Graceful degradation</strong>: One template serves rich terminals, plain pipes, and everything in between.</p>
</li>
<li>
<p><strong>Structured output for free</strong>: JSON, YAML outputs work automatically from your serializable types.</p>
</li>
<li>
<p><strong>Tabular layouts</strong>: Declarative column definitions handle alignment, wrapping, truncation, and ANSI-awareness.</p>
</li>
</ol>
<p>The rendering system makes it practical to care about details. When iteration is fast and changes are safe, polish becomes achievable—not aspirational.</p>
<p>For complete API details, see the <a href="https://docs.rs/standout-render">API documentation</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../../guides/intro-to-standout.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../../crates/render/guides/intro-to-tabular.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../../guides/intro-to-standout.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../../crates/render/guides/intro-to-tabular.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../../elasticlunr.min.js"></script>
        <script src="../../../mark.min.js"></script>
        <script src="../../../searcher.js"></script>

        <script src="../../../clipboard.min.js"></script>
        <script src="../../../highlight.js"></script>
        <script src="../../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../../assets/version-banner.js"></script>


    </div>
    </body>
</html>
