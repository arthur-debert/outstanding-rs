#!/usr/bin/env python3
"""
Release script for outstanding.

Creates a new release by:
1. Validating the git repo is clean
2. Validating no existing git tag or crates.io version conflicts
3. Updating all Cargo.toml files with the new version
4. Committing the change
5. Creating and pushing a git tag

Usage:
    scripts/new-release --bump          # Bump patch version (0.3.2 -> 0.3.3)
    scripts/new-release 0.4.0           # Set explicit version
    scripts/new-release v0.4.0          # Also accepts 'v' prefix
"""

import argparse
import re
import subprocess
import sys
import tomllib
from pathlib import Path

# Workspace crate paths (order matters: outstanding must be published first)
CRATES = [
    Path("crates/outstanding/Cargo.toml"),
    Path("crates/outstanding-clap/Cargo.toml"),
]

# The primary crate determines the version
PRIMARY_CRATE = CRATES[0]


def run(cmd: list[str], capture: bool = True, check: bool = True) -> subprocess.CompletedProcess:
    """Run a command and return the result."""
    return subprocess.run(cmd, capture_output=capture, text=True, check=check)


def get_current_version(cargo_toml: Path) -> str:
    """Read the current version from Cargo.toml."""
    with open(cargo_toml, "rb") as f:
        data = tomllib.load(f)
    return data["package"]["version"]


def parse_version(version: str) -> tuple[int, int, int]:
    """Parse a semver string into (major, minor, patch)."""
    match = re.match(r"^v?(\d+)\.(\d+)\.(\d+)$", version)
    if not match:
        raise ValueError(f"Invalid version format: {version}")
    return int(match.group(1)), int(match.group(2)), int(match.group(3))


def version_tuple_to_str(v: tuple[int, int, int]) -> str:
    """Convert version tuple to string."""
    return f"{v[0]}.{v[1]}.{v[2]}"


def bump_patch(version: str) -> str:
    """Bump the patch part of a version."""
    major, minor, patch = parse_version(version)
    return version_tuple_to_str((major, minor, patch + 1))


def normalize_version(version: str) -> str:
    """Normalize version string (remove 'v' prefix if present)."""
    return version.lstrip("v")


def check_git_clean() -> None:
    """Ensure git repo is clean."""
    result = run(["git", "status", "--porcelain"])
    if result.stdout.strip():
        print("Error: Git repository is not clean.", file=sys.stderr)
        print("Please commit or stash your changes first.", file=sys.stderr)
        print("\nModified files:", file=sys.stderr)
        print(result.stdout, file=sys.stderr)
        sys.exit(1)


def ensure_latest(new_version: str, prior_versions: list[str]) -> str | None:
    """Check that new_version is greater than all prior versions.

    Args:
        new_version: The version we want to release
        prior_versions: List of version strings (with or without 'v' prefix)

    Returns:
        None if new_version is latest, otherwise the conflicting version string
    """
    new_v = parse_version(new_version)

    for ver_str in prior_versions:
        try:
            ver = parse_version(ver_str)
            if ver >= new_v:
                return version_tuple_to_str(ver)
        except ValueError:
            pass  # Skip malformed versions

    return None


def get_git_tags() -> list[str]:
    """Get all version tags from git as strings."""
    result = run(["git", "tag", "-l", "v*"])
    return [line for line in result.stdout.strip().split("\n") if line]


def check_git_tag_conflict(new_version: str) -> None:
    """Check that no git tag exists for this version or higher."""
    existing_tags = get_git_tags()
    conflict = ensure_latest(new_version, existing_tags)

    if conflict:
        print(f"Aborting: there's pre-existing git tag for v{conflict}.", file=sys.stderr)
        print("Remove or update Cargo.toml manually, then try again.", file=sys.stderr)
        sys.exit(1)


def get_crate_name(cargo_toml: Path) -> str:
    """Get the crate name from Cargo.toml."""
    with open(cargo_toml, "rb") as f:
        data = tomllib.load(f)
    return data["package"]["name"]


def get_crates_io_versions(crate_name: str) -> list[str]:
    """Get all versions of the crate from crates.io as strings."""
    # Use cargo search to check if crate exists
    result = run(["cargo", "search", crate_name, "--limit", "1"], check=False)
    if result.returncode != 0 or crate_name not in result.stdout:
        # Crate doesn't exist on crates.io yet
        return []

    # Use the crates.io API to get all versions
    result = run(
        ["curl", "-s", f"https://crates.io/api/v1/crates/{crate_name}/versions"],
        check=False
    )
    if result.returncode != 0:
        return []

    # Parse the JSON response manually
    return [match.group(1) for match in re.finditer(r'"num"\s*:\s*"([^"]+)"', result.stdout)]


def check_crates_io_conflict(crate_name: str, new_version: str) -> None:
    """Check that no crates.io version exists for this version or higher."""
    existing_versions = get_crates_io_versions(crate_name)

    if not existing_versions:
        return  # Crate not on crates.io yet, or couldn't fetch

    conflict = ensure_latest(new_version, existing_versions)

    if conflict:
        print(f"Aborting: crates.io already has version {conflict} for {crate_name}.", file=sys.stderr)
        print("Remove or update Cargo.toml manually, then try again.", file=sys.stderr)
        sys.exit(1)


def update_package_version(cargo_toml: Path, new_version: str) -> None:
    """Update the package version in Cargo.toml."""
    content = cargo_toml.read_text()

    # Match version = "X.Y.Z" in the [package] section
    pattern = r'(\[package\][^\[]*?version\s*=\s*)"[^"]+"'
    replacement = rf'\1"{new_version}"'

    new_content, count = re.subn(pattern, replacement, content, count=1, flags=re.DOTALL)

    if count == 0:
        raise RuntimeError(f"Failed to find version in {cargo_toml}")

    cargo_toml.write_text(new_content)


def update_dependency_version(cargo_toml: Path, dep_name: str, new_version: str) -> None:
    """Update a dependency version in Cargo.toml."""
    content = cargo_toml.read_text()

    # Match outstanding = { version = "X.Y.Z", ... }
    pattern = rf'({dep_name}\s*=\s*\{{\s*version\s*=\s*)"[^"]+"'
    replacement = rf'\1"{new_version}"'

    new_content, count = re.subn(pattern, replacement, content, flags=re.DOTALL)

    if count == 0:
        # Dependency might not exist in this file, that's ok
        return

    cargo_toml.write_text(new_content)


def git_commit_and_tag(new_version: str) -> None:
    """Commit all Cargo.toml changes and create a tag."""
    tag = f"v{new_version}"

    # Stage all Cargo.toml files
    for cargo_toml in CRATES:
        run(["git", "add", str(cargo_toml)])

    # Commit
    run(["git", "commit", "-m", f"Bump version to {tag}"])

    # Create tag
    run(["git", "tag", "-a", tag, "-m", f"Release {tag}"])

    # Push commit and tag
    run(["git", "push"])
    run(["git", "push", "origin", tag])


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Create a new release for outstanding.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s --bump          Bump patch version (0.3.2 -> 0.3.3)
  %(prog)s 0.4.0           Set explicit version
  %(prog)s v0.4.0          Also accepts 'v' prefix

The script will:
  1. Validate git repo is clean
  2. Check no conflicting git tags or crates.io versions exist
  3. Update all Cargo.toml files (package versions + dependency refs)
  4. Commit, tag, and push
        """,
    )

    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument(
        "--bump",
        action="store_true",
        help="Bump the patch version (e.g., 0.3.2 -> 0.3.3)",
    )
    group.add_argument(
        "version",
        nargs="?",
        help="Explicit version to set (e.g., 0.4.0 or v0.4.0)",
    )

    args = parser.parse_args()

    # Verify we're in the project root
    if not PRIMARY_CRATE.exists():
        print(f"Error: {PRIMARY_CRATE} not found. Run from project root.", file=sys.stderr)
        sys.exit(1)

    # Check git is clean first
    check_git_clean()

    # Get current version from primary crate
    current_version = get_current_version(PRIMARY_CRATE)
    print(f"Current version: {current_version}")

    # Determine new version
    if args.bump:
        new_version = bump_patch(current_version)
    else:
        new_version = normalize_version(args.version)
        try:
            parse_version(new_version)
        except ValueError as e:
            print(f"Error: {e}", file=sys.stderr)
            sys.exit(1)

    print(f"New version: {new_version}")

    # Validations
    print("\nRunning validations...")

    print("  Checking git tags...", end=" ", flush=True)
    check_git_tag_conflict(new_version)
    print("OK")

    for cargo_toml in CRATES:
        crate_name = get_crate_name(cargo_toml)
        print(f"  Checking crates.io ({crate_name})...", end=" ", flush=True)
        check_crates_io_conflict(crate_name, new_version)
        print("OK")

    # Update all Cargo.toml files
    print(f"\nUpdating Cargo.toml files to {new_version}...")
    for cargo_toml in CRATES:
        print(f"  {cargo_toml}")
        update_package_version(cargo_toml, new_version)
        # Also update dependency on 'outstanding' if present
        update_dependency_version(cargo_toml, "outstanding", new_version)

    print("\nCommitting and tagging...")
    git_commit_and_tag(new_version)

    print(f"\nâœ… Released v{new_version}")
    print(f"   Tag: v{new_version}")
    print("   CI will publish to crates.io")


if __name__ == "__main__":
    main()
