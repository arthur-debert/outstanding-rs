<!DOCTYPE HTML>
<html lang="en" class="rust" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Standout</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="A CLI framework for Rust that enforces separation between logic and presentation">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="assets/version-banner.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('rust')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index.html">Introduction</a></li><li class="chapter-item affix "><li class="spacer"></li><li class="chapter-item "><a href="guides/index.html"><strong aria-hidden="true">1.</strong> Guides</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="guides/intro-to-standout.html"><strong aria-hidden="true">1.1.</strong> Introduction to Standout</a></li><li class="chapter-item "><a href="guides/intro-to-rendering.html"><strong aria-hidden="true">1.2.</strong> Introduction to Rendering</a></li><li class="chapter-item "><a href="guides/intro-to-tabular.html"><strong aria-hidden="true">1.3.</strong> Introduction to Tabular</a></li><li class="chapter-item "><a href="guides/tldr-intro-to-standout.html"><strong aria-hidden="true">1.4.</strong> TLDR Quick Start</a></li></ol></li><li class="chapter-item "><a href="topics/index.html"><strong aria-hidden="true">2.</strong> Topics</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="topics/handler-contract.html"><strong aria-hidden="true">2.1.</strong> Handler Contract</a></li><li class="chapter-item "><a href="topics/rendering-system.html"><strong aria-hidden="true">2.2.</strong> Rendering System</a></li><li class="chapter-item "><a href="topics/output-modes.html"><strong aria-hidden="true">2.3.</strong> Output Modes</a></li><li class="chapter-item "><a href="topics/tabular.html"><strong aria-hidden="true">2.4.</strong> Tabular Layout</a></li><li class="chapter-item "><a href="topics/app-configuration.html"><strong aria-hidden="true">2.5.</strong> App Configuration</a></li><li class="chapter-item "><a href="topics/execution-model.html"><strong aria-hidden="true">2.6.</strong> Execution Model</a></li><li class="chapter-item "><a href="topics/partial-adoption.html"><strong aria-hidden="true">2.7.</strong> Partial Adoption</a></li><li class="chapter-item "><a href="topics/render-only.html"><strong aria-hidden="true">2.8.</strong> Render Only</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Standout</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/arthur-debert/standout" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="standout"><a class="header" href="#standout">Standout</a></h1>
<p><strong>Test your data. Render your view.</strong></p>
<p>Standout is a CLI framework for Rust that enforces separation between logic and presentation. Your handlers return structs, not strings—making CLI logic as testable as any other code.</p>
<h2 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h2>
<p>CLI code that mixes logic with <code>println!</code> statements is impossible to unit test:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// You can't unit test this—it writes directly to stdout
fn list_command(show_all: bool) {
    let todos = storage::list().unwrap();
    println!("Your Todos:");
    for todo in todos.iter() {
        if show_all || todo.status == Status::Pending {
            println!("  {} {}", if todo.done { "[x]" } else { "[ ]" }, todo.title);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The only way to test this is regex on captured stdout. That's fragile, verbose, and couples your tests to presentation details.</p>
<h2 id="the-solution"><a class="header" href="#the-solution">The Solution</a></h2>
<p>With Standout, handlers return data. The framework handles rendering:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This is unit-testable—it's a pure function that returns data
fn list_handler(matches: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;TodoResult&gt; {
    let show_all = matches.get_flag("all");
    let todos = storage::list()?
        .into_iter()
        .filter(|t| show_all || t.status == Status::Pending)
        .collect();
    Ok(Output::Render(TodoResult { todos }))
}

#[test]
fn test_list_filters_completed() {
    let matches = /* mock ArgMatches with all=false */;
    let result = list_handler(&amp;matches, &amp;ctx).unwrap();
    assert!(result.todos.iter().all(|t| t.status == Status::Pending));
}
<span class="boring">}</span></code></pre></pre>
<p>Because your logic returns a struct, you test the struct. No stdout capture, no regex, no brittleness.</p>
<h2 id="standing-out"><a class="header" href="#standing-out">Standing Out</a></h2>
<p>What Standout provides:</p>
<ul>
<li>Enforced architecture splitting data and presentation</li>
<li>Logic is testable as any Rust code</li>
<li>Boilerplateless: declaratively link your handlers to command names and templates, Standout handles the rest</li>
<li>Autodispatch: save keystrokes with auto dispatch from the known command tree</li>
<li>Free <a href="topics/output-modes.html">output handling</a>: rich terminal with graceful degradation, plus structured data (JSON, YAML, CSV)</li>
<li>Finely crafted output:
<ul>
<li>File-based <a href="topics/rendering-system.html">templates</a> for content and CSS for styling</li>
<li>Rich styling with <a href="topics/rendering-system.html#adaptive-styles">adaptive properties</a> (light/dark modes), inheritance, and full theming</li>
<li>Powerful templating through <a href="https://github.com/mitsuhiko/minijinja">MiniJinja</a>, including partials (reusable, smaller templates for models displayed in multiple places)</li>
<li><a href="topics/rendering-system.html#hot-reloading">Hot reload</a>: changes to templates and styles don't require compiling</li>
<li>Declarative layout support for <a href="topics/tabular.html">tabular data</a></li>
</ul>
</li>
</ul>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<h3 id="1-define-your-commands-and-handlers"><a class="header" href="#1-define-your-commands-and-handlers">1. Define Your Commands and Handlers</a></h3>
<p>Use the <code>Dispatch</code> derive macro to connect commands to handlers. Handlers receive parsed arguments and return serializable data.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout::cli::{Dispatch, CommandContext, HandlerResult, Output};
use clap::{ArgMatches, Subcommand};
use serde::Serialize;

#[derive(Subcommand, Dispatch)]
#[dispatch(handlers = handlers)]  // handlers are in the `handlers` module
pub enum Commands {
    List,
    Add { title: String },
}

#[derive(Serialize)]
struct TodoResult {
    todos: Vec&lt;Todo&gt;,
}

mod handlers {
    use super::*;

    // HandlerResult&lt;T&gt; wraps your data; Output::Render tells Standout to render it
    pub fn list(_m: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;TodoResult&gt; {
        let todos = storage::list()?;
        Ok(Output::Render(TodoResult { todos }))
    }

    pub fn add(m: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;TodoResult&gt; {
        let title: &amp;String = m.get_one("title").unwrap();
        let todo = storage::add(title)?;
        Ok(Output::Render(TodoResult { todos: vec![todo] }))
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-define-your-presentation"><a class="header" href="#2-define-your-presentation">2. Define Your Presentation</a></h3>
<p>Templates use MiniJinja with semantic style tags. Styles are defined separately in CSS or YAML.</p>
<pre><code class="language-jinja">{# list.jinja #}
[title]My Todos[/title]
{% for todo in todos %}
  - {{ todo.title }} ([status]{{ todo.status }}[/status])
{% endfor %}
</code></pre>
<pre><code class="language-css">/* styles/default.css */
.title { color: cyan; font-weight: bold; }
.status { color: yellow; }
</code></pre>
<h3 id="3-wire-it-up"><a class="header" href="#3-wire-it-up">3. Wire It Up</a></h3>
<pre><pre class="playground"><code class="language-rust">use standout::cli::App;
use standout::{embed_templates, embed_styles};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = App::builder()
        .commands(Commands::dispatch_config())  // Register handlers from derive macro
        .templates(embed_templates!("src/templates"))
        .styles(embed_styles!("src/styles"))
        .build()?;

    app.run(Cli::command(), std::env::args());
    Ok(())
}</code></pre></pre>
<p>Run it:</p>
<pre><code class="language-bash">myapp list              # Rich terminal output with colors
myapp list --output json    # JSON for scripting
myapp list --output yaml    # YAML for config files
myapp list --output text    # Plain text, no ANSI codes
</code></pre>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<h3 id="architecture"><a class="header" href="#architecture">Architecture</a></h3>
<ul>
<li>Logic/presentation separation enforced by design</li>
<li>Handlers return data; framework handles rendering</li>
<li>Unit-testable CLI logic without stdout capture</li>
</ul>
<h3 id="output-modes"><a class="header" href="#output-modes">Output Modes</a></h3>
<ul>
<li>Rich terminal output with colors and styles</li>
<li>Automatic JSON, YAML, CSV serialization from the same handler</li>
<li>Graceful degradation when terminal lacks capabilities</li>
</ul>
<h3 id="rendering"><a class="header" href="#rendering">Rendering</a></h3>
<ul>
<li><a href="https://github.com/mitsuhiko/minijinja">MiniJinja</a> templates with semantic style tags</li>
<li>CSS or YAML stylesheets with light/dark mode support</li>
<li>Hot reload during development—edit templates without recompiling</li>
<li>Tabular layouts with alignment, truncation, and Unicode support</li>
</ul>
<h3 id="integration"><a class="header" href="#integration">Integration</a></h3>
<ul>
<li>Clap integration with automatic dispatch</li>
<li>Declarative command registration via derive macros</li>
</ul>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<pre><code class="language-bash">cargo add standout
</code></pre>
<h2 id="migrating-an-existing-cli"><a class="header" href="#migrating-an-existing-cli">Migrating an Existing CLI</a></h2>
<p>Already have a CLI? Standout supports incremental adoption. Standout handles matched commands automatically; unmatched commands return <code>ArgMatches</code> for your existing dispatch:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(matches) = app.run(Cli::command(), std::env::args()) {
    // Standout didn't handle this command, fall back to legacy
    your_existing_dispatch(matches);
}
<span class="boring">}</span></code></pre></pre>
<p>See the <a href="topics/partial-adoption.html">Partial Adoption Guide</a> for the full migration path.</p>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ul>
<li><strong><a href="guides/intro-to-standout.html">Introduction to Standout</a></strong> — Adopting Standout in a working CLI. Start here.</li>
<li><a href="guides/intro-to-rendering.html">Introduction to Rendering</a> — Creating polished terminal output</li>
<li><a href="guides/intro-to-tabular.html">Introduction to Tabular</a> — Building aligned, readable tabular layouts</li>
<li><a href="topics/index.html">All Topics</a> — In-depth documentation for specific systems</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guides"><a class="header" href="#guides">Guides</a></h1>
<p>Step-by-step walkthroughs covering principles, rationale, and features.</p>
<h2 id="available-guides"><a class="header" href="#available-guides">Available Guides</a></h2>
<ul>
<li><strong><a href="guides/./intro-to-standout.html">Introduction to Standout</a></strong> — Adopting Standout in a working CLI. Start here.</li>
<li><strong><a href="guides/./intro-to-rendering.html">Introduction to Rendering</a></strong> — Creating polished terminal output with templates and styles.</li>
<li><strong><a href="guides/./intro-to-tabular.html">Introduction to Tabular</a></strong> — Building aligned, readable tabular layouts.</li>
<li><strong><a href="guides/./tldr-intro-to-standout.html">TLDR Quick Start</a></strong> — Fast-paced intro for experienced developers.</li>
</ul>
<h2 id="where-to-start"><a class="header" href="#where-to-start">Where to Start</a></h2>
<p>If you're new to Standout, begin with <a href="guides/./intro-to-standout.html">Introduction to Standout</a>. It walks through adopting Standout in an existing CLI, step by step.</p>
<p>For a quick overview without the explanations, see the <a href="guides/./tldr-intro-to-standout.html">TLDR Quick Start</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standout-how-to"><a class="header" href="#standout-how-to">Standout How To</a></h1>
<p>This is a small, focused guide for adopting Standout in a working shell application. Each step is self-sufficient, takes a positive step towards a sane CLI design, and can be incrementally merged. This can be done for one command (probably a good idea), then replicated to as many as you'd like.</p>
<p>Note that only 2 out of 8 steps are Standout related. The others are generally good practices and clear designs for maintainable shell programs. This is not an accident, as Standout's goal is to allow your app to keep a great structure effortlessly, while providing testability, rich and fast output design, and more.</p>
<p>For explanation's sake, we will show a hypothetical list command for tdoo, a todo list manager.</p>
<p><strong>See Also:</strong></p>
<ul>
<li><a href="guides/../topics/handler-contract.html">Handler Contract</a> - detailed handler API</li>
<li><a href="guides/../topics/rendering-system.html">Rendering System</a> - templates and styles in depth</li>
<li><a href="guides/../topics/output-modes.html">Output Modes</a> - all output format options</li>
<li><a href="guides/../topics/partial-adoption.html">Partial Adoption</a> - migrating incrementally</li>
</ul>
<h2 id="1-start-the-argument-parsing"><a class="header" href="#1-start-the-argument-parsing">1. Start: The Argument Parsing</a></h2>
<p>Arg parsing is insanely intricate and deceptively simple. In case you are not already: define your application's interface with clap. Nothing else is worth doing until you have a sane starting point.</p>
<p>If you don't have clap set up yet, here's a minimal starting point:</p>
<pre><pre class="playground"><code class="language-rust">use clap::{Parser, Subcommand};

#[derive(Parser)]
#[command(name = "tdoo")]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// List all todos
    List {
        #[arg(short, long)]
        all: bool,
    },
    /// Add a new todo
    Add {
        title: String,
    },
}

fn main() {
    let cli = Cli::parse();
    match cli.command {
        Commands::List { all } =&gt; list_command(all),
        Commands::Add { title } =&gt; add_command(&amp;title),
    }
}</code></pre></pre>
<p>(If you are using a non-clap-compatible crate, for now, you'd have to write an adapter for clap.)</p>
<blockquote>
<p><strong>Verify:</strong> Run <code>cargo build</code> - it should compile without errors.</p>
</blockquote>
<h2 id="2-hard-split-logic-and-formatting"><a class="header" href="#2-hard-split-logic-and-formatting">2. Hard Split Logic and Formatting</a></h2>
<p>Now, your command should be split into two functions: the logic handler and its rendering. Don't worry about the specifics, do the straightest path from your current code.</p>
<p>This is the one key step, the key design rule. And that's not because Standout requires it, rather the other way around: Standout is designed on top of it, and keeping it separate and easy to iterate on both logic and presentation under this design is Standout's key value.</p>
<p>If your CLI is in good shape this will be a small task, otherwise you may find yourself patching together print statements everywhere, tidying up the data model and centralizing the processing. The silver lining here being: if it takes considerable work, there will be considerable gain in doing so.</p>
<p><strong>Before</strong> (tangled logic and output):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn list_command(show_all: bool) {
    let todos = storage::list().unwrap();
    println!("Your Todos:");
    println!("-----------");
    for (i, todo) in todos.iter().enumerate() {
        if show_all || todo.status == Status::Pending {
            let marker = if todo.status == Status::Done { "[x]" } else { "[ ]" };
            println!("{}. {} {}", i + 1, marker, todo.title);
        }
    }
    if todos.is_empty() {
        println!("No todos yet!");
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>After</strong> (clean separation):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use clap::ArgMatches;

// Data types for your domain
#[derive(Clone)]
pub enum Status { Pending, Done }

#[derive(Clone)]
pub struct Todo {
    pub title: String,
    pub status: Status,
}

pub struct TodoResult {
    pub message: Option&lt;String&gt;,
    pub todos: Vec&lt;Todo&gt;,
}

// This is your core logic handler, receiving parsed clap args
// and returning a pure Rust data type.
//
// Note: This example uses immutable references. If your handler needs
// mutable state (&amp;mut self), see the "Mutable Handlers" section below.
pub fn list(matches: &amp;ArgMatches) -&gt; TodoResult {
    let show_done = matches.get_flag("all");
    let todos = storage::list().unwrap();

    let filtered: Vec&lt;Todo&gt; = if show_done {
        todos
    } else {
        todos.into_iter()
            .filter(|t| matches!(t.status, Status::Pending))
            .collect()
    };

    TodoResult {
        message: None,
        todos: filtered,
    }
}

// This will take the Rust data type and print the result to stdout
pub fn render_list(result: TodoResult) {
    if let Some(msg) = result.message {
        println!("{}", msg);
    }
    for (i, todo) in result.todos.iter().enumerate() {
        let status = match todo.status {
            Status::Done =&gt; "[x]",
            Status::Pending =&gt; "[ ]",
        };
        println!("{}. {} {}", i + 1, status, todo.title);
    }
}

// And the orchestrator:
pub fn list_command(matches: &amp;ArgMatches) {
    render_list(list(matches))
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Verify:</strong> Run <code>cargo build</code> and then <code>tdoo list</code> - output should look identical to before.</p>
</blockquote>
<h3 id="intermezzo-a-milestone---logic-and-presentation-split"><a class="header" href="#intermezzo-a-milestone---logic-and-presentation-split">Intermezzo A: Milestone - Logic and Presentation Split</a></h3>
<p><strong>What you achieved:</strong> Your command logic is now a pure function that returns data.
<strong>What's now possible:</strong></p>
<ul>
<li>All of your app's logic can be unit tested as any code, from the logic inwards.</li>
<li>You can test by feeding input strings and verifying your logic handler gets called with the right parameters.</li>
<li>The rendering can also be tested by feeding data inputs and matching outputs (though this is brittle).</li>
</ul>
<p><strong>What's next:</strong> Making the return type serializable for automatic JSON/YAML output.
<strong>Your files now:</strong></p>
<pre><code class="language-text">src/
├── main.rs          # clap setup + orchestrators
├── handlers.rs      # list(), add() - pure logic
└── render.rs        # render_list(), render_add() - output formatting
</code></pre>
<h2 id="3-fine-tune-the-logic-handlers-return-type"><a class="header" href="#3-fine-tune-the-logic-handlers-return-type">3. Fine Tune the Logic Handler's Return Type</a></h2>
<p>While any data type works, Standout's renderer takes a generic type that must implement <code>Serialize</code>. This enables automatic JSON/YAML output modes and template rendering through MiniJinja's context system. This is likely a small change, and beneficial as a baseline for logic results that will simplify writing renderers later.</p>
<p>Add serde to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
serde = { version = "1", features = ["derive"] }
</code></pre>
<p>Update your types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::Serialize;

#[derive(Clone, Serialize)]
#[serde(rename_all = "lowercase")]
pub enum Status { Pending, Done }

#[derive(Clone, Serialize)]
pub struct Todo {
    pub title: String,
    pub status: Status,
}

#[derive(Serialize)]
pub struct TodoResult {
    pub message: Option&lt;String&gt;,
    pub todos: Vec&lt;Todo&gt;,
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Verify:</strong> Run <code>cargo build</code> - it should compile without errors.</p>
</blockquote>
<h2 id="4-replace-imperative-print-statements-with-a-template"><a class="header" href="#4-replace-imperative-print-statements-with-a-template">4. Replace Imperative Print Statements With a Template</a></h2>
<p>Reading a template of an output next to the substituting variables is much easier to reason about than scattered prints, string concats and the like.</p>
<p>This step is optional - if your current output is simple, you can skip to step 5. If you want an intermediate checkpoint, use Rust's format strings:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn render_list(result: TodoResult) {
    let output = format!(
        "{header}\n{todos}",
        header = result.message.unwrap_or_default(),
        todos = result.todos.iter().enumerate()
            .map(|(i, t)| format!("{}. [{}] {}", i + 1, t.status, t.title))
            .collect::&lt;Vec&lt;_&gt;&gt;()
            .join("\n")
    );
    println!("{}", output);
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Verify:</strong> Run <code>tdoo list</code> - output should still work.</p>
</blockquote>
<h2 id="5-use-a-minijinja-template-string"><a class="header" href="#5-use-a-minijinja-template-string">5. Use a MiniJinja Template String</a></h2>
<p>Rewrite your <code>std::fmt</code> or imperative prints into a MiniJinja template string, and add minijinja to your crate. If you're not familiar with it, it's a Rust implementation of Jinja, pretty much a de-facto standard for more complex templates.</p>
<p><strong>Resources:</strong></p>
<ul>
<li><a href="https://docs.rs/minijinja">MiniJinja docs</a></li>
<li><a href="https://jinja.palletsprojects.com/en/3.1.x/templates/">Jinja syntax reference</a></li>
</ul>
<p>Add minijinja to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
minijinja = "2"
</code></pre>
<p>And then you call render in MiniJinja, passing the template string and the data to use. So now your rendering function looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn render_list(result: TodoResult) {
    let output_tmpl = r#"
{% if message %}
    {{ message }}
{% endif %}
{% for todo in todos %}
    {{ loop.index }}. [{{ todo.status }}] {{ todo.title }}
{% endfor %}
"#;

    let env = minijinja::Environment::new();
    let tmpl = env.template_from_str(output_tmpl).unwrap();
    let output = tmpl.render(&amp;result).unwrap();
    println!("{}", output);
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Verify:</strong> Run <code>tdoo list</code> - output should match (formatting may differ slightly).</p>
</blockquote>
<h2 id="6-use-a-dedicated-template-file"><a class="header" href="#6-use-a-dedicated-template-file">6. Use a Dedicated Template File</a></h2>
<p>Now, move the template content into a file (say <code>src/templates/list.jinja</code>), and load it in the rendering module. Dedicated files have several advantages: triggering editor/IDE support for the file type, more descriptive diffs, less risk of breaking the code/build and, in the event that you have less technical people helping out with the UI, a much cleaner and simpler way for them to contribute.</p>
<p>Create <code>src/templates/list.jinja</code>:</p>
<pre><code class="language-jinja">{% if message %}{{ message }} {% endif %}
{% for todo in todos %}
    {{ loop.index }}. [{{ todo.status }}] {{ todo.title }}
{% endfor %}
</code></pre>
<p>Update your render function to load from file:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn render_list(result: TodoResult) {
    let template_content = include_str!("templates/list.jinja");
    let env = minijinja::Environment::new();
    let tmpl = env.template_from_str(template_content).unwrap();
    let output = tmpl.render(&amp;result).unwrap();
    println!("{}", output);
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Verify:</strong> Run <code>tdoo list</code> - output should be identical.</p>
</blockquote>
<h3 id="intermezzo-b-declarative-output-definition"><a class="header" href="#intermezzo-b-declarative-output-definition">Intermezzo B: Declarative Output Definition</a></h3>
<p><strong>What you achieved:</strong> Output is now defined declaratively in a template file, separate from Rust code.
<strong>What's now possible:</strong></p>
<ul>
<li>Edit templates without recompiling (with minor changes to loading)</li>
<li>Non-Rust developers can contribute to UI</li>
<li>Clear separation in code reviews: "is this a logic change or display change?"</li>
<li>Use partials, filters, and macros for complex outputs (see <a href="guides/../topics/rendering-system.html">Rendering System</a>)</li>
</ul>
<p><strong>What's next:</strong> Hooking up Standout for automatic dispatch and rich output.
Also, notice we've yet to do anything Standout-specific. This is not a coincidence—the framework is designed around this pattern, making testability, fast iteration, and rich features natural outcomes of the architecture.
<strong>Your files now:</strong></p>
<pre><code class="language-text">src/
├── main.rs
├── handlers.rs
├── render.rs
└── templates/
    └── list.jinja
</code></pre>
<h2 id="7-standout-offload-the-handler-orchestration"><a class="header" href="#7-standout-offload-the-handler-orchestration">7. Standout: Offload the Handler Orchestration</a></h2>
<p>And now the Standout-specific bits finally show up.</p>
<h3 id="71-add-standout-to-your-cargotoml"><a class="header" href="#71-add-standout-to-your-cargotoml">7.1 Add Standout to your Cargo.toml</a></h3>
<pre><code class="language-toml">[dependencies]
standout = { version = "2", features = ["clap", "macros"] }
</code></pre>
<blockquote>
<p><strong>Verify:</strong> Run <code>cargo build</code> - dependencies should download and compile.</p>
</blockquote>
<h3 id="72-create-the-commands-enum-with-dispatch"><a class="header" href="#72-create-the-commands-enum-with-dispatch">7.2 Create the Commands enum with Dispatch</a></h3>
<p>Annotate your commands enum with the Dispatch derive macro. This tells Standout that the "list" command should be dispatched to the <code>list</code> handler. That's all Standout needs to know, and now it can manage the execution.</p>
<p>See <a href="guides/../topics/handler-contract.html">Handler Contract</a> for full handler API details.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout::cli::{Dispatch, CommandContext, HandlerResult, Output};
use clap::{ArgMatches, Subcommand};

// Define your commands enum with the Dispatch derive
#[derive(Subcommand, Dispatch)]
#[dispatch(handlers = handlers)]
pub enum Commands {
    List,
    Add,
}

// Your handlers module
mod handlers {
    use super::*;

    pub fn list(_matches: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;TodoResult&gt; {
        let todos = storage::list()?;
        Ok(Output::Render(TodoResult {
            message: None,
            todos,
        }))
    }

    pub fn add(matches: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;TodoResult&gt; {
        let title: &amp;String = matches.get_one("title").unwrap();
        let todo = storage::add(title)?;
        Ok(Output::Render(TodoResult {
            message: Some(format!("Added: {}", title)),
            todos: vec![todo],
        }))
    }
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Verify:</strong> Run <code>cargo build</code> - it should compile without errors.</p>
</blockquote>
<h3 id="73-configure-appbuilder"><a class="header" href="#73-configure-appbuilder">7.3 Configure AppBuilder</a></h3>
<p>Use AppBuilder to configure your app. Instantiate the builder, add the path for your templates. See <a href="guides/../topics/app-configuration.html">App Configuration</a> for all configuration options.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout::cli::App;
use standout::{embed_templates, embed_styles};

let app = App::builder()
    .templates(embed_templates!("src/templates"))   // Embeds all .jinja/.j2 files
    .commands(Commands::dispatch_config())          // Register handlers from derive macro
    .build()?;
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Verify:</strong> Run <code>cargo build</code> - it should compile without errors.</p>
</blockquote>
<h3 id="74-wire-up-main"><a class="header" href="#74-wire-up-main">7.4 Wire up main()</a></h3>
<p>The final bit: handling the dispatching off to Standout:</p>
<pre><pre class="playground"><code class="language-rust">use standout::cli::App;
use standout::embed_templates;

fn main() -&gt; anyhow::Result&lt;()&gt; {
    let app = App::builder()
        .templates(embed_templates!("src/templates"))
        .commands(Commands::dispatch_config())
        .build()?;

    // Run with auto dispatch - handles parsing and execution
    app.run(Cli::command(), std::env::args());
    Ok(())
}</code></pre></pre>
<p>If your app has other clap commands that are not managed by Standout, check for unhandled commands. See <a href="guides/../topics/partial-adoption.html">Partial Adoption</a> for details on incremental migration.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(matches) = app.run(Cli::command(), std::env::args()) {
    // Standout didn't handle this command, fall back to legacy
    legacy_dispatch(matches);
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Verify:</strong> Run <code>tdoo list</code> - it should work as before.
<strong>Verify:</strong> Run <code>tdoo list --output json</code> - you should get JSON output for free!</p>
</blockquote>
<p>And now you can remove the boilerplate: the orchestrator (<code>list_command</code>) and the rendering (<code>render_list</code>). You're pretty much at global optima: a single line of derive macro links your app logic to a command name, a few lines configure Standout, and auto dispatch handles all the boilerplate.</p>
<p>For the next commands you'd wish to migrate, this is even simpler. Say you have a "create" logic handler: add a "create.jinja" to that template dir, add the derive macro for the create function and that is it. By default the macro will match the command's name to the handlers and to the template files, but you can change these and map explicitly to your heart's content.</p>
<h3 id="intermezzo-c-welcome-to-standout"><a class="header" href="#intermezzo-c-welcome-to-standout">Intermezzo C: Welcome to Standout</a></h3>
<p><strong>What you achieved:</strong> Full dispatch pipeline with zero boilerplate.</p>
<p><strong>What's now possible:</strong></p>
<ul>
<li>Alter the template and re-run your CLI, without compilation, and the new template will be used</li>
<li>Your CLI just got multiple output modes via <code>--output</code> (see <a href="guides/../topics/output-modes.html">Output Modes</a>):
<ul>
<li><strong>term</strong>: rich shell formatting (more about this on the next step)</li>
<li><strong>term-debug</strong>: print formatting info for testing/debugging</li>
<li><strong>text</strong>: plain text, no styling</li>
<li><strong>auto</strong>: the default, rich term that degrades gracefully</li>
<li><strong>json, csv, yaml</strong>: automatic serialization of your data</li>
</ul>
</li>
</ul>
<p><strong>What's next:</strong> Adding rich styling to make the output beautiful.</p>
<p><strong>Your files now:</strong></p>
<pre><code class="language-text">src/
├── main.rs              # App::builder() setup
├── commands.rs          # Commands enum with #[derive(Dispatch)]
├── handlers.rs          # list(), add() returning HandlerResult
└── templates/
    ├── list.jinja
    └── add.jinja
</code></pre>
<h2 id="8-make-the-output-awesome"><a class="header" href="#8-make-the-output-awesome">8. Make the Output Awesome</a></h2>
<p>Let's transform that mono-typed, monochrome string into a richer and more useful UI. Borrowing from web apps setup, we keep the content in a template file, and we define styles in a stylesheet file.</p>
<p>See <a href="guides/../topics/rendering-system.html">Rendering System</a> for full styling documentation.</p>
<h3 id="81-create-the-stylesheet"><a class="header" href="#81-create-the-stylesheet">8.1 Create the stylesheet</a></h3>
<p>Create <code>src/styles/default.css</code>:</p>
<pre><code class="language-css">/* Styles for completed todos */
.done {
    text-decoration: line-through;
    color: gray;
}

/* Style for todo index numbers */
.index {
    color: yellow;
}

/* Style for pending todos */
.pending {
    font-weight: bold;
    color: white;
}

/* Adaptive style for messages */
.message {
    color: cyan;
}

@media (prefers-color-scheme: light) {
    .pending { color: black; }
}

@media (prefers-color-scheme: dark) {
    .pending { color: white; }
}
</code></pre>
<p>Or if you prefer YAML (<code>src/styles/default.yaml</code>):</p>
<pre><code class="language-yaml">done: strikethrough, gray
index: yellow
pending:
  bold: true
  fg: white
  light:
    fg: black
  dark:
    fg: white
message: cyan
</code></pre>
<blockquote>
<p><strong>Verify:</strong> The file exists at <code>src/styles/default.css</code> or <code>src/styles/default.yaml</code>.</p>
</blockquote>
<h3 id="82-add-style-tags-to-your-template"><a class="header" href="#82-add-style-tags-to-your-template">8.2 Add style tags to your template</a></h3>
<p>Update <code>src/templates/list.jinja</code> with style tags:</p>
<pre><code class="language-jinja">{% if message %}[message]{{ message }}[/message]
{% endif %}
{% for todo in todos %}
[index]{{ loop.index }}.[/index] [{{ todo.status }}]{{ todo.title }}[/{{ todo.status }}]
{% endfor %}
</code></pre>
<p>The style tags use BBCode-like syntax: <code>[style-name]content[/style-name]</code></p>
<p>Notice how we use <code>[{{ todo.status }}]</code> dynamically - if <code>todo.status</code> is "done", it applies the <code>.done</code> style; if it's "pending", it applies the <code>.pending</code> style.</p>
<blockquote>
<p><strong>Verify:</strong> The template file is updated.</p>
</blockquote>
<h3 id="83-wire-up-styles-in-appbuilder"><a class="header" href="#83-wire-up-styles-in-appbuilder">8.3 Wire up styles in AppBuilder</a></h3>
<p>Add the styles to your app builder:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let app = App::builder()
    .templates(embed_templates!("src/templates"))
    .styles(embed_styles!("src/styles"))       // Load stylesheets
    .default_theme("default")                  // Use styles/default.css or default.yaml
    .commands(Commands::dispatch_config())
    .build()?;
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Verify:</strong> Run <code>cargo build</code> - it should compile without errors.
<strong>Verify:</strong> Run <code>tdoo list</code> - you should see colored, styled output!
<strong>Verify:</strong> Run <code>tdoo list --output text</code> - plain text, no colors.</p>
</blockquote>
<p>Now you're leveraging the core rendering design of Standout:</p>
<ul>
<li>File-based templates for content, and stylesheets for styles</li>
<li>Custom template syntax with BBCode for markup styles <code>[style][/style]</code></li>
<li>Live reload: iterate through content and styling without recompiling</li>
</ul>
<h3 id="intermezzo-d-the-full-setup-is-done"><a class="header" href="#intermezzo-d-the-full-setup-is-done">Intermezzo D: The Full Setup Is Done</a></h3>
<p><strong>What you achieved:</strong> A fully styled, testable, multi-format CLI.</p>
<p><strong>What's now possible:</strong></p>
<ul>
<li>Rich terminal output with colors, bold, strikethrough</li>
<li>Automatic light/dark mode adaptation</li>
<li>JSON/YAML/CSV output for scripting and testing</li>
<li>Hot reload of templates and styles during development</li>
<li>Unit testable logic handlers</li>
</ul>
<p><strong>Your final files:</strong></p>
<pre><code class="language-text">src/
├── main.rs              # App::builder() setup
├── commands.rs          # Commands enum with #[derive(Dispatch)]
├── handlers.rs          # list(), add() returning HandlerResult
├── templates/
│   ├── list.jinja       # with [style] tags
│   └── add.jinja
└── styles/
    └── default.css      # or default.yaml
</code></pre>
<p>For brevity's sake, we've ignored a bunch of finer and relevant points:</p>
<ul>
<li>The derive macros can set name mapping explicitly: <code>#[dispatch(handler = custom_fn, template = "custom.jinja")]</code></li>
<li>There are pre-dispatch, post-dispatch and post-render hooks (see <a href="guides/../topics/execution-model.html">Execution Model</a>)</li>
<li>Standout exposes its primitives as libraries for custom usage (see <a href="guides/../topics/render-only.html">Render Only</a>)</li>
<li>Powerful tabular layouts via the <code>col</code> filter (see <a href="guides/../topics/tabular.html">Tabular Layout</a>)</li>
<li>A help topics system for rich documentation (see <a href="guides/../topics/topics-system.html">Topics System</a>)</li>
</ul>
<p>Aside from exposing the library primitives, Standout leverages best-in-breed crates like MiniJinja and console::Style under the hood. The lock-in is really negligible: you can use Standout's BB parser or swap it, manually dispatch handlers, and use the renderers directly in your clap dispatch.</p>
<h2 id="mutable-handlers-localapp"><a class="header" href="#mutable-handlers-localapp">Mutable Handlers (LocalApp)</a></h2>
<p>If your application logic uses <code>&amp;mut self</code> methods—common with database connections, file caches, or in-memory indices—you can use <code>LocalApp</code> instead of <code>App</code>:</p>
<pre><pre class="playground"><code class="language-rust">use standout::cli::{LocalApp, Output};
use standout::embed_templates;

struct PadStore {
    index: HashMap&lt;Uuid, Metadata&gt;,
}

impl PadStore {
    fn complete(&amp;mut self, id: Uuid) -&gt; Result&lt;()&gt; {
        // This needs &amp;mut self
        self.index.get_mut(&amp;id).unwrap().completed = true;
        Ok(())
    }
}

fn main() -&gt; anyhow::Result&lt;()&gt; {
    let mut store = PadStore::load()?;

    LocalApp::builder()
        .templates(embed_templates!("src/templates"))
        .command("complete", |m, ctx| {
            let id = m.get_one::&lt;Uuid&gt;("id").unwrap();
            store.complete(*id)?;  // &amp;mut store works!
            Ok(Output::Silent)
        }, "")
        .command("list", |m, ctx| {
            // Even read-only handlers work with LocalApp
            Ok(Output::Render(store.list()))
        }, "{{ items }}")
        .build()?
        .run(Cli::command(), std::env::args());
    Ok(())
}</code></pre></pre>
<p><strong>Key differences from <code>App</code>:</strong></p>
<ul>
<li><code>LocalApp::builder()</code> accepts <code>FnMut</code> closures (not just <code>Fn</code>)</li>
<li>Handlers can capture <code>&amp;mut</code> references to state</li>
<li>No <code>Send + Sync</code> requirement on handlers</li>
<li><code>app.run()</code> takes <code>&amp;mut self</code> instead of <code>&amp;self</code></li>
</ul>
<p>Use <code>LocalApp</code> when:</p>
<ul>
<li>Your API has <code>&amp;mut self</code> methods</li>
<li>You want to avoid <code>Arc&lt;Mutex&lt;_&gt;&gt;</code> wrappers</li>
<li>Your CLI is single-threaded (the common case)</li>
</ul>
<p>See <a href="guides/../topics/handler-contract.html">Handler Contract</a> for the full comparison.</p>
<h2 id="appendix-common-errors-and-troubleshooting"><a class="header" href="#appendix-common-errors-and-troubleshooting">Appendix: Common Errors and Troubleshooting</a></h2>
<ul>
<li>Template not found
<ul>
<li><strong>Error:</strong> <code>template 'list' not found</code></li>
<li><strong>Cause:</strong> The template path in <code>embed_templates!</code> doesn't match your file structure.</li>
<li><strong>Fix:</strong> Ensure the path is relative to your <code>Cargo.toml</code>, e.g., <code>embed_templates!("src/templates")</code> and that the file is named <code>list.jinja</code>, <code>list.j2</code>, or <code>list.txt</code>.</li>
</ul>
</li>
<li>Style not applied
<ul>
<li><strong>Symptom:</strong> Text appears but without colors/formatting.</li>
<li><strong>Cause:</strong> Style name in template doesn't match stylesheet.</li>
<li><strong>Fix:</strong> Check that <code>[mystyle]</code> in your template matches <code>.mystyle</code> in CSS or <code>mystyle:</code> in YAML. Run with <code>--output term-debug</code> to see style tag names.</li>
</ul>
</li>
<li>Handler not called
<ul>
<li><strong>Symptom:</strong> Command runs but nothing happens or wrong handler runs.</li>
<li><strong>Cause:</strong> Command name mismatch between clap enum variant and handler function.</li>
<li><strong>Fix:</strong> Ensure enum variant <code>List</code> maps to function <code>handlers::list</code> (snake_case conversion). Or use explicit mapping: <code>#[dispatch(handler = my_custom_handler)]</code></li>
</ul>
</li>
<li>JSON output is empty or wrong
<ul>
<li><strong>Symptom:</strong> <code>--output json</code> produces unexpected results.</li>
<li><strong>Cause:</strong> <code>Serialize</code> derive is missing or field names don't match template expectations.</li>
<li><strong>Fix:</strong> Ensure all types in your result implement <code>Serialize</code>. Use <code>#[serde(rename_all = "lowercase")]</code> for consistent naming.</li>
</ul>
</li>
<li>Styles not loading
<ul>
<li><strong>Error:</strong> <code>theme not found: default</code></li>
<li><strong>Cause:</strong> Stylesheet file missing or wrong path.</li>
<li><strong>Fix:</strong> Ensure <code>src/styles/default.css</code> or <code>default.yaml</code> exists. Check <code>embed_styles!</code> path matches your file structure.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-rendering"><a class="header" href="#introduction-to-rendering">Introduction to Rendering</a></h1>
<p>Terminal outputs have significant limitations: single font, single size, no graphics. But modern terminals provide many facilities like true colors, light/dark mode support, adaptive sizing, and more. Rich, helpful, and clear outputs are within reach.</p>
<p>The development reality explains why such output remains rare. From a primitive syntax born in the 1970s to the scattered ecosystem support, it's been a major effort to craft great outputs—and logically, it rarely makes sense to invest that time.</p>
<p>In the past few years, we've made rapid progress. Interactive TUIs have a rich and advanced ecosystem. For non-interactive, textual outputs, we've certainly come far with good crates and tools, but it's still sub-par.</p>
<p>Standout's rendering layer is designed to make crafting polished outputs a breeze by leveraging ideas, tools, and workflows from web applications—a domain in which rich interface authoring has evolved into the best model we've got. (But none of the JavaScript ecosystem chaos, rest assured.)</p>
<p>In this guide, we'll explore what makes great outputs and how Standout helps you get there.</p>
<p><strong>See Also:</strong></p>
<ul>
<li><a href="guides/../topics/rendering-system.html">Rendering System</a> - complete rendering API reference</li>
<li><a href="guides/../topics/output-modes.html">Output Modes</a> - all output format options</li>
<li><a href="guides/intro-to-standout.html">Introduction to Standout</a> - end-to-end adoption guide</li>
</ul>
<hr />
<h2 id="what-polished-output-entails"><a class="header" href="#what-polished-output-entails">What Polished Output Entails</a></h2>
<p>If you're building your CLI in Rust, chances are it's not a throwaway grep-formatting script—if that were the case, nothing beats shells. More likely, your program deals with complex data, logic, and computation, and the full power of Rust matters. In the same way, clear, well-presented, and designed outputs improve your users' experience when parsing that information.</p>
<p>Creating good results depends on discipline, consistency, and above all, experimentation—from exploring options to fine-tuning small details. Unlike code, good layout is experimental and takes many iterations: change, view result, change again, judge the new change, and so on.</p>
<p>The classical setup for shell UIs is anything but conducive to this. All presentation is mixed with code, often with complicated logic, if not coupled to it. Additionally, from escape codes to whitespace handling to spreading visual information across many lines of code, it becomes hard to visualize and change things.</p>
<p>The edit-code-compile-run cycle makes small tweaks take minutes. Sometimes a full hour for a minor change. In that scenario, it's no surprise that people don't bother.</p>
<hr />
<h2 id="our-example-tdoo"><a class="header" href="#our-example-tdoo">Our Example: tdoo</a></h2>
<p>We'll use <code>tdoo</code>, a simple todo list manager CLI, to demonstrate the rendering layer. Here's our data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Serialize)]
#[serde(rename_all = "lowercase")]
pub enum Status { Pending, Done }

#[derive(Clone, Serialize)]
pub struct Todo {
    pub title: String,
    pub status: Status,
}

#[derive(Serialize)]
pub struct TodoResult {
    pub message: Option&lt;String&gt;,
    pub todos: Vec&lt;Todo&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>Our goal: transform this raw data into polished, readable output that adapts to the terminal, respects user preferences, and takes minutes to iterate on—not hours.</p>
<hr />
<h2 id="the-separation-principle"><a class="header" href="#the-separation-principle">The Separation Principle</a></h2>
<p>Standout is designed around a strict separation of logic and presentation. This isn't just architectural nicety—it unlocks a fundamentally better workflow.</p>
<h3 id="without-separation"><a class="header" href="#without-separation">Without Separation</a></h3>
<p>Here's the typical approach, tangling logic and output:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn list_command(show_all: bool) {
    let todos = storage::list().unwrap();
    println!("\x1b[1;36mYour Todos\x1b[0m");
    println!("──────────");
    for (i, todo) in todos.iter().enumerate() {
        if show_all || todo.status == Status::Pending {
            let marker = if todo.status == Status::Done { "[x]" } else { "[ ]" };
            println!("{}. {} {}", i + 1, marker, todo.title);
        }
    }
    println!("\n{} todos total", todos.len());
}
<span class="boring">}</span></code></pre></pre>
<p>Problems:</p>
<ul>
<li>Escape codes are cryptic and error-prone</li>
<li>Changes require recompilation</li>
<li>Logic and presentation are intertwined</li>
<li>Testing is brittle</li>
<li>No easy way to support multiple output formats</li>
</ul>
<h3 id="with-separation"><a class="header" href="#with-separation">With Separation</a></h3>
<p>The same output, properly separated:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Handler: pure logic, returns data
pub fn list(matches: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;TodoResult&gt; {
    let show_all = matches.get_flag("all");
    let todos = storage::list()?;

    let filtered: Vec&lt;Todo&gt; = if show_all {
        todos
    } else {
        todos.into_iter()
            .filter(|t| matches!(t.status, Status::Pending))
            .collect()
    };

    Ok(Output::Render(TodoResult {
        message: Some(format!("{} todos total", filtered.len())),
        todos: filtered,
    }))
}
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-jinja">{# Template: list.jinja #}
[title]Your Todos[/title]
──────────
{% for todo in todos %}
[{{ todo.status }}]{{ todo.status }}[/{{ todo.status }}]  {{ todo.title }}
{% endfor %}

{% if message %}[muted]{{ message }}[/muted]{% endif %}
</code></pre>
<pre><code class="language-yaml"># Styles: theme.yaml
title:
  fg: cyan
  bold: true
done: green
pending: yellow
muted:
  dim: true
</code></pre>
<p>Now:</p>
<ul>
<li>Logic is testable without output concerns</li>
<li>Presentation is declarative and readable</li>
<li>Styles are centralized and named semantically</li>
<li>Changes to appearance don't require recompilation</li>
</ul>
<hr />
<h2 id="quick-iteration-and-workflow"><a class="header" href="#quick-iteration-and-workflow">Quick Iteration and Workflow</a></h2>
<p>The separation principle enables a radically better workflow. Here's what Standout provides:</p>
<h3 id="1-file-based-flow"><a class="header" href="#1-file-based-flow">1. File-Based Flow</a></h3>
<p>Dedicated files for templates and styles:</p>
<ul>
<li>Lower risk of breaking code—especially relevant for non-developer types like technical designers</li>
<li>Simpler diffs and easier navigation</li>
<li>Trivial to experiment with variations (duplicate files, swap names)</li>
</ul>
<p><strong>Directory structure:</strong></p>
<pre><code class="language-text">src/
├── handlers.rs        # Logic
└── templates/
    └── list.jinja     # Content template
styles/
└── default.yaml       # Visual styling
</code></pre>
<h3 id="2-hot-live-reload"><a class="header" href="#2-hot-live-reload">2. Hot Live Reload</a></h3>
<p>During development, you edit the template or styles and re-run. No compilation. No long turnaround.</p>
<p>This changes the entire experience. You can make and verify small adjustments in seconds. You can extensively fine-tune a command output quickly, then polish the full app in a focused session. Time efficiency aside, the quick iterative cycles encourage caring about smaller details, consistency—the things you forgo when iteration is painful.</p>
<p>(When released, files are compiled into the binary, costing no performance or path-handling headaches in distribution.)</p>
<p>See <a href="guides/../topics/rendering-system.html#hot-reloading">Rendering System</a> for details on how hot reload works.</p>
<hr />
<h2 id="best-of-breed-specialized-formats"><a class="header" href="#best-of-breed-specialized-formats">Best-of-Breed Specialized Formats</a></h2>
<h3 id="templates-minijinja"><a class="header" href="#templates-minijinja">Templates: MiniJinja</a></h3>
<p>Standout uses MiniJinja templates—a Rust implementation of Jinja, a de facto standard for rich and powerful templating. The simple syntax and powerful features let you map template text to actual output much easier than <code>println!</code> spreads.</p>
<pre><code class="language-jinja">{% if message %}[accent]{{ message }}[/accent]{% endif %}

{% for todo in todos %}
[{{ todo.status }}]{{ todo.status | upper }}[/{{ todo.status }}]  {{ todo.title }}
{% endfor %}
</code></pre>
<p>Benefits:</p>
<ul>
<li>Simple, readable syntax</li>
<li>Powerful control flow (loops, conditionals, filters)</li>
<li><strong>Partials support</strong>: templates can include other templates, enabling reuse across commands</li>
<li><strong>Custom filters</strong>: for complex presentation needs, write small bits of code and keep templates clean</li>
</ul>
<p>See <a href="guides/../topics/rendering-system.html">Rendering System</a> for template filters and context injection.</p>
<h3 id="styles-css-themes"><a class="header" href="#styles-css-themes">Styles: CSS Themes</a></h3>
<p>The styling layer uses CSS files with the familiar syntax you already know, but with simpler semantics tailored for terminals:</p>
<pre><code class="language-css">.title {
    color: cyan;
    font-weight: bold;
}

.done { color: green; }
.blocked { color: red; }
.pending { color: yellow; }

/* Adaptive for light/dark mode */
@media (prefers-color-scheme: light) {
    .panel { color: black; }
}

@media (prefers-color-scheme: dark) {
    .panel { color: white; }
}
</code></pre>
<p>Features:</p>
<ul>
<li><strong>Adaptive attributes</strong>: a style can render different values for light and dark modes</li>
<li><strong>Theming support</strong>: swap the entire visual appearance at once, with themes extending other themes</li>
<li><strong>True color</strong>: RGB values for precise colors (<code>#ff6b35</code> or <code>[255, 107, 53]</code>)</li>
<li><strong>Aliases</strong>: semantic names resolve to visual styles (<code>commit-message: title</code>)</li>
</ul>
<p>YAML syntax is also supported as an alternative. See <a href="guides/../topics/rendering-system.html#themes-and-styles">Rendering System</a> for complete style options.</p>
<hr />
<h2 id="template-integration-with-styling"><a class="header" href="#template-integration-with-styling">Template Integration with Styling</a></h2>
<p>Styles are applied with BBCode-like syntax: <code>[style]content[/style]</code>. A familiar, simple, and accessible form.</p>
<pre><code class="language-jinja">[title]Your Todos[/title]
{% for todo in todos %}
[{{ todo.status }}]{{ todo.title }}[/{{ todo.status }}]
{% endfor %}
</code></pre>
<p>Style tags:</p>
<ul>
<li>Nest properly: <code>[outer][inner]text[/inner][/outer]</code></li>
<li>Can span multiple lines</li>
<li>Can contain template logic: <code>[title]{% if x %}{{ x }}{% endif %}[/title]</code></li>
</ul>
<h3 id="graceful-degradation"><a class="header" href="#graceful-degradation">Graceful Degradation</a></h3>
<p><strong>Single template for rich and plain text.</strong> Standout degrades gracefully based on terminal capabilities:</p>
<pre><code class="language-bash">myapp list              # Rich colors (if terminal supports)
myapp list &gt; file.txt   # Plain text (not a TTY)
myapp list | less       # Plain text (pipe)
</code></pre>
<p>No separate templates for different output modes. The same template serves both.</p>
<h3 id="debug-mode"><a class="header" href="#debug-mode">Debug Mode</a></h3>
<p>Override auto behavior with <code>--output=term-debug</code> for debugging:</p>
<pre><code class="language-text">[title]Your Todos[/title]
[pending]pending[/pending]  Implement auth
[done]done[/done]  Fix tests
</code></pre>
<p>Style tags remain visible, making it easy to verify correct placement. Useful for testing and automation tools.</p>
<p>See <a href="guides/../topics/output-modes.html">Output Modes</a> for all available output formats.</p>
<hr />
<h2 id="tabular-layout"><a class="header" href="#tabular-layout">Tabular Layout</a></h2>
<p>Many commands output lists of things—log entries, servers, todos. These benefit from vertically aligned layouts. Aligning fields seems simple at first, but when you factor in ANSI awareness, flexible size ranges, wrapping behavior, truncation, justification, and expanding cells, it becomes really hard. Those one-off bugs that drive you mad—yeah, those.</p>
<p>Tabular gives you a declarative API, both in Rust and in templates, that handles all of this:</p>
<pre><code class="language-jinja">{% set t = tabular([
    {"name": "index", "width": 4},
    {"name": "status", "width": 10},
    {"name": "title", "width": "fill"}
], separator="  ") %}

{% for todo in todos %}
{{ t.row([loop.index, todo.status | style_as(todo.status), todo.title]) }}
{% endfor %}
</code></pre>
<p>Output adapts to terminal width:</p>
<pre><code class="language-text">1.    pending     Implement user authentication
2.    done        Review pull request #142
3.    pending     Update dependencies
</code></pre>
<p>Features:</p>
<ul>
<li>Fixed, range, fill, and fractional widths</li>
<li>Truncation (start, middle, end) with custom ellipsis</li>
<li>Word wrapping for long content</li>
<li>Per-column styling</li>
<li>Automatic field extraction from structs</li>
</ul>
<p>See <a href="guides/intro-to-tabular.html">Introduction to Tabular</a> for a comprehensive walkthrough.</p>
<hr />
<h2 id="output-control"><a class="header" href="#output-control">Output Control</a></h2>
<p>Standout supports various output formats at runtime with the <code>--output</code> option:</p>
<pre><code class="language-bash">myapp list                    # Auto: rich or plain based on terminal
myapp list --output=term      # Force rich terminal output
myapp list --output=text      # Force plain text
myapp list --output=term-debug # Show style tags for debugging
myapp list --output=json      # JSON serialization
myapp list --output=yaml      # YAML serialization
myapp list --output=csv       # CSV serialization
</code></pre>
<p><strong>Structured output for free.</strong> Because your handler returns a <code>Serialize</code>-able type, JSON/YAML/CSV outputs work automatically. Automation (tests, scripts, other programs) no longer needs to reverse-engineer data from formatted output.</p>
<pre><code class="language-bash">myapp list --output=json | jq '.tasks[] | select(.status == "blocked")'
</code></pre>
<p>Same handler, same types—different output format. This enables API-like behavior from CLI apps without writing separate code paths.</p>
<p>See <a href="guides/../topics/output-modes.html">Output Modes</a> for complete documentation.</p>
<hr />
<h2 id="putting-it-all-together"><a class="header" href="#putting-it-all-together">Putting It All Together</a></h2>
<p>Here's a complete example of a polished todo list command:</p>
<p><strong>Handler (<code>src/handlers.rs</code>):</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout::cli::{CommandContext, HandlerResult, Output};
use clap::ArgMatches;
use serde::Serialize;

#[derive(Clone, Serialize)]
#[serde(rename_all = "lowercase")]
pub enum Status { Pending, Done }

#[derive(Clone, Serialize)]
pub struct Todo {
    pub title: String,
    pub status: Status,
}

#[derive(Serialize)]
pub struct TodoResult {
    pub message: Option&lt;String&gt;,
    pub todos: Vec&lt;Todo&gt;,
}

pub fn list(matches: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;TodoResult&gt; {
    let show_all = matches.get_flag("all");
    let todos = storage::list()?;

    let filtered: Vec&lt;Todo&gt; = if show_all {
        todos
    } else {
        todos.into_iter()
            .filter(|t| matches!(t.status, Status::Pending))
            .collect()
    };

    let pending_count = filtered.iter()
        .filter(|t| matches!(t.status, Status::Pending))
        .count();

    Ok(Output::Render(TodoResult {
        message: Some(format!("{} pending", pending_count)),
        todos: filtered,
    }))
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Template (<code>src/templates/list.jinja</code>):</strong></p>
<pre><code class="language-jinja">[title]My Todos[/title]

{% set t = tabular([
    {"name": "index", "width": 4},
    {"name": "status", "width": 10},
    {"name": "title", "width": "fill"}
], separator="  ") %}

{% for todo in todos %}
{{ t.row([loop.index, todo.status | style_as(todo.status), todo.title]) }}
{% endfor %}

{% if message %}[muted]{{ message }}[/muted]{% endif %}
</code></pre>
<p><strong>Styles (<code>src/styles/default.yaml</code>):</strong></p>
<pre><code class="language-yaml">title:
  fg: cyan
  bold: true

done: green
pending: yellow

muted:
  dim: true
  light:
    fg: "#666666"
  dark:
    fg: "#999999"
</code></pre>
<p><strong>Output (terminal):</strong></p>
<pre><code class="language-text">My Todos

1.    pending     Implement user authentication
2.    done        Review pull request #142
3.    pending     Update dependencies

2 pending
</code></pre>
<p>With colors, "pending" appears yellow, "done" appears green. The title column fills available space.</p>
<p><strong>Output (<code>--output=json</code>):</strong></p>
<pre><code class="language-json">{
  "message": "2 pending",
  "todos": [
    {"title": "Implement user authentication", "status": "pending"},
    {"title": "Review pull request #142", "status": "done"},
    {"title": "Update dependencies", "status": "pending"}
  ]
}
</code></pre>
<p>Same handler. No additional code.</p>
<hr />
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Standout's rendering layer transforms CLI output from a chore into a pleasure:</p>
<ol>
<li>
<p><strong>Separation of concerns</strong>: Logic returns data. Templates define structure. Styles control appearance.</p>
</li>
<li>
<p><strong>Fast iteration</strong>: Hot reload means edit-and-see in seconds, not minutes. This changes what's practical.</p>
</li>
<li>
<p><strong>Familiar tools</strong>: MiniJinja for templates (Jinja syntax), CSS or YAML for styles. No new languages to learn.</p>
</li>
<li>
<p><strong>Graceful degradation</strong>: One template serves rich terminals, plain pipes, and everything in between.</p>
</li>
<li>
<p><strong>Structured output for free</strong>: JSON, YAML, and CSV outputs work automatically from your serializable types.</p>
</li>
<li>
<p><strong>Tabular layouts</strong>: Declarative column definitions handle alignment, wrapping, truncation, and ANSI-awareness.</p>
</li>
</ol>
<p>The rendering system makes it practical to care about details. When iteration is fast and changes are safe, polish becomes achievable—not aspirational.</p>
<p>For complete API details, see <a href="guides/../topics/rendering-system.html">Rendering System</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-tabular"><a class="header" href="#introduction-to-tabular">Introduction to Tabular</a></h1>
<p>Polished terminal output requires two things: good formatting (see <a href="guides/../topics/rendering-system.html">Rendering System</a>) and good layouts. For text-only, non-interactive output, layout mostly means aligning things vertically and controlling how multiple pieces of information are presented together.</p>
<p>Tabular provides a declarative column system with powerful primitives for sizing (fixed, range, fill, fractions), positioning (anchor to right), overflow handling (clip, wrap, truncate), cell alignment, and automated per-column styling.</p>
<p>Tabular is not only about tables. Any listing where items have multiple fields that benefit from vertical alignment is a good candidate—log entries with authors, timestamps, and messages; file listings with names, sizes, and dates; task lists with IDs, titles, and statuses. Add headers, separators, and borders to a tabular layout, and you have a table.</p>
<p>Tabular is designed to minimize grunt work. It offers a declarative API, template-based syntax, and derive macros to link your existing data types directly to column definitions. Complex tables with complex types can be handled declaratively, with precise control over layout and minimal code.</p>
<p>In this guide, we will walk our way up from a simpler table to a more complex one, exploring the available features of Tabular.</p>
<p><strong>See Also:</strong></p>
<ul>
<li><a href="guides/../topics/tabular.html">Tabular Reference</a> - complete API reference</li>
<li><a href="guides/../topics/rendering-system.html">Rendering System</a> - templates and styles in depth</li>
</ul>
<hr />
<h2 id="our-example-tdoo-1"><a class="header" href="#our-example-tdoo-1">Our Example: tdoo</a></h2>
<p>We'll build the output for <code>tdoo list</code>, a command that shows todos. This is a perfect Tabular use case: each todo has an index, title, and status. We want them aligned, readable, and visually clear at a glance.</p>
<p>Here's our data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Serialize)]
#[serde(rename_all = "lowercase")]
pub enum Status { Pending, Done }

#[derive(Clone, Serialize)]
struct Todo {
    title: String,
    status: Status,
}

let todos = vec![
    Todo { title: "Implement user authentication".into(), status: Status::Pending },
    Todo { title: "Fix payment gateway timeout".into(), status: Status::Pending },
    Todo { title: "Update documentation for API v2".into(), status: Status::Done },
    Todo { title: "Review pull request #142".into(), status: Status::Pending },
];
<span class="boring">}</span></code></pre></pre>
<p>Let's progressively build this from raw output to a polished, professional listing.</p>
<hr />
<h2 id="step-1-the-problem-with-plain-output"><a class="header" href="#step-1-the-problem-with-plain-output">Step 1: The Problem with Plain Output</a></h2>
<p>Without any formatting, a naive approach might look like this:</p>
<pre><code class="language-jinja">{% for todo in todos %}
{{ loop.index }}. {{ todo.title }} {{ todo.status }}
{% endfor %}
</code></pre>
<p>Output:</p>
<pre><code class="language-text">1. Implement user authentication pending
2. Fix payment gateway timeout pending
3. Update documentation for API v2 done
4. Review pull request #142 pending
</code></pre>
<p>This is barely readable. Fields run together, nothing aligns, and scanning the list requires mental parsing of each line. Let's fix that.</p>
<hr />
<h2 id="step-2-basic-column-alignment-with-col"><a class="header" href="#step-2-basic-column-alignment-with-col">Step 2: Basic Column Alignment with <code>col</code></a></h2>
<p>The simplest improvement is the <code>col</code> filter. It pads (or truncates) each value to a fixed width:</p>
<pre><code class="language-jinja">{% for todo in todos %}
{{ loop.index | col(4) }}  {{ todo.status | col(10) }}  {{ todo.title | col(40) }}
{% endfor %}
</code></pre>
<p>Output:</p>
<pre><code class="language-text">1.    pending     Implement user authentication
2.    pending     Fix payment gateway timeout
3.    done        Update documentation for API v2
4.    pending     Review pull request #142
</code></pre>
<p>Already much better. Each column aligns vertically, making it easy to scan. But we've hardcoded widths, and if a title is too long, it gets truncated with <code>…</code>.</p>
<blockquote>
<p><strong>Key insight:</strong> The <code>col</code> filter handles Unicode correctly. CJK characters count as 2 columns, combining marks don't add width, and ANSI escape codes are preserved but not counted.</p>
</blockquote>
<hr />
<h2 id="step-3-structured-layout-with-tabular"><a class="header" href="#step-3-structured-layout-with-tabular">Step 3: Structured Layout with <code>tabular()</code></a></h2>
<p>For more control, use the <code>tabular()</code> function. This creates a formatter that you configure once and use for all rows:</p>
<pre><code class="language-jinja">{% set t = tabular([
    {"name": "index", "width": 4},
    {"name": "status", "width": 10},
    {"name": "title", "width": 40}
], separator="  ") %}

{% for todo in todos %}
{{ t.row([loop.index, todo.status, todo.title]) }}
{% endfor %}
</code></pre>
<p>The output looks the same, but now the column definitions are centralized. This becomes powerful when we start adding features.</p>
<hr />
<h2 id="step-4-flexible-widths"><a class="header" href="#step-4-flexible-widths">Step 4: Flexible Widths</a></h2>
<p>Hardcoded widths are fragile. What if the terminal is wider or narrower? Tabular offers flexible width strategies:</p>
<div class="table-wrapper"><table><thead><tr><th>Width</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>8</code></td><td>Exactly 8 columns (fixed)</td></tr>
<tr><td><code>{"min": 10}</code></td><td>At least 10, grows to fit content</td></tr>
<tr><td><code>{"min": 10, "max": 30}</code></td><td>Between 10 and 30</td></tr>
<tr><td><code>"fill"</code></td><td>Takes all remaining space</td></tr>
<tr><td><code>"2fr"</code></td><td>2 parts of remaining (proportional)</td></tr>
</tbody></table>
</div>
<p>Let's make the title column expand to fill available space:</p>
<pre><code class="language-jinja">{% set t = tabular([
    {"name": "index", "width": 4},
    {"name": "status", "width": 10},
    {"name": "title", "width": "fill"}
], separator="  ") %}
</code></pre>
<p>Now on an 80-column terminal:</p>
<pre><code class="language-text">1.    pending     Implement user authentication
2.    pending     Fix payment gateway timeout
3.    done        Update documentation for API v2
4.    pending     Review pull request #142
</code></pre>
<p>On a 120-column terminal, the title column automatically expands to use the extra space.</p>
<p>The layout adapts to the available space.</p>
<hr />
<h2 id="step-5-right-align-numbers"><a class="header" href="#step-5-right-align-numbers">Step 5: Right-Align Numbers</a></h2>
<p>Numbers and indices look better right-aligned. Use the <code>align</code> option:</p>
<pre><code class="language-jinja">{% set t = tabular([
    {"name": "index", "width": 4, "align": "right"},
    {"name": "status", "width": 10},
    {"name": "title", "width": "fill"}
], separator="  ") %}
</code></pre>
<p>Output:</p>
<pre><code class="language-text">  1.  pending     Implement user authentication
  2.  pending     Fix payment gateway timeout
  3.  done        Update documentation for API v2
  4.  pending     Review pull request #142
</code></pre>
<p>The indices now align on the right edge of their column.</p>
<hr />
<h2 id="step-6-anchoring-columns"><a class="header" href="#step-6-anchoring-columns">Step 6: Anchoring Columns</a></h2>
<p>Sometimes you want a column pinned to the terminal's right edge, regardless of how other columns resize. Use <code>anchor</code>:</p>
<pre><code class="language-jinja">{% set t = tabular([
    {"name": "index", "width": 4},
    {"name": "title", "width": "fill"},
    {"name": "status", "width": 10, "anchor": "right"}
], separator="  ") %}
</code></pre>
<p>Now the status column is always at the right edge. If the terminal is 100 columns or 200, the status stays anchored. The fill column absorbs the extra space between fixed columns and anchored columns.</p>
<hr />
<h2 id="step-7-handling-long-content"><a class="header" href="#step-7-handling-long-content">Step 7: Handling Long Content</a></h2>
<p>What happens when a title is longer than its column? By default, Tabular truncates at the end with <code>…</code>. But you have options:</p>
<h3 id="truncate-at-different-positions"><a class="header" href="#truncate-at-different-positions">Truncate at Different Positions</a></h3>
<pre><code class="language-jinja">{"name": "title", "width": 30, "overflow": "truncate"}                        {# "Very long title th…" #}
{"name": "title", "width": 30, "overflow": {"truncate": {"at": "start"}}}     {# "…itle that is long" #}
{"name": "title", "width": 30, "overflow": {"truncate": {"at": "middle"}}}    {# "Very long…is long" #}
</code></pre>
<p>Middle truncation is perfect for file paths where both the start and end matter: <code>/home/user/…/important.txt</code></p>
<h3 id="wrap-to-multiple-lines"><a class="header" href="#wrap-to-multiple-lines">Wrap to Multiple Lines</a></h3>
<p>For descriptions or messages, wrapping is often better than truncating:</p>
<pre><code class="language-jinja">{% set t = tabular([
    {"name": "index", "width": 4},
    {"name": "title", "width": 40, "overflow": "wrap"},
    {"name": "status", "width": 10}
], separator="  ") %}
</code></pre>
<p>If a title exceeds 40 columns, it wraps:</p>
<pre><code class="language-text">1.    Implement comprehensive error handling    pending
      for all API endpoints with proper
      logging and user feedback
2.    Quick fix                                 done
</code></pre>
<p>The wrapped lines are indented to align with the column.</p>
<hr />
<h2 id="step-8-dynamic-styling-based-on-values"><a class="header" href="#step-8-dynamic-styling-based-on-values">Step 8: Dynamic Styling Based on Values</a></h2>
<p>Here's where Tabular shines for todo lists. We want status colors: green for done, yellow for pending.</p>
<p>First, define styles in your <a href="guides/../topics/rendering-system.html#themes-and-styles">theme</a>:</p>
<pre><code class="language-css">/* styles/default.css */
.done { color: green; }
.pending { color: yellow; }
</code></pre>
<p>Then use the <code>style_as</code> filter to apply styles based on the value itself:</p>
<pre><code class="language-jinja">{% set t = tabular([
    {"name": "index", "width": 4},
    {"name": "status", "width": 10},
    {"name": "title", "width": "fill"}
], separator="  ") %}

{% for todo in todos %}
{{ t.row([loop.index, todo.status | style_as(todo.status), todo.title]) }}
{% endfor %}
</code></pre>
<p>The <code>style_as</code> filter wraps the value in style tags: <code>[done]done[/done]</code>. Standout's rendering system then applies the green color.</p>
<p>Output (with colors):</p>
<pre><code class="language-text">1.    [yellow]pending[/yellow]   Implement user authentication
2.    [yellow]pending[/yellow]   Fix payment gateway timeout
3.    [green]done[/green]        Update documentation for API v2
4.    [yellow]pending[/yellow]   Review pull request #142
</code></pre>
<p>In the terminal, statuses appear in their respective colors, making it instantly clear which todos need attention.</p>
<hr />
<h2 id="step-9-column-level-styles"><a class="header" href="#step-9-column-level-styles">Step 9: Column-Level Styles</a></h2>
<p>Instead of styling individual values, you can style entire columns. This is useful for de-emphasizing certain information:</p>
<pre><code class="language-jinja">{% set t = tabular([
    {"name": "index", "width": 4, "style": "muted"},
    {"name": "status", "width": 10},
    {"name": "title", "width": "fill"}
], separator="  ") %}
</code></pre>
<p>Now indices appear in a muted style (typically gray), while titles and statuses remain prominent. This creates visual hierarchy.</p>
<hr />
<h2 id="step-10-automatic-field-extraction"><a class="header" href="#step-10-automatic-field-extraction">Step 10: Automatic Field Extraction</a></h2>
<p>Tired of manually listing <code>[todo.title, todo.status, ...]</code>? If your column names match your struct fields, use <code>row_from()</code>:</p>
<pre><code class="language-jinja">{% set t = tabular([
    {"name": "title", "width": "fill"},
    {"name": "status", "width": 10}
]) %}

{% for todo in todos %}
{{ t.row_from(todo) }}
{% endfor %}
</code></pre>
<p>Tabular extracts <code>todo.title</code>, <code>todo.status</code>, etc. automatically. For nested fields, use <code>key</code>:</p>
<pre><code class="language-jinja">{"name": "Author", "key": "author.name", "width": 20}
{"name": "Email", "key": "author.email", "width": 30}
</code></pre>
<hr />
<h2 id="step-11-adding-headers-and-borders"><a class="header" href="#step-11-adding-headers-and-borders">Step 11: Adding Headers and Borders</a></h2>
<p>For a proper table with headers, switch from <code>tabular()</code> to <code>table()</code>:</p>
<pre><code class="language-jinja">{% set t = table([
    {"name": "#", "width": 4},
    {"name": "Status", "width": 10},
    {"name": "Title", "width": "fill"}
], border="rounded", header_style="bold") %}

{{ t.header_row() }}
{{ t.separator_row() }}
{% for todo in todos %}
{{ t.row([loop.index, todo.status, todo.title]) }}
{% endfor %}
{{ t.bottom_border() }}
</code></pre>
<p>Output:</p>
<pre><code class="language-text">╭──────┬────────────┬────────────────────────────────────────╮
│ #    │ Status     │ Title                                  │
├──────┼────────────┼────────────────────────────────────────┤
│ 1    │ pending    │ Implement user authentication          │
│ 2    │ pending    │ Fix payment gateway timeout            │
│ 3    │ done       │ Update documentation for API v2        │
│ 4    │ pending    │ Review pull request #142               │
╰──────┴────────────┴────────────────────────────────────────╯
</code></pre>
<h3 id="border-styles"><a class="header" href="#border-styles">Border Styles</a></h3>
<p>Choose from six border styles:</p>
<div class="table-wrapper"><table><thead><tr><th>Style</th><th>Look</th></tr></thead><tbody>
<tr><td><code>"none"</code></td><td>No borders</td></tr>
<tr><td><code>"ascii"</code></td><td><code>+--+--+</code> (ASCII compatible)</td></tr>
<tr><td><code>"light"</code></td><td><code>┌──┬──┐</code></td></tr>
<tr><td><code>"heavy"</code></td><td><code>┏━━┳━━┓</code></td></tr>
<tr><td><code>"double"</code></td><td><code>╔══╦══╗</code></td></tr>
<tr><td><code>"rounded"</code></td><td><code>╭──┬──╮</code></td></tr>
</tbody></table>
</div>
<h3 id="row-separators"><a class="header" href="#row-separators">Row Separators</a></h3>
<p>For dense data, add lines between rows:</p>
<pre><code class="language-jinja">{% set t = table(columns, border="light", row_separator=true) %}
</code></pre>
<pre><code class="language-text">┌──────┬────────────────────────────────────╮
│ #    │ Title                              │
├──────┼────────────────────────────────────┤
│ 1    │ Implement user authentication      │
├──────┼────────────────────────────────────┤
│ 2    │ Fix payment gateway timeout        │
└──────┴────────────────────────────────────┘
</code></pre>
<hr />
<h2 id="step-12-the-complete-example"><a class="header" href="#step-12-the-complete-example">Step 12: The Complete Example</a></h2>
<p>Putting it all together, here's our polished todo list:</p>
<pre><code class="language-jinja">{% set t = table([
    {"name": "#", "width": 4, "style": "muted"},
    {"name": "Status", "width": 10},
    {"name": "Title", "width": "fill", "overflow": {"truncate": {"at": "middle"}}}
], border="rounded", header_style="bold", separator=" │ ") %}

{{ t.header_row() }}
{{ t.separator_row() }}
{% for todo in todos %}
{{ t.row([loop.index, todo.status | style_as(todo.status), todo.title]) }}
{% endfor %}
{{ t.bottom_border() }}
</code></pre>
<p>Output (80 columns, with styling):</p>
<pre><code class="language-text">╭──────┬────────────┬───────────────────────────────────────────────────────╮
│ #    │ Status     │ Title                                                 │
├──────┼────────────┼───────────────────────────────────────────────────────┤
│ 1    │ pending    │ Implement user authentication                         │
│ 2    │ pending    │ Fix payment gateway timeout                           │
│ 3    │ done       │ Update documentation for API v2                       │
│ 4    │ pending    │ Review pull request #142                              │
╰──────┴────────────┴───────────────────────────────────────────────────────╯
</code></pre>
<p>Features in use:</p>
<ul>
<li><strong>Rounded borders</strong> for a modern look</li>
<li><strong>Muted styling</strong> on index column for visual hierarchy</li>
<li><strong>Fill width</strong> on title to use available space</li>
<li><strong>Middle truncation</strong> for titles that exceed the column</li>
<li><strong>Dynamic status colors</strong> via <code>style_as</code></li>
</ul>
<hr />
<h2 id="using-tabular-from-rust"><a class="header" href="#using-tabular-from-rust">Using Tabular from Rust</a></h2>
<p>Everything shown in templates is also available in Rust:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout::tabular::{TabularSpec, Col, Table, BorderStyle};

let spec = TabularSpec::builder()
    .column(Col::fixed(4).header("#").style("muted"))
    .column(Col::fixed(10).header("Status"))
    .column(Col::fill().header("Title").truncate_middle())
    .separator(" │ ")
    .build();

let table = Table::new(spec, 80)
    .header_from_columns()
    .header_style("bold")
    .border(BorderStyle::Rounded);

// Render the full table
let output = table.render(&amp;data);

// Or render parts manually for custom logic
println!("{}", table.header_row());
println!("{}", table.separator_row());
for (i, todo) in todos.iter().enumerate() {
    println!("{}", table.row(&amp;[&amp;(i + 1).to_string(), &amp;todo.status.to_string(), &amp;todo.title]));
}
println!("{}", table.bottom_border());
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="derive-macros-type-safe-table-definitions"><a class="header" href="#derive-macros-type-safe-table-definitions">Derive Macros: Type-Safe Table Definitions</a></h2>
<p>Instead of manually building <code>TabularSpec</code> instances, you can use derive macros to generate them from struct annotations. This keeps your column definitions co-located with your data types and ensures they stay in sync.</p>
<h3 id="derivetabular---generate-spec-from-struct"><a class="header" href="#derivetabular---generate-spec-from-struct"><code>#[derive(Tabular)]</code> - Generate Spec from Struct</a></h3>
<p>Add <code>#[col(...)]</code> attributes to your struct fields to define column properties:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout::tabular::{Tabular, TabularRow, Table, BorderStyle};
use serde::Serialize;

#[derive(Clone, Serialize)]
#[serde(rename_all = "lowercase")]
pub enum Status { Pending, Done }

#[derive(Clone, Serialize, Tabular, TabularRow)]
#[tabular(separator = " │ ")]
struct Todo {
    #[col(width = "fill", header = "Title", overflow = "truncate", truncate_at = "middle")]
    title: String,

    #[col(width = 10, header = "Status")]
    status: Status,
}
<span class="boring">}</span></code></pre></pre>
<p>Now create formatters and tables directly from the type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create a table using the derived spec
let table = Table::from_type::&lt;Todo&gt;(80)
    .header_from_columns()
    .border(BorderStyle::Rounded);

// Render rows using the TabularRow trait (no JSON serialization)
for todo in &amp;todos {
    println!("{}", table.row_from_trait(todo));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="available-field-attributes"><a class="header" href="#available-field-attributes">Available Field Attributes</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Attribute</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>width</code></td><td><code>8</code>, <code>"fill"</code>, <code>"2fr"</code></td><td>Column width strategy</td></tr>
<tr><td><code>min</code>, <code>max</code></td><td><code>usize</code></td><td>Bounded width range</td></tr>
<tr><td><code>align</code></td><td><code>"left"</code>, <code>"right"</code>, <code>"center"</code></td><td>Text alignment within cell</td></tr>
<tr><td><code>anchor</code></td><td><code>"left"</code>, <code>"right"</code></td><td>Column position in row</td></tr>
<tr><td><code>overflow</code></td><td><code>"truncate"</code>, <code>"wrap"</code>, <code>"clip"</code>, <code>"expand"</code></td><td>How to handle long content</td></tr>
<tr><td><code>truncate_at</code></td><td><code>"end"</code>, <code>"start"</code>, <code>"middle"</code></td><td>Where to truncate</td></tr>
<tr><td><code>style</code></td><td>string</td><td>Style name for entire column</td></tr>
<tr><td><code>style_from_value</code></td><td>flag</td><td>Use cell value as style name</td></tr>
<tr><td><code>header</code></td><td>string</td><td>Column header text</td></tr>
<tr><td><code>null_repr</code></td><td>string</td><td>Representation for null values</td></tr>
<tr><td><code>key</code></td><td>string</td><td>Override field name for extraction</td></tr>
<tr><td><code>skip</code></td><td>flag</td><td>Exclude field from table</td></tr>
</tbody></table>
</div>
<h3 id="container-attributes"><a class="header" href="#container-attributes">Container Attributes</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Attribute</th><th>Description</th></tr></thead><tbody>
<tr><td><code>separator</code></td><td>Column separator (default: <code>"  "</code>)</td></tr>
<tr><td><code>prefix</code></td><td>Row prefix</td></tr>
<tr><td><code>suffix</code></td><td>Row suffix</td></tr>
</tbody></table>
</div>
<h3 id="using-with-templates"><a class="header" href="#using-with-templates">Using with Templates</a></h3>
<p>The derived spec can be injected into templates using helper functions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout::tabular::filters::{table_from_type, register_tabular_filters};
use minijinja::{context, Environment};

let mut env = Environment::new();
register_tabular_filters(&amp;mut env);

// Create a table from the derived spec
let table = table_from_type::&lt;Todo&gt;(80, BorderStyle::Light, true);

// Use in template context
env.add_template("todos", r#"
{{ tbl.top_border() }}
{{ tbl.header_row() }}
{{ tbl.separator_row() }}
{% for todo in todos %}{{ tbl.row([todo.title, todo.status]) }}
{% endfor %}{{ tbl.bottom_border() }}
"#)?;

let output = env.get_template("todos")?.render(context! {
    tbl =&gt; table,
    todos =&gt; todo_data,
})?;
<span class="boring">}</span></code></pre></pre>
<h3 id="why-two-macros"><a class="header" href="#why-two-macros">Why Two Macros?</a></h3>
<ul>
<li><strong><code>#[derive(Tabular)]</code></strong> generates the <code>TabularSpec</code> (column definitions, widths, styles)</li>
<li><strong><code>#[derive(TabularRow)]</code></strong> generates efficient row extraction (field values to strings)</li>
</ul>
<p>You can use them independently:</p>
<ul>
<li>Use only <code>Tabular</code> with <code>row_from()</code> to keep serde-based extraction</li>
<li>Use only <code>TabularRow</code> with manually-built specs for maximum control</li>
<li>Use both together for the best type safety and performance</li>
</ul>
<hr />
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>Tabular transforms raw data into polished, scannable output with minimal effort:</p>
<ol>
<li><strong>Start simple</strong> - use <code>col</code> filter for quick alignment</li>
<li><strong>Structure with <code>tabular()</code></strong> - centralize column definitions</li>
<li><strong>Flex with widths</strong> - use <code>fill</code>, bounded ranges, and fractions</li>
<li><strong>Align content</strong> - right-align numbers and dates</li>
<li><strong>Anchor columns</strong> - pin important data to edges</li>
<li><strong>Handle overflow</strong> - truncate intelligently or wrap</li>
<li><strong>Add visual hierarchy</strong> - style columns and values dynamically</li>
<li><strong>Extract automatically</strong> - let <code>row_from()</code> pull fields from structs</li>
<li><strong>Decorate as tables</strong> - add borders, headers, and separators</li>
<li><strong>Use derive macros</strong> - <code>#[derive(Tabular, TabularRow)]</code> for type-safe definitions</li>
</ol>
<p>The declarative approach means your layout adapts to terminal width, handles Unicode correctly, and remains maintainable as your data evolves.</p>
<p>For complete API details, see the <a href="guides/../topics/tabular.html">Tabular Reference</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fast-paced-intro-to-your-first-standout-based-command"><a class="header" href="#fast-paced-intro-to-your-first-standout-based-command">Fast Paced intro to your First Standout Based Command</a></h1>
<p>This is a terse and direct how to for more experienced developers or at least the ones in a hurry.
It skimps rationale, design and other useful bits you can read from the <a href="guides/intro-to-standout.html">longer form version</a></p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>A cli app, that uses clap for arg parsing.
A command fucntion that is pure logic, that is , returns the result, and does not print to stdout or format output.</p>
<p>For this guide's purpose we'll use a ficticious "list" command of our todo list manager</p>
<h2 id="the-core-a-pure-function-logic-handler"><a class="header" href="#the-core-a-pure-function-logic-handler">The Core: A pure function logic handler</a></h2>
<p>The logic handler: receives parsed cli args, and returns a serializable data structure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn list(matches: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;TodoResult&gt; {}
<span class="boring">}</span></code></pre></pre>
<h2 id="making-it-oustanding"><a class="header" href="#making-it-oustanding">Making it oustanding</a></h2>
<h3 id="1-the-file-system"><a class="header" href="#1-the-file-system">1. The File System</a></h3>
<p>Create a templates/list.jinja and styles/default.css:</p>
<pre><code class="language-text">    src/
        ├── handlers.rs         # where list it
        ├── templates/          # standout will match templates name against rel. paths from temp root, here
            ├── list.jinja      # the template to render list, name matched against the command name
        ├── styles/             #  likewise for themes, this sets a theme called "default"
            ├── default.css     # the default style for the command, filename will be the theme name
</code></pre>
<h3 id="2-define-your-styles"><a class="header" href="#2-define-your-styles">2. Define your styles</a></h3>
<pre><code class="language-css">    .done {
        text-decoration: line-through;
        color: gray;
    }
    .pending {
        font-weight: bold;
        color: white;
    }
    .index {
        color: yellow;
    }
</code></pre>
<h3 id="3-write-your-template"><a class="header" href="#3-write-your-template">3. Write your template</a></h3>
<pre><code class="language-Jinja">    {% if message %}
        [message]{{ message }} [/message]
    {% endif %}
    {% for todo in todos %}
        [index]{{ loop.index }}.[/index] [{{ todo.status }}]{{ todo.title }}[/{{ todo.status }}]
    {% endfor %}
</code></pre>
<h3 id="4-putting-it-all-together"><a class="header" href="#4-putting-it-all-together">4. Putting it all together</a></h3>
<p>Configure the app:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let app = App::builder()
        .templates(embed_templates!("src/templates"))    //  Sets the root template path, hot relead for dev, embeded in release
        .styles(embed_styles!("src/styles"))                       //  Likewise the styles root
        .default_theme("default")                                       // Use styles/default.css or default.yaml
        .commands(Commands::dispatch_config())          // Register handlers from derive macro
    .build()?;
<span class="boring">}</span></code></pre></pre>
<p>Connect your logic to a command name and template :</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[dispatch(handlers = handlers)]
    pub enum Commands {
          ...
          list,
    }
<span class="boring">}</span></code></pre></pre>
<p>And finally, run in main, the autodispatcher:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    match app.run(Cli::command(), std::env::args()) {
        // If you've got other commands on vanilla manual dispatch, call it for unported commands
        RunResult::NoMatch(matches) =&gt; legacy_dispatch(matches),  // Your existing handler
    }
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="topics"><a class="header" href="#topics">Topics</a></h1>
<p>In-depth documentation for specific Standout systems and use cases.</p>
<hr />
<h2 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h2>
<h3 id="handler-contract"><a class="header" href="#handler-contract"><a href="topics/handler-contract.html">Handler Contract</a></a></h3>
<p>The interface between your logic and Standout. Covers the <code>Handler</code> trait, <code>HandlerResult</code>, the <code>Output</code> enum (<code>Render</code>, <code>Silent</code>, <code>Binary</code>), and <code>CommandContext</code>. Essential reading for understanding how handlers return data to be rendered.</p>
<h3 id="rendering-system"><a class="header" href="#rendering-system"><a href="topics/rendering-system.html">Rendering System</a></a></h3>
<p>How Standout transforms data into styled terminal output. Covers the two-pass architecture (MiniJinja + BBParser), style tags, themes, template filters, context injection, and structured output modes.</p>
<h3 id="output-modes-1"><a class="header" href="#output-modes-1"><a href="topics/output-modes.html">Output Modes</a></a></h3>
<p>The <code>--output</code> flag and <code>OutputMode</code> enum. Covers auto/term/text modes for terminal output, structured modes (JSON, YAML, XML, CSV), file output, and how to access the mode in handlers.</p>
<h3 id="execution-model"><a class="header" href="#execution-model"><a href="topics/execution-model.html">Execution Model</a></a></h3>
<p>The request lifecycle from CLI input to rendered output. Covers the pipeline (parsing, dispatch, handler, hooks, rendering), command paths, the hooks system (pre-dispatch, post-dispatch, post-output), and default command behavior.</p>
<hr />
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<h3 id="app-configuration"><a class="header" href="#app-configuration"><a href="topics/app-configuration.html">App Configuration</a></a></h3>
<p>The <code>AppBuilder</code> API for configuring your application. Covers embedding templates and styles, theme selection, command registration, hooks, context injection, flag customization, and the complete setup workflow.</p>
<h3 id="topics-system"><a class="header" href="#topics-system"><a href="topics/topics-system.html">Topics System</a></a></h3>
<p>Adding help topics to your CLI. Covers the <code>Topic</code> struct, <code>TopicRegistry</code>, loading topics from directories, help integration, pager support, and custom rendering.</p>
<hr />
<h2 id="layout"><a class="header" href="#layout">Layout</a></h2>
<h3 id="tabular-layout-1"><a class="header" href="#tabular-layout-1"><a href="topics/tabular.html">Tabular Layout</a></a></h3>
<p>Creating aligned, readable output for lists and tables. Covers the <code>col</code> filter, <code>tabular()</code> and <code>table()</code> functions, flexible widths, overflow handling, column styling, borders, and the Rust API.</p>
<hr />
<h2 id="standalone-usage"><a class="header" href="#standalone-usage">Standalone Usage</a></h2>
<h3 id="partial-adoption"><a class="header" href="#partial-adoption"><a href="topics/partial-adoption.html">Partial Adoption</a></a></h3>
<p>Migrating an existing CLI to Standout incrementally. Covers using <code>run</code> with fallback dispatch, progressive command migration, and full adoption patterns.</p>
<h3 id="render-only"><a class="header" href="#render-only"><a href="topics/render-only.html">Render Only</a></a></h3>
<p>Using Standout's rendering layer without CLI integration. Covers standalone rendering functions, building themes programmatically, template validation, and context injection for non-CLI use cases.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-handler-contract"><a class="header" href="#the-handler-contract">The Handler Contract</a></h1>
<p>Handlers are where your application logic lives. Standout's handler contract is designed to be <strong>explicit</strong> rather than permissive. By enforcing serializable return types and clear ownership semantics, the framework guarantees that your code remains testable and decoupled from output formatting.</p>
<p>Instead of fighting with generic <code>Any</code> types or global state, you work with a clear contract: inputs are references, output is a <code>Result</code>.</p>
<p>See also:</p>
<ul>
<li><a href="topics/output-modes.html">Output Modes</a> for how the output enum interacts with formats.</li>
</ul>
<h2 id="handler-modes"><a class="header" href="#handler-modes">Handler Modes</a></h2>
<p>Standout supports two handler modes to accommodate different use cases:</p>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th><code>Handler</code> (default)</th><th><code>LocalHandler</code></th></tr></thead><tbody>
<tr><td>App type</td><td><code>App</code></td><td><code>LocalApp</code></td></tr>
<tr><td>Self reference</td><td><code>&amp;self</code></td><td><code>&amp;mut self</code></td></tr>
<tr><td>Closure type</td><td><code>Fn</code></td><td><code>FnMut</code></td></tr>
<tr><td>Thread bounds</td><td><code>Send + Sync</code></td><td>None</td></tr>
<tr><td>State mutation</td><td>Via interior mutability</td><td>Direct</td></tr>
<tr><td>Use case</td><td>Libraries, async, multi-threaded</td><td>Simple CLIs with mutable state</td></tr>
</tbody></table>
</div>
<p>Choose based on your needs:</p>
<ul>
<li>
<p><strong><code>App</code> with <code>Handler</code></strong>: Default. Use when handlers are stateless or use interior mutability (<code>Arc&lt;Mutex&lt;_&gt;&gt;</code>). Required for potential multi-threading.</p>
</li>
<li>
<p><strong><code>LocalApp</code> with <code>LocalHandler</code></strong>: Use when your handlers need <code>&amp;mut self</code> access without wrapper types. Ideal for single-threaded CLIs.</p>
</li>
</ul>
<h2 id="the-handler-trait-thread-safe"><a class="header" href="#the-handler-trait-thread-safe">The Handler Trait (Thread-safe)</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Handler: Send + Sync {
    type Output: Serialize;
    fn handle(&amp;self, matches: &amp;ArgMatches, ctx: &amp;CommandContext) -&gt; HandlerResult&lt;Self::Output&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>Key constraints:</p>
<ul>
<li><strong>Send + Sync required</strong>: Handlers may be called from multiple threads</li>
<li><strong>Output must be Serialize</strong>: Needed for JSON/YAML modes and template context</li>
<li><strong>Immutable references</strong>: Handlers cannot modify arguments or context</li>
</ul>
<p>Implementing the trait directly is useful when your handler needs internal state—database connections, configuration, etc. For stateless logic, closure handlers are more convenient.</p>
<h2 id="closure-handlers"><a class="header" href="#closure-handlers">Closure Handlers</a></h2>
<p>Most handlers are simple closures:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::builder()
    .command("list", |matches, ctx| {
        let verbose = matches.get_flag("verbose");
        let items = storage::list()?;
        Ok(Output::Render(ListResult { items, verbose }))
    }, "list.j2")
<span class="boring">}</span></code></pre></pre>
<p>The closure signature:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn(&amp;ArgMatches, &amp;CommandContext) -&gt; HandlerResult&lt;T&gt;
where T: Serialize + Send + Sync
<span class="boring">}</span></code></pre></pre>
<p>Closures must be <code>Fn</code> (not <code>FnMut</code> or <code>FnOnce</code>) because Standout may call them multiple times in certain scenarios.</p>
<h2 id="the-localhandler-trait-mutable-state"><a class="header" href="#the-localhandler-trait-mutable-state">The LocalHandler Trait (Mutable State)</a></h2>
<p>When your handlers need <code>&amp;mut self</code> access—common with database connections, file caches, or in-memory indices—use <code>LocalHandler</code> with <code>LocalApp</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait LocalHandler {
    type Output: Serialize;
    fn handle(&amp;mut self, matches: &amp;ArgMatches, ctx: &amp;CommandContext) -&gt; HandlerResult&lt;Self::Output&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>Key differences from <code>Handler</code>:</p>
<ul>
<li><strong>No Send + Sync</strong>: Handlers don't need to be thread-safe</li>
<li><strong>Mutable self</strong>: <code>&amp;mut self</code> allows direct state modification</li>
<li><strong>FnMut closures</strong>: Captured variables can be mutated</li>
</ul>
<h3 id="when-to-use-localhandler"><a class="header" href="#when-to-use-localhandler">When to Use LocalHandler</a></h3>
<p>Use <code>LocalHandler</code> when:</p>
<ul>
<li>Your API uses <code>&amp;mut self</code> methods (common for file/database operations)</li>
<li>You want to avoid <code>Arc&lt;Mutex&lt;_&gt;&gt;</code> wrappers</li>
<li>Your CLI is single-threaded (the typical case)</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout::cli::{LocalApp, LocalHandler, Output, HandlerResult, CommandContext};

struct Database {
    connection: Connection,
    cache: HashMap&lt;String, Record&gt;,
}

impl Database {
    fn query_mut(&amp;mut self, sql: &amp;str) -&gt; Result&lt;Vec&lt;Row&gt;, Error&gt; {
        // Needs &amp;mut self because it updates the cache
        if let Some(cached) = self.cache.get(sql) {
            return Ok(cached.clone());
        }
        let result = self.connection.execute(sql)?;
        self.cache.insert(sql.to_string(), result.clone());
        Ok(result)
    }
}

impl LocalHandler for Database {
    type Output = Vec&lt;Row&gt;;

    fn handle(&amp;mut self, matches: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;Vec&lt;Row&gt;&gt; {
        let query = matches.get_one::&lt;String&gt;("query").unwrap();
        let rows = self.query_mut(query)?;
        Ok(Output::Render(rows))
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="local-closure-handlers"><a class="header" href="#local-closure-handlers">Local Closure Handlers</a></h3>
<p><code>LocalApp::builder().command()</code> accepts <code>FnMut</code> closures:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut db = Database::connect()?;

LocalApp::builder()
    .command("query", |matches, ctx| {
        let sql = matches.get_one::&lt;String&gt;("sql").unwrap();
        let rows = db.query_mut(sql)?;  // &amp;mut db works!
        Ok(Output::Render(rows))
    }, "{{ rows }}")
    .build()?
    .run(cmd, args);
<span class="boring">}</span></code></pre></pre>
<p>This is the primary use case: capturing mutable references in closures without interior mutability wrappers.</p>
<h2 id="handlerresult"><a class="header" href="#handlerresult">HandlerResult</a></h2>
<p><code>HandlerResult&lt;T&gt;</code> is a standard <code>Result</code> type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type HandlerResult&lt;T&gt; = Result&lt;Output&lt;T&gt;, anyhow::Error&gt;;
<span class="boring">}</span></code></pre></pre>
<p>The <code>?</code> operator works naturally for error propagation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn list_handler(matches: &amp;ArgMatches, ctx: &amp;CommandContext) -&gt; HandlerResult&lt;Items&gt; {
    let items = storage::load()?;           // Propagates errors
    let filtered = filter_items(&amp;items)?;   // Propagates errors
    Ok(Output::Render(Items { filtered }))
}
<span class="boring">}</span></code></pre></pre>
<p>Errors become the command output—Standout formats and displays them appropriately.</p>
<h2 id="the-output-enum"><a class="header" href="#the-output-enum">The Output Enum</a></h2>
<p><code>Output&lt;T&gt;</code> represents what a handler produces:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Output&lt;T: Serialize&gt; {
    Render(T),
    Silent,
    Binary { data: Vec&lt;u8&gt;, filename: String },
}
<span class="boring">}</span></code></pre></pre>
<h3 id="outputrendert"><a class="header" href="#outputrendert">Output::Render(T)</a></h3>
<p>The common case. Data is serialized to JSON, passed to the template engine, and rendered with styles:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize)]
struct ListResult {
    items: Vec&lt;Item&gt;,
    total: usize,
}

fn list_handler(_m: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;ListResult&gt; {
    let items = storage::list()?;
    Ok(Output::Render(ListResult {
        total: items.len(),
        items,
    }))
}
<span class="boring">}</span></code></pre></pre>
<p>In structured output modes (<code>--output json</code>), the template is skipped and data serializes directly—same handler code, different output format.</p>
<h3 id="outputsilent"><a class="header" href="#outputsilent">Output::Silent</a></h3>
<p>No output produced. Useful for commands with side effects only:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn delete_handler(matches: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;()&gt; {
    let id: &amp;String = matches.get_one("id").unwrap();
    storage::delete(id)?;
    Ok(Output::Silent)
}
<span class="boring">}</span></code></pre></pre>
<p>Silent behavior in the pipeline:</p>
<ul>
<li>Post-output hooks still receive <code>RenderedOutput::Silent</code> (they can transform it)</li>
<li>If <code>--output-file</code> is set, nothing is written</li>
<li>Nothing prints to stdout</li>
</ul>
<p>The type parameter for <code>Output::Silent</code> is often <code>()</code> but can be any <code>Serialize</code> type—it's never used.</p>
<h3 id="outputbinary"><a class="header" href="#outputbinary">Output::Binary</a></h3>
<p>Raw bytes written to a file. Useful for exports, archives, or generated files:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn export_handler(matches: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;()&gt; {
    let data = generate_report()?;
    let pdf_bytes = render_to_pdf(&amp;data)?;

    Ok(Output::Binary {
        data: pdf_bytes,
        filename: "report.pdf".into(),
    })
}
<span class="boring">}</span></code></pre></pre>
<p>The filename is used as a literal file path. Standout writes the bytes using <code>std::fs::write()</code> and prints a confirmation to stderr. The filename can be:</p>
<ul>
<li>Relative: <code>"output/report.pdf"</code></li>
<li>Absolute: <code>"/tmp/report.pdf"</code></li>
<li>Dynamic: <code>format!("report-{}.pdf", timestamp)</code></li>
</ul>
<p>Binary output bypasses the template engine entirely.</p>
<h2 id="commandcontext"><a class="header" href="#commandcontext">CommandContext</a></h2>
<p><code>CommandContext</code> provides execution environment information:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CommandContext {
    pub output_mode: OutputMode,
    pub command_path: Vec&lt;String&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>output_mode</strong>: The resolved output format (Term, Text, Json, etc.). Handlers can inspect this to adjust behavior—for example, skipping interactive prompts in JSON mode:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn interactive_handler(matches: &amp;ArgMatches, ctx: &amp;CommandContext) -&gt; HandlerResult&lt;Data&gt; {
    let confirmed = if ctx.output_mode.is_structured() {
        true  // Non-interactive in JSON mode
    } else {
        prompt_user("Continue?")?
    };
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p><strong>command_path</strong>: The subcommand chain as a vector, e.g., <code>["db", "migrate"]</code>. Useful for logging or conditional logic.</p>
<p>See <a href="topics/execution-model.html">Execution Model</a> for more on command paths.</p>
<p><code>CommandContext</code> is intentionally minimal. Application-specific context (config, connections) should be captured in struct handlers or closures:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyHandler {
    db: DatabasePool,
    config: AppConfig,
}

impl Handler for MyHandler {
    type Output = Data;

    fn handle(&amp;self, matches: &amp;ArgMatches, ctx: &amp;CommandContext) -&gt; HandlerResult&lt;Data&gt; {
        let result = self.db.query(...)?;
        Ok(Output::Render(result))
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="accessing-cli-arguments"><a class="header" href="#accessing-cli-arguments">Accessing CLI Arguments</a></h2>
<p>The <code>ArgMatches</code> parameter provides access to parsed arguments through clap's standard API:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handler(matches: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;Data&gt; {
    // Flags
    let verbose = matches.get_flag("verbose");

    // Required options
    let name: &amp;String = matches.get_one("name").unwrap();

    // Optional values
    let limit: Option&lt;&amp;u32&gt; = matches.get_one("limit");

    // Multiple values
    let tags: Vec&lt;&amp;String&gt; = matches.get_many("tags")
        .map(|v| v.collect())
        .unwrap_or_default();

    Ok(Output::Render(Data { ... }))
}
<span class="boring">}</span></code></pre></pre>
<p>For subcommands, you receive the <code>ArgMatches</code> for your specific command, not the root. Standout navigates to the deepest match before calling your handler.</p>
<h2 id="the-dispatch-macro"><a class="header" href="#the-dispatch-macro">The #[dispatch] Macro</a></h2>
<p>For applications with many commands, the <code>#[dispatch]</code> attribute macro generates registration from an enum:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Dispatch)]
enum Commands {
    List,
    Add,
    Remove,
}
<span class="boring">}</span></code></pre></pre>
<p>This generates a <code>dispatch_config()</code> method that registers handlers. Variant names are converted to snake_case command names:</p>
<ul>
<li><code>List</code> → <code>"list"</code></li>
<li><code>ListAll</code> → <code>"list_all"</code></li>
</ul>
<p>The macro expects handler functions named after the variant:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn list(_m: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;ListOutput&gt; { ... }
fn add(_m: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;AddOutput&gt; { ... }
fn remove(_m: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;RemoveOutput&gt; { ... }
<span class="boring">}</span></code></pre></pre>
<p>Variant attributes for customization:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Dispatch)]
enum Commands {
    #[dispatch(handler = custom_list_fn)]  // Override handler function
    List,

    #[dispatch(template = "custom/add.j2")]  // Override template path
    Add,

    #[dispatch(pre_dispatch = validate_auth)]  // Add hook
    Remove,

    #[dispatch(skip)]  // Don't register this variant
    Internal,

    #[dispatch(nested)]  // This is a subcommand enum
    Db(DbCommands),
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>nested</code> attribute is required for subcommand enums—it's not inferred from tuple variants.</p>
<h2 id="testing-handlers"><a class="header" href="#testing-handlers">Testing Handlers</a></h2>
<p>Because handlers are pure functions with explicit inputs and outputs, they're straightforward to test:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_list_handler() {
    let cmd = Command::new("test").arg(Arg::new("verbose").long("verbose").action(ArgAction::SetTrue));
    let matches = cmd.try_get_matches_from(["test", "--verbose"]).unwrap();

    let ctx = CommandContext {
        output_mode: OutputMode::Term,
        command_path: vec!["list".into()],
    };

    let result = list_handler(&amp;matches, &amp;ctx);

    assert!(result.is_ok());
    if let Ok(Output::Render(data)) = result {
        assert!(data.verbose);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>No mocking frameworks needed—construct <code>ArgMatches</code> with clap, create a <code>CommandContext</code>, call your handler, assert on the result.</p>
<h3 id="testing-localhandlers"><a class="header" href="#testing-localhandlers">Testing LocalHandlers</a></h3>
<p><code>LocalHandler</code> tests work the same way, but use <code>&amp;mut self</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_local_handler_state_mutation() {
    struct Counter { count: u32 }

    impl LocalHandler for Counter {
        type Output = u32;
        fn handle(&amp;mut self, _m: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;u32&gt; {
            self.count += 1;
            Ok(Output::Render(self.count))
        }
    }

    let mut handler = Counter { count: 0 };
    let cmd = Command::new("test");
    let matches = cmd.try_get_matches_from(["test"]).unwrap();
    let ctx = CommandContext {
        output_mode: OutputMode::Term,
        command_path: vec!["count".into()],
    };

    // State accumulates across calls
    let _ = handler.handle(&amp;matches, &amp;ctx);
    let _ = handler.handle(&amp;matches, &amp;ctx);
    let result = handler.handle(&amp;matches, &amp;ctx);

    assert!(matches!(result, Ok(Output::Render(3))));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="choosing-between-handler-and-localhandler"><a class="header" href="#choosing-between-handler-and-localhandler">Choosing Between Handler and LocalHandler</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Your situation</th><th>Use</th></tr></thead><tbody>
<tr><td>Stateless handlers</td><td><code>App</code> + closures</td></tr>
<tr><td>State with <code>Arc&lt;Mutex&lt;_&gt;&gt;</code> already</td><td><code>App</code> + <code>Handler</code> trait</td></tr>
<tr><td>API with <code>&amp;mut self</code> methods</td><td><code>LocalApp</code> + <code>LocalHandler</code></td></tr>
<tr><td>Building a library</td><td><code>App</code> (consumers might need thread safety)</td></tr>
<tr><td>Simple single-threaded CLI</td><td>Either works; <code>LocalApp</code> avoids wrapper types</td></tr>
</tbody></table>
</div>
<p>The key insight: CLIs are fundamentally single-threaded (parse → run one handler → output → exit). The <code>Send + Sync</code> requirement in <code>Handler</code> is conventional, not strictly necessary. <code>LocalHandler</code> removes this requirement for simpler code when thread safety isn't needed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-rendering-system"><a class="header" href="#the-rendering-system">The Rendering System</a></h1>
<p>Standout's rendering layer separates presentation from logic by using a two-pass architecture. This allows you to use standard tools (MiniJinja) for structure while keeping styling strictly separated and easy to debug.</p>
<p>Instead of mixing ANSI codes into your logic or templates, you define <em>what</em> something is (semantic tags like <code>[error]</code>) and let the theme decide <em>how</em> it looks.</p>
<h2 id="two-pass-rendering"><a class="header" href="#two-pass-rendering">Two-Pass Rendering</a></h2>
<p>Templates are processed in two distinct passes:</p>
<p><strong>Pass 1 - MiniJinja</strong>: Standard template processing. Variables are substituted, control flow executes, filters apply.</p>
<p><strong>Pass 2 - BBParser</strong>: Style tag processing. Bracket-notation tags are converted to ANSI escape codes (or stripped, depending on output mode).</p>
<pre><code class="language-text">Template:     [title]{{ name }}[/title] has {{ count }} items
Data:         { name: "Report", count: 42 }

After Pass 1: [title]Report[/title] has 42 items
After Pass 2: \x1b[1;32mReport\x1b[0m has 42 items
</code></pre>
<p>This separation means:</p>
<ul>
<li>Template logic (loops, conditionals) is handled by MiniJinja—a mature, well-documented engine</li>
<li>Style application is a simple, predictable transformation</li>
<li>You can debug each pass independently</li>
</ul>
<h2 id="style-tags"><a class="header" href="#style-tags">Style Tags</a></h2>
<p>Style tags use BBCode-like bracket notation:</p>
<pre><code class="language-text">[style-name]content to style[/style-name]
</code></pre>
<p>The style-name must match a style defined in the theme. Tags can:</p>
<ul>
<li>Nest: <code>[outer][inner]text[/inner][/outer]</code></li>
<li>Span multiple lines</li>
<li>Contain template logic: <code>[title]{% if x %}{{ x }}{% endif %}[/title]</code></li>
</ul>
<p>The tag syntax was chosen over Jinja filters because it reads naturally and doesn't interfere with Jinja's own syntax.</p>
<h3 id="what-happens-based-on-outputmode"><a class="header" href="#what-happens-based-on-outputmode">What Happens Based on OutputMode</a></h3>
<ul>
<li><strong>Term</strong>: Tags replaced with ANSI escape codes</li>
<li><strong>Text</strong>: Tags stripped, plain text remains</li>
<li><strong>TermDebug</strong>: Tags kept as literals (<code>[name]...[/name]</code>) for debugging</li>
<li><strong>Structured</strong> (JSON, etc.): Template not used—data serializes directly</li>
</ul>
<h3 id="unknown-style-tags"><a class="header" href="#unknown-style-tags">Unknown Style Tags</a></h3>
<p>When a tag references a style not in the theme, Standout prioritizes developer visibility without crashing production apps.</p>
<ul>
<li>
<p><strong>Term mode</strong>: Unknown tags get a <code>?</code> marker: <code>[unknown?]text[/unknown?]</code></p>
</li>
<li>
<p><strong>Text mode</strong>: Tags stripped like any other</p>
</li>
<li>
<p><strong>TermDebug mode</strong>: Tags preserved as-is</p>
</li>
</ul>
<p>The <code>?</code> marker helps catch typos during development. For production, use <code>validate_template()</code> at startup:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = validate_template(template, &amp;sample_data, &amp;theme);
if let Err(e) = result {
    eprintln!("Template errors: {}", e);
    std::process::exit(1);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="themes-and-styles"><a class="header" href="#themes-and-styles">Themes and Styles</a></h2>
<p>A <code>Theme</code> is a named collection of styles mapping style names to console formatting.</p>
<p>See <a href="topics/app-configuration.html">App Configuration</a> for how to embed and load themes.</p>
<h3 id="programmatic-themes"><a class="header" href="#programmatic-themes">Programmatic Themes</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let theme = Theme::new()
    .add("title", Style::new().bold().cyan())
    .add("muted", Style::new().dim())
    .add("error", Style::new().red().bold())
    .add("disabled", "muted");  // Alias
<span class="boring">}</span></code></pre></pre>
<h3 id="yaml-stylesheets"><a class="header" href="#yaml-stylesheets">YAML Stylesheets</a></h3>
<p>For file-based configuration:</p>
<pre><code class="language-yaml"># Full attribute form
header:
  fg: cyan
  bold: true

# Shorthand (space or comma separated)
accent: cyan
emphasis: bold
warning: "yellow bold"
error: bold, red, italic

# Alias (references another style)
disabled: muted

# Adaptive (different in light/dark mode)
panel:
  fg: gray
  bold: true
  light:
    fg: black
  dark:
    fg: white
</code></pre>
<h3 id="css-stylesheets"><a class="header" href="#css-stylesheets">CSS Stylesheets</a></h3>
<p>If you prefer standard CSS syntax over YAML, Standout supports a subset of CSS Level 3 tailored for terminals:</p>
<pre><code class="language-css">/* Selectors map to style names */
.panel {
  color: gray;
  font-weight: bold;
}

/* Shortcuts work as expected */
.error { color: red; font-weight: bold; }

/* Adaptive styles via media queries */
@media (prefers-color-scheme: light) {
  .panel { color: black; }
}

@media (prefers-color-scheme: dark) {
  .panel { color: white; }
}
</code></pre>
<p>This is ideal for developers who want to leverage existing knowledge and tooling (syntax highlighting, linters) for their CLI themes.</p>
<h3 id="supported-attributes"><a class="header" href="#supported-attributes">Supported Attributes</a></h3>
<p>Colors: <code>fg</code>, <code>bg</code></p>
<p>Text attributes: <code>bold</code>, <code>dim</code>, <code>italic</code>, <code>underline</code>, <code>blink</code>, <code>reverse</code>, <code>hidden</code>, <code>strikethrough</code></p>
<h3 id="color-formats"><a class="header" href="#color-formats">Color Formats</a></h3>
<pre><code class="language-yaml">fg: red                  # Named (16 ANSI colors)
fg: bright_green         # Bright variants
fg: 208                  # 256-color palette
fg: "#ff6b35"            # RGB hex
fg: [255, 107, 53]       # RGB array
</code></pre>
<h3 id="style-aliasing"><a class="header" href="#style-aliasing">Style Aliasing</a></h3>
<p>Aliases let semantic names in templates resolve to visual styles:</p>
<pre><code class="language-yaml">title:
  fg: cyan
  bold: true
commit-message: title    # Alias
section-header: title    # Another alias
</code></pre>
<p>Benefits:</p>
<ul>
<li>Templates use meaningful names (<code>[commit-message]</code>)</li>
<li>Change one definition, update all aliases</li>
<li>Styling stays flexible without template changes</li>
</ul>
<p>Aliases can chain (<code>a</code> → <code>b</code> → <code>c</code> → concrete style). Cycles are detected and rejected.</p>
<h3 id="adaptive-styles"><a class="header" href="#adaptive-styles">Adaptive Styles</a></h3>
<p>Themes can respond to the OS light/dark mode:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>theme.add_adaptive(
    "panel",
    Style::new().bold(),                    // base (shared)
    Some(Style::new().fg(Color::Black)),    // light mode override
    Some(Style::new().fg(Color::White)),    // dark mode override
)
<span class="boring">}</span></code></pre></pre>
<p>In YAML:</p>
<pre><code class="language-yaml">panel:
  bold: true
  light:
    fg: black
  dark:
    fg: white
</code></pre>
<p>The base provides shared attributes. Mode-specific overrides merge with base—<code>Some</code> replaces, <code>None</code> preserves.</p>
<p>Standout auto-detects the OS color scheme. Override for testing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>set_theme_detector(|| ColorMode::Dark);
<span class="boring">}</span></code></pre></pre>
<h2 id="template-filters"><a class="header" href="#template-filters">Template Filters</a></h2>
<p>Beyond MiniJinja's built-ins, Standout adds formatting filters:</p>
<h3 id="column-formatting"><a class="header" href="#column-formatting">Column Formatting</a></h3>
<pre><code class="language-jinja">{{ value | col(10) }}
{{ value | col(20, align='right') }}
{{ value | col(15, truncate='middle', ellipsis='...') }}
</code></pre>
<p>Arguments: <code>width</code>, <code>align</code> (left/right/center), <code>truncate</code> (end/start/middle), <code>ellipsis</code></p>
<h3 id="padding"><a class="header" href="#padding">Padding</a></h3>
<pre><code class="language-jinja">{{ "42" | pad_left(8) }}     {# "      42" #}
{{ "hi" | pad_right(8) }}    {# "hi      " #}
{{ "hi" | pad_center(8) }}   {# "   hi   " #}
</code></pre>
<h3 id="truncation"><a class="header" href="#truncation">Truncation</a></h3>
<pre><code class="language-jinja">{{ long_text | truncate_at(20) }}
{{ path | truncate_at(30, 'middle', '...') }}
</code></pre>
<h3 id="display-width"><a class="header" href="#display-width">Display Width</a></h3>
<pre><code class="language-jinja">{% if value | display_width &gt; 20 %}...{% endif %}
</code></pre>
<p>Returns visual width (handles Unicode—CJK characters count as 2).</p>
<h2 id="context-injection"><a class="header" href="#context-injection">Context Injection</a></h2>
<p>Context injection adds values to the template beyond handler data.</p>
<h3 id="static-context"><a class="header" href="#static-context">Static Context</a></h3>
<p>Fixed values set at configuration time:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::builder()
    .context("version", "1.0.0")
    .context("app_name", "MyApp")
<span class="boring">}</span></code></pre></pre>
<h3 id="dynamic-context"><a class="header" href="#dynamic-context">Dynamic Context</a></h3>
<p>Computed at render time:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::builder()
    .context_fn("terminal_width", |ctx| {
        Value::from(ctx.terminal_width.unwrap_or(80))
    })
    .context_fn("is_color", |ctx| {
        Value::from(ctx.output_mode.should_use_color())
    })
<span class="boring">}</span></code></pre></pre>
<p>In templates:</p>
<pre><code class="language-jinja">{{ app_name }} v{{ version }}
{% if terminal_width &gt; 100 %}...{% endif %}
</code></pre>
<p>When handler data and context have the same key, <strong>handler data wins</strong>. Context is supplementary, not an override mechanism.</p>
<h2 id="structured-output-modes"><a class="header" href="#structured-output-modes">Structured Output Modes</a></h2>
<p>Structured modes (Json, Yaml, Xml, Csv) bypass template rendering entirely:</p>
<pre><code class="language-text">OutputMode::Json  → serde_json::to_string_pretty(data)
OutputMode::Yaml  → serde_yaml::to_string(data)
OutputMode::Xml   → quick_xml::se::to_string(data)
OutputMode::Csv   → flatten and format as CSV
</code></pre>
<p>This means:</p>
<ul>
<li>Template content is ignored</li>
<li>Style tags never apply</li>
<li>Context injection is skipped</li>
<li>What you serialize is what you get</li>
</ul>
<p>Same handler code, same data types—just different output format based on <code>--output</code>.</p>
<h2 id="render-functions"><a class="header" href="#render-functions">Render Functions</a></h2>
<p>For using the rendering layer without CLI integration:</p>
<h3 id="basic-rendering"><a class="header" href="#basic-rendering">Basic Rendering</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout::{render, Theme};

let theme = Theme::new().add("ok", Style::new().green());

let output = render(
    "[ok]{{ message }}[/ok]",
    &amp;Data { message: "Success".into() },
    &amp;theme,
)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="with-output-mode"><a class="header" href="#with-output-mode">With Output Mode</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout::{render_with_output, OutputMode};

// Honor --output flag value
let output = render_with_output(template, &amp;data, &amp;theme, OutputMode::Text)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="with-extra-variables"><a class="header" href="#with-extra-variables">With Extra Variables</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout::{render_with_vars, OutputMode};
use std::collections::HashMap;

// Inject simple key-value pairs into the template context
let mut vars = HashMap::new();
vars.insert("version", "1.0.0");

let output = render_with_vars(
    "{{ name }} v{{ version }}",
    &amp;data, &amp;theme, OutputMode::Text, vars,
)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="auto-dispatch-template-vs-serialize"><a class="header" href="#auto-dispatch-template-vs-serialize">Auto-Dispatch (Template vs Serialize)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout::render_auto;

// For Term/Text: renders template
// For Json/Yaml/etc: serializes data directly
let output = render_auto(template, &amp;data, &amp;theme, OutputMode::Json)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="full-control"><a class="header" href="#full-control">Full Control</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout::{render_with_mode, ColorMode};

// Explicit output mode AND color mode (for tests)
let output = render_with_mode(
    template, &amp;data, &amp;theme,
    OutputMode::Term,
    ColorMode::Dark,
)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="rendering-prelude"><a class="header" href="#rendering-prelude">Rendering Prelude</a></h2>
<p>For convenient imports when using the rendering layer standalone:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout::rendering::prelude::*;

let theme = Theme::new()
    .add("title", Style::new().bold());

let output = render("[title]{{ name }}[/title]", &amp;data, &amp;theme)?;
<span class="boring">}</span></code></pre></pre>
<p>The prelude includes: <code>render</code>, <code>render_auto</code>, <code>render_with_output</code>, <code>render_with_mode</code>, <code>render_with_vars</code>, <code>Theme</code>, <code>ColorMode</code>, <code>OutputMode</code>, <code>Renderer</code>, and <code>Style</code>.</p>
<h2 id="hot-reloading"><a class="header" href="#hot-reloading">Hot Reloading</a></h2>
<p>In debug builds, file-based templates are re-read from disk on each render. Edit templates without recompiling.</p>
<p>In release builds, templates are cached after first load.</p>
<p>This is automatic—no configuration needed. The <code>Renderer</code> struct tracks which templates are inline vs file-based and handles them appropriately.</p>
<h2 id="template-registry"><a class="header" href="#template-registry">Template Registry</a></h2>
<p>Templates are resolved by name with priority:</p>
<ol>
<li><strong>Inline templates</strong> (added via <code>add_template()</code>)</li>
<li><strong>Embedded templates</strong> (from <code>embed_templates!</code>)</li>
<li><strong>File templates</strong> (from <code>.templates_dir()</code>)</li>
</ol>
<p>Supported extensions (in priority order): <code>.jinja</code>, <code>.jinja2</code>, <code>.j2</code>, <code>.txt</code></p>
<p>When you request <code>"config"</code>, the registry checks:</p>
<ul>
<li>Inline template named <code>"config"</code></li>
<li><code>config.jinja</code> in registered directories</li>
<li><code>config.jinja2</code>, <code>config.j2</code>, <code>config.txt</code> (lower priority)</li>
</ul>
<p>Cross-directory collisions (same name in multiple dirs) raise an error. Same-directory collisions use extension priority.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="output-modes-2"><a class="header" href="#output-modes-2">Output Modes</a></h1>
<p>Standout supports multiple output formats through a single handler because modern CLI tools serve two masters: human operators and machine automation.</p>
<p>The same handler logic produces styled terminal output for eyes, plain text for logs, or structured JSON for <code>jq</code> pipelines—controlled entirely by the user's <code>--output</code> flag. This frees you from writing separate "API" and "CLI" logic.</p>
<h2 id="the-outputmode-enum"><a class="header" href="#the-outputmode-enum">The OutputMode Enum</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum OutputMode {
    Auto,       // Auto-detect terminal capabilities
    Term,       // Always use ANSI escape codes
    Text,       // Never use ANSI codes (plain text)
    TermDebug,  // Keep style tags as [name]...[/name]
    Json,       // Serialize as JSON (skip template)
    Yaml,       // Serialize as YAML (skip template)
    Xml,        // Serialize as XML (skip template)
    Csv,        // Serialize as CSV (skip template)
}
<span class="boring">}</span></code></pre></pre>
<p>Three categories:</p>
<p><strong>Templated modes</strong> (Auto, Term, Text): Render the template, vary ANSI handling.</p>
<p><strong>Debug mode</strong> (TermDebug): Render the template, keep tags as literals for inspection.</p>
<p><strong>Structured modes</strong> (Json, Yaml, Xml, Csv): Skip the template entirely, serialize handler data directly.</p>
<h2 id="auto-mode"><a class="header" href="#auto-mode">Auto Mode</a></h2>
<p><code>Auto</code> is the default. It queries the terminal for color support:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Term::stdout().features().colors_supported()
<span class="boring">}</span></code></pre></pre>
<p>If colors are supported, Auto behaves like Term (ANSI codes applied). If not, Auto behaves like Text (tags stripped).</p>
<p>This detection happens at render time, not startup. Piping output to a file or another process typically disables color support, so:</p>
<pre><code class="language-bash">myapp list              # Colors (if terminal supports)
myapp list &gt; file.txt   # No colors (not a TTY)
myapp list | less       # No colors (pipe)
</code></pre>
<h2 id="the---output-flag"><a class="header" href="#the---output-flag">The --output Flag</a></h2>
<p>Standout adds a global <code>--output</code> flag accepting these values:</p>
<pre><code class="language-bash">myapp list --output=auto        # Default
myapp list --output=term        # Force ANSI codes
myapp list --output=text        # Force plain text
myapp list --output=term-debug  # Show style tags
myapp list --output=json        # JSON serialization
myapp list --output=yaml        # YAML serialization
myapp list --output=xml         # XML serialization
myapp list --output=csv         # CSV serialization
</code></pre>
<p>The flag is global—it applies to all subcommands.</p>
<h2 id="term-vs-text"><a class="header" href="#term-vs-text">Term vs Text</a></h2>
<p><strong>Term</strong>: Always applies ANSI escape codes, even when piping:</p>
<pre><code class="language-bash">myapp list --output=term &gt; colored.txt
</code></pre>
<p>Useful when you want to preserve colors for later display (e.g., <code>less -R</code>).</p>
<p><strong>Text</strong>: Never applies ANSI codes:</p>
<pre><code class="language-bash">myapp list --output=text
</code></pre>
<p>Useful for clean output regardless of terminal capabilities, or when processing output with other tools.</p>
<h2 id="termdebug-mode"><a class="header" href="#termdebug-mode">TermDebug Mode</a></h2>
<p>TermDebug preserves style tags instead of converting them:</p>
<pre><code class="language-text">Template: [title]Hello[/title]
Output:   [title]Hello[/title]
</code></pre>
<p>Use cases:</p>
<ul>
<li>Debugging template issues</li>
<li>Verifying style tag placement</li>
<li>Automated testing of template output</li>
</ul>
<p>Unlike Term mode, unknown tags don't get the <code>?</code> marker in TermDebug.</p>
<h2 id="structured-modes"><a class="header" href="#structured-modes">Structured Modes</a></h2>
<p>Structured modes bypass the template entirely. Handler data is serialized directly:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize)]
struct ListOutput {
    items: Vec&lt;Item&gt;,
    total: usize,
}

fn list_handler(...) -&gt; HandlerResult&lt;ListOutput&gt; {
    Ok(Output::Render(ListOutput { items, total: items.len() }))
}
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-bash">myapp list --output=json
</code></pre>
<pre><code class="language-json">{
  "items": [...],
  "total": 42
}
</code></pre>
<p>Same handler, same types—different output format. This enables:</p>
<ul>
<li>Machine-readable output for scripts</li>
<li>Integration with other tools (<code>jq</code>, etc.)</li>
<li>API-like behavior from CLI apps</li>
</ul>
<h3 id="csv-output"><a class="header" href="#csv-output">CSV Output</a></h3>
<p>CSV mode flattens nested JSON automatically. For more control, use <code>FlatDataSpec</code>.</p>
<p>See <a href="topics/tabular.html">Tabular Layout</a> for detailed CSV configuration.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let spec = FlatDataSpec::builder()
    .column(Column::new(Width::Fixed(10)).key("name").header("Name"))
    .column(Column::new(Width::Fixed(10)).key("meta.role").header("Role"))
    .build();

render_auto_with_spec(template, &amp;data, &amp;theme, OutputMode::Csv, Some(&amp;spec))?
<span class="boring">}</span></code></pre></pre>
<p>The <code>key</code> field uses dot notation for nested paths (<code>"meta.role"</code> extracts <code>data["meta"]["role"]</code>).</p>
<h2 id="file-output"><a class="header" href="#file-output">File Output</a></h2>
<p>The <code>--output-file-path</code> flag redirects output to a file:</p>
<pre><code class="language-bash">myapp list --output-file-path=results.txt
myapp list --output=json --output-file-path=data.json
</code></pre>
<p>Behavior:</p>
<ul>
<li>Text output: written to file, nothing printed to stdout</li>
<li>Binary output: written to file (same as without flag)</li>
<li>Silent output: no-op</li>
</ul>
<p>After writing to file, stdout output is suppressed to prevent double-printing.</p>
<h2 id="customizing-flags"><a class="header" href="#customizing-flags">Customizing Flags</a></h2>
<p>Rename or disable the flags via <code>AppBuilder</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::builder()
    .output_flag(Some("format"))       // --format instead of --output
    .output_file_flag(Some("out"))     // --out instead of --output-file-path
    .build()?
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::builder()
    .no_output_flag()                  // Disable --output entirely
    .no_output_file_flag()             // Disable file output
    .build()?
<span class="boring">}</span></code></pre></pre>
<h2 id="accessing-outputmode-in-handlers"><a class="header" href="#accessing-outputmode-in-handlers">Accessing OutputMode in Handlers</a></h2>
<p><code>CommandContext</code> carries the resolved output mode:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handler(matches: &amp;ArgMatches, ctx: &amp;CommandContext) -&gt; HandlerResult&lt;Data&gt; {
    if ctx.output_mode.is_structured() {
        // Skip interactive prompts in JSON mode
    }

    if ctx.output_mode == OutputMode::Csv {
        // Maybe adjust data structure for flat output
    }

    Ok(Output::Render(data))
}
<span class="boring">}</span></code></pre></pre>
<p>Helper methods:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ctx.output_mode.should_use_color()  // True for Term, depends on terminal for Auto
ctx.output_mode.is_structured()     // True for Json, Yaml, Xml, Csv
ctx.output_mode.is_debug()          // True for TermDebug
<span class="boring">}</span></code></pre></pre>
<h2 id="rendering-without-cli"><a class="header" href="#rendering-without-cli">Rendering Without CLI</a></h2>
<p>For standalone rendering with explicit mode:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout::{render_auto, OutputMode};

// Renders template for Term/Text, serializes for Json/Yaml
let output = render_auto(template, &amp;data, &amp;theme, OutputMode::Json)?;
<span class="boring">}</span></code></pre></pre>
<p>The "auto" in <code>render_auto</code> refers to template-vs-serialize dispatch, not color detection.</p>
<p>For full control over both output mode and color mode:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout::{render_with_mode, ColorMode};

let output = render_with_mode(
    template,
    &amp;data,
    &amp;theme,
    OutputMode::Term,
    ColorMode::Dark,
)?;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tabular-layout-2"><a class="header" href="#tabular-layout-2">Tabular Layout</a></h1>
<p>Standout helps you create aligned, readable output for lists, logs, and tabular data.</p>
<p><strong>Choose your path:</strong></p>
<ul>
<li><a href="topics/tabular.html#quick-start-the-col-filter">Quick Start</a>: Simple alignment with template filters</li>
<li><a href="topics/tabular.html#structured-layout">Structured Layout</a>: Multi-column specs for complex output</li>
<li><a href="topics/tabular.html#tables-headers-and-borders">Full Tables</a>: Headers, borders, and separators</li>
</ul>
<h2 id="quick-start-the-col-filter"><a class="header" href="#quick-start-the-col-filter">Quick Start: The <code>col</code> Filter</a></h2>
<p>For simple alignment, use the <code>col</code> filter directly in templates:</p>
<pre><code class="language-jinja">{% for entry in entries %}
{{ entry.id | col(8) }}  {{ entry.name | col(20) }}  {{ entry.status | col(10) }}
{% endfor %}
</code></pre>
<p>Output:</p>
<pre><code class="language-text">abc123    Alice Johnson         active
def456    Bob Smith             pending
ghi789    Carol Williams        done
</code></pre>
<p>The <code>col</code> filter:</p>
<ul>
<li>Pads short values to the specified width</li>
<li>Truncates long values with <code>…</code></li>
<li>Handles Unicode correctly (CJK characters count as 2 columns)</li>
</ul>
<h3 id="alignment"><a class="header" href="#alignment">Alignment</a></h3>
<pre><code class="language-jinja">{{ value | col(10) }}                 {# Left-aligned (default) #}
{{ value | col(10, align="right") }}  {# Right-aligned #}
{{ value | col(10, align="center") }} {# Centered #}
</code></pre>
<pre><code class="language-text">left......
....right.
..center..
</code></pre>
<h3 id="truncation-position"><a class="header" href="#truncation-position">Truncation Position</a></h3>
<p>When content is too long, choose where to cut:</p>
<pre><code class="language-jinja">{{ path | col(15) }}                        {# "Very long pa…" (default: end) #}
{{ path | col(15, truncate="start") }}      {# "…ng/path/file" #}
{{ path | col(15, truncate="middle") }}     {# "Very l…h/file" #}
</code></pre>
<p>Truncate <code>middle</code> is useful for paths where both start and end matter.</p>
<h3 id="custom-ellipsis"><a class="header" href="#custom-ellipsis">Custom Ellipsis</a></h3>
<pre><code class="language-jinja">{{ value | col(10, ellipsis="...") }}   {# "Hello W..." instead of "Hello W…" #}
{{ value | col(10, ellipsis="→") }}     {# "Hello Wor→" #}
</code></pre>
<hr />
<h2 id="structured-layout"><a class="header" href="#structured-layout">Structured Layout</a></h2>
<p>When you need consistent column widths across complex output, define a layout spec.</p>
<h3 id="defining-columns-in-templates"><a class="header" href="#defining-columns-in-templates">Defining Columns in Templates</a></h3>
<p>Use the <code>tabular()</code> function to create a formatter:</p>
<pre><code class="language-jinja">{% set t = tabular([
    {"name": "id", "width": 8},
    {"name": "author", "width": 20},
    {"name": "message", "width": "fill"},
    {"name": "date", "width": 10, "align": "right"}
]) %}

{% for commit in commits %}
{{ t.row([commit.id, commit.author, commit.message, commit.date]) }}
{% endfor %}
</code></pre>
<p>Output:</p>
<pre><code class="language-text">a1b2c3d4  Alice Johnson         Add new login feature             2024-01-15
e5f6g7h8  Bob Smith             Fix authentication bug            2024-01-14
i9j0k1l2  Carol Williams        Update dependencies               2024-01-13
</code></pre>
<h3 id="width-options"><a class="header" href="#width-options">Width Options</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Width</th><th>Meaning</th><th>Example</th></tr></thead><tbody>
<tr><td><code>8</code></td><td>Exactly 8 columns</td><td>IDs, short codes</td></tr>
<tr><td><code>{"min": 10}</code></td><td>At least 10, grows to fit</td><td>Names, titles</td></tr>
<tr><td><code>{"min": 10, "max": 30}</code></td><td>Between 10 and 30</td><td>Bounded growth</td></tr>
<tr><td><code>"fill"</code></td><td>Takes remaining space</td><td>Descriptions</td></tr>
<tr><td><code>"2fr"</code></td><td>2 parts of remaining (vs 1fr)</td><td>Proportional</td></tr>
</tbody></table>
</div>
<pre><code class="language-jinja">{% set t = tabular([
    {"name": "id", "width": 8},                    {# Fixed #}
    {"name": "name", "width": {"min": 10}},        {# Grows to fit #}
    {"name": "desc", "width": "fill"},             {# Takes the rest #}
]) %}
</code></pre>
<h3 id="anchoring-columns"><a class="header" href="#anchoring-columns">Anchoring Columns</a></h3>
<p>Put columns at the right edge:</p>
<pre><code class="language-jinja">{% set t = tabular([
    {"name": "name", "width": 20},
    {"name": "path", "width": "fill"},
    {"name": "size", "width": 8, "anchor": "right"},  {# Stays at right edge #}
]) %}
</code></pre>
<p>Output:</p>
<pre><code class="language-text">document.txt          /home/user/docs/                    1.2 MB
image.png             /home/user/photos/vacation/         4.5 MB
</code></pre>
<p>The <code>size</code> column is anchored to the right edge. The <code>path</code> column fills the gap.</p>
<h3 id="handling-long-content"><a class="header" href="#handling-long-content">Handling Long Content</a></h3>
<p>Choose what happens when content exceeds the column width:</p>
<pre><code class="language-jinja">{% set t = tabular([
    {"name": "path", "width": 30, "overflow": "truncate"},  {# Default: "Very long…" #}
    {"name": "desc", "width": 30, "overflow": "wrap"},      {# Wrap to multiple lines #}
]) %}
</code></pre>
<h4 id="truncate-default"><a class="header" href="#truncate-default">Truncate (default)</a></h4>
<pre><code class="language-jinja">{"overflow": "truncate"}                      {# Truncate at end #}
{"overflow": {"truncate": {"at": "middle"}}}  {# Keep start and end #}
{"overflow": {"truncate": {"marker": "..."}}} {# Custom ellipsis #}
</code></pre>
<h4 id="wrap"><a class="header" href="#wrap">Wrap</a></h4>
<p>Content wraps to multiple lines:</p>
<pre><code class="language-text">abc123  This is a very long       active
        description that wraps
        to multiple lines
def456  Short description         done
</code></pre>
<pre><code class="language-jinja">{"name": "desc", "width": 25, "overflow": "wrap"}
{"name": "desc", "width": 25, "overflow": {"wrap": {"indent": 2}}}  {# Continuation indent #}
</code></pre>
<h3 id="extracting-fields-from-objects"><a class="header" href="#extracting-fields-from-objects">Extracting Fields from Objects</a></h3>
<p>When column names match struct fields, use <code>row_from()</code>:</p>
<pre><code class="language-jinja">{% set t = tabular([
    {"name": "id", "width": 8},
    {"name": "title", "width": 30},
    {"name": "status", "width": 10}
]) %}

{% for item in items %}
{{ t.row_from(item) }}  {# Automatically extracts item.id, item.title, item.status #}
{% endfor %}
</code></pre>
<p>For nested fields, use <code>key</code>:</p>
<pre><code class="language-jinja">{% set t = tabular([
    {"name": "Author", "key": "author.name", "width": 20},
    {"name": "Email", "key": "author.email", "width": 30}
]) %}
</code></pre>
<h3 id="column-styles"><a class="header" href="#column-styles">Column Styles</a></h3>
<p>Apply styles to entire columns:</p>
<pre><code class="language-jinja">{% set t = tabular([
    {"name": "id", "width": 8, "style": "muted"},
    {"name": "name", "width": 20, "style": "bold"},
    {"name": "status", "width": 10}  {# No automatic style #}
]) %}
</code></pre>
<p>The <code>style</code> value wraps content in style tags: <code>[muted]abc123[/muted]</code></p>
<p>For dynamic styles (style based on value):</p>
<pre><code class="language-jinja">{% for item in items %}
{{ t.row([item.id, item.name, item.status | style_as(item.status)]) }}
{% endfor %}
</code></pre>
<p>This applies <code>[pending]pending[/pending]</code> or <code>[done]done[/done]</code> based on the actual status value.</p>
<hr />
<h2 id="defining-layout-in-rust"><a class="header" href="#defining-layout-in-rust">Defining Layout in Rust</a></h2>
<p>For reusable layouts or when you need full control:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout::tabular::{TabularSpec, Col};

let spec = TabularSpec::builder()
    .column(Col::fixed(8).named("id"))
    .column(Col::min(10).named("name").style("author"))
    .column(Col::fill().named("description").wrap())
    .column(Col::fixed(10).named("status").anchor_right().right())
    .separator("  ")
    .build();
<span class="boring">}</span></code></pre></pre>
<p>Pass to template context:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let formatter = TabularFormatter::new(&amp;spec, 80);
ctx.insert("table", formatter);
<span class="boring">}</span></code></pre></pre>
<h3 id="shorthand-column-constructors"><a class="header" href="#shorthand-column-constructors">Shorthand Column Constructors</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Col::fixed(8)          // Exactly 8 columns
Col::min(10)           // At least 10, grows to fit
Col::bounded(10, 30)   // Between 10 and 30
Col::fill()            // Takes remaining space
Col::fraction(2)       // 2 parts of remaining (2fr)

// Chained modifiers
Col::fixed(10)
    .named("status")       // Column name
    .right()               // Align right
    .center()              // Align center
    .anchor_right()        // Position at right edge
    .wrap()                // Overflow: wrap
    .clip()                // Overflow: hard cut
    .truncate_middle()     // Truncate in middle
    .style("pending")      // Apply style
    .null_repr("N/A")      // Display for missing values
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="tables-headers-and-borders"><a class="header" href="#tables-headers-and-borders">Tables: Headers and Borders</a></h2>
<p>For output with explicit headers, separators, and borders:</p>
<pre><code class="language-jinja">{% set t = table([
    {"name": "ID", "key": "id", "width": 8},
    {"name": "Author", "key": "author", "width": 20},
    {"name": "Message", "key": "message", "width": "fill"}
], border="rounded", header_style="bold") %}

{{ t.header_row() }}
{{ t.separator_row() }}
{% for commit in commits %}
{{ t.row([commit.id, commit.author, commit.message]) }}
{% endfor %}
{{ t.bottom_border() }}
</code></pre>
<p>Output:</p>
<pre><code class="language-text">╭──────────┬──────────────────────┬────────────────────────────────╮
│ ID       │ Author               │ Message                        │
├──────────┼──────────────────────┼────────────────────────────────┤
│ a1b2c3d4 │ Alice Johnson        │ Add new login feature          │
│ e5f6g7h8 │ Bob Smith            │ Fix authentication bug         │
│ i9j0k1l2 │ Carol Williams       │ Update dependencies            │
╰──────────┴──────────────────────┴────────────────────────────────╯
</code></pre>
<h3 id="table-border-styles"><a class="header" href="#table-border-styles">Table Border Styles</a></h3>
<pre><code class="language-jinja">border="none"     {# No borders #}
border="ascii"    {# +--+--+  ASCII compatible #}
border="light"    {# ┌──┬──┐  Light box drawing #}
border="heavy"    {# ┏━━┳━━┓  Heavy box drawing #}
border="double"   {# ╔══╦══╗  Double lines #}
border="rounded"  {# ╭──┬──╮  Rounded corners #}
</code></pre>
<h3 id="row-separators-1"><a class="header" href="#row-separators-1">Row Separators</a></h3>
<p>Add lines between data rows:</p>
<pre><code class="language-jinja">{% set t = table(columns, border="light", row_separator=true) %}
</code></pre>
<pre><code class="language-text">┌──────────┬──────────────────────┐
│ ID       │ Name                 │
├──────────┼──────────────────────┤
│ abc123   │ Alice                │
├──────────┼──────────────────────┤
│ def456   │ Bob                  │
└──────────┴──────────────────────┘
</code></pre>
<h3 id="simple-table-rendering"><a class="header" href="#simple-table-rendering">Simple Table Rendering</a></h3>
<p>For simple cases, render everything in one call using <code>render_all()</code>:</p>
<pre><code class="language-jinja">{% set t = table([
    {"width": 8, "header": "ID"},
    {"width": 20, "header": "Author"}
], border="light", header=["ID", "Author"]) %}
{{ t.render_all(commits) }}
</code></pre>
<hr />
<h2 id="in-rust-full-table-api"><a class="header" href="#in-rust-full-table-api">In Rust: Full Table API</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout::tabular::{Table, TabularSpec, Col, BorderStyle};

let spec = TabularSpec::builder()
    .column(Col::fixed(8).header("ID"))
    .column(Col::min(10).header("Author"))
    .column(Col::fill().named("Message"))
    .build();

let table = Table::new(spec, 80)
    .header_from_columns()        // Use column headers/names as headers
    .header_style("table-header")
    .border(BorderStyle::Rounded);

// Render full table
let data = vec![
    vec!["a1b2c3d4", "Alice", "Add login"],
    vec!["e5f6g7h8", "Bob", "Fix bug"],
];
let output = table.render(&amp;data);
println!("{}", output);

// Or render parts manually
println!("{}", table.header_row());
println!("{}", table.separator_row());
for row in &amp;data {
    println!("{}", table.row(row));
}
println!("{}", table.bottom_border());
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="terminal-width"><a class="header" href="#terminal-width">Terminal Width</a></h2>
<p>By default, Standout auto-detects terminal width. Override for testing or fixed-width output:</p>
<pre><code class="language-jinja">{% set t = tabular(columns, width=80) %}  {# Fixed 80 columns #}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let formatter = TabularFormatter::new(&amp;spec, 80);  // Fixed width
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="helper-filters"><a class="header" href="#helper-filters">Helper Filters</a></h2>
<p>For simpler use cases, these filters work standalone:</p>
<h3 id="padding-1"><a class="header" href="#padding-1">Padding</a></h3>
<pre><code class="language-jinja">{{ value | pad_right(10) }}   {# "hello     " - left align #}
{{ value | pad_left(10) }}    {# "     hello" - right align #}
{{ value | pad_center(10) }}  {# "  hello   " - center #}
</code></pre>
<h3 id="truncation-1"><a class="header" href="#truncation-1">Truncation</a></h3>
<pre><code class="language-jinja">{{ path | truncate_at(20) }}                  {# End: "/very/long/path…" #}
{{ path | truncate_at(20, "middle") }}        {# Middle: "/very…/file" #}
{{ path | truncate_at(20, "start") }}         {# Start: "…long/path/file" #}
{{ path | truncate_at(20, "end", "...") }}    {# Custom marker #}
</code></pre>
<h3 id="display-width-1"><a class="header" href="#display-width-1">Display Width</a></h3>
<p>Check visual width (handles Unicode):</p>
<pre><code class="language-jinja">{% if name | display_width &gt; 20 %}
  {{ name | truncate_at(20) }}
{% else %}
  {{ name }}
{% endif %}
</code></pre>
<hr />
<h2 id="unicode-and-ansi"><a class="header" href="#unicode-and-ansi">Unicode and ANSI</a></h2>
<p>The tabular system correctly handles:</p>
<ul>
<li><strong>CJK characters</strong>: 日本語 counts as 6 columns (2 each)</li>
<li><strong>Combining marks</strong>: café is 4 columns (é combines)</li>
<li><strong>ANSI codes</strong>: Preserved in output, not counted in width</li>
</ul>
<pre><code class="language-jinja">{{ "Hello 日本" | col(12) }}  →  "Hello 日本  " (10 display columns + 2 padding)
</code></pre>
<p>Styled text maintains styles through truncation:</p>
<pre><code class="language-jinja">{{ "[red]very long red text[/red]" | col(10) }}  →  "[red]very lon…[/red]"
</code></pre>
<hr />
<h2 id="missing-values"><a class="header" href="#missing-values">Missing Values</a></h2>
<p>Set what displays for null/empty values:</p>
<pre><code class="language-jinja">{% set t = tabular([
    {"name": "email", "width": 30, "null_repr": "N/A"}
]) %}
</code></pre>
<p>Or in templates with Jinja's default filter:</p>
<pre><code class="language-jinja">{{ entry.email | default("N/A") | col(30) }}
</code></pre>
<hr />
<h2 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h2>
<p>A git log-style output:</p>
<pre><code class="language-jinja">{% set t = tabular([
    {"name": "hash", "width": 8, "style": "muted"},
    {"name": "author", "width": {"min": 15, "max": 25}, "style": "author"},
    {"name": "message", "width": "fill"},
    {"name": "date", "width": 10, "anchor": "right", "align": "right", "style": "date"}
], separator=" │ ") %}

{% for commit in commits %}
{{ t.row([commit.hash[:8], commit.author, commit.message, commit.date]) }}
{% endfor %}
</code></pre>
<p>Output (80 columns):</p>
<pre><code class="language-text">a1b2c3d4 │ Alice Johnson   │ Add new login feature with OAuth    │ 2024-01-15
e5f6g7h8 │ Bob Smith       │ Fix authentication bug              │ 2024-01-14
i9j0k1l2 │ Carol Williams  │ Update dependencies and refactor    │ 2024-01-13
</code></pre>
<p>With styling (in terminal):</p>
<pre><code class="language-text">[muted]a1b2c3d4[/muted] │ [author]Alice Johnson[/author]   │ Add new login feature with OAuth    │ [date]2024-01-15[/date]
</code></pre>
<hr />
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Need</th><th>Solution</th></tr></thead><tbody>
<tr><td>Simple column alignment</td><td><code>{{ value | col(width) }}</code></td></tr>
<tr><td>Multiple columns, same widths</td><td><code>tabular([...])</code> with <code>t.row([...])</code></td></tr>
<tr><td>Auto field extraction</td><td><code>t.row_from(object)</code></td></tr>
<tr><td>Headers and borders</td><td><code>table([...])</code></td></tr>
<tr><td>Right-edge columns</td><td><code>anchor: "right"</code></td></tr>
<tr><td>Long content wrapping</td><td><code>overflow: "wrap"</code></td></tr>
<tr><td>Proportional widths</td><td><code>width: "2fr"</code></td></tr>
</tbody></table>
</div>
<hr />
<h2 id="reference"><a class="header" href="#reference">Reference</a></h2>
<h3 id="col-filter"><a class="header" href="#col-filter"><code>col</code> Filter</a></h3>
<pre><code class="language-text">{{ value | col(width, align=?, truncate=?, ellipsis=?) }}
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Param</th><th>Values</th><th>Default</th></tr></thead><tbody>
<tr><td><code>width</code></td><td>integer</td><td>required</td></tr>
<tr><td><code>align</code></td><td>"left", "right", "center"</td><td>"left"</td></tr>
<tr><td><code>truncate</code></td><td>"end", "start", "middle"</td><td>"end"</td></tr>
<tr><td><code>ellipsis</code></td><td>string</td><td>"…"</td></tr>
</tbody></table>
</div>
<h3 id="column-spec"><a class="header" href="#column-spec">Column Spec</a></h3>
<pre><code class="language-json">{
  "name": "string",
  "key": "field.path",
  "width": 8 | {"min": 5} | {"min": 5, "max": 20} | "fill" | "2fr",
  "align": "left" | "right" | "center",
  "anchor": "left" | "right",
  "overflow": "truncate" | "wrap" | "clip" | {"truncate": {...}} | {"wrap": {...}},
  "style": "style-name",
  "null_repr": "-"
}
</code></pre>
<h3 id="tabular-function"><a class="header" href="#tabular-function"><code>tabular()</code> Function</a></h3>
<pre><code class="language-jinja">{% set t = tabular(columns, separator=?, width=?) %}
{{ t.row([values]) }}
{{ t.row_from(object) }}
</code></pre>
<h3 id="table-function"><a class="header" href="#table-function"><code>table()</code> Function</a></h3>
<pre><code class="language-jinja">{% set t = table(columns, border=?, header=?, header_style=?, row_separator=?, width=?) %}
{{ t.header_row() }}
{{ t.separator_row() }}
{{ t.row([values]) }}
{{ t.row_from(object) }}
{{ t.top_border() }}
{{ t.bottom_border() }}
{{ t.render_all(rows) }}
</code></pre>
<h3 id="border-styles-1"><a class="header" href="#border-styles-1">Border Styles</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Value</th><th>Example</th></tr></thead><tbody>
<tr><td><code>"none"</code></td><td>No borders</td></tr>
<tr><td><code>"ascii"</code></td><td><code>+--+--+</code></td></tr>
<tr><td><code>"light"</code></td><td><code>┌──┬──┐</code></td></tr>
<tr><td><code>"heavy"</code></td><td><code>┏━━┳━━┓</code></td></tr>
<tr><td><code>"double"</code></td><td><code>╔══╦══╗</code></td></tr>
<tr><td><code>"rounded"</code></td><td><code>╭──┬──╮</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="app-configuration-1"><a class="header" href="#app-configuration-1">App Configuration</a></h1>
<p><code>AppBuilder</code> is the unified entry point for configuring your application. Instead of scattering configuration across multiple structs (<code>Standout</code>, <code>RenderSetup</code>, <code>Theme</code>), everything from command registration to theme selection happens in one fluent interface.</p>
<p>This design ensures that your application defines its entire environment—commands, styles, templates, and hooks—before the runtime starts, preventing configuration race conditions and simplifying testing.</p>
<p>This guide covers the full setup: embedding resources, registering commands, configuring themes, and customizing behavior.</p>
<p>See also:</p>
<ul>
<li><a href="topics/rendering-system.html">Rendering System</a> for details on templates and styles.</li>
<li><a href="topics/topics-system.html">Topics System</a> for help topics.</li>
</ul>
<h2 id="basic-setup"><a class="header" href="#basic-setup">Basic Setup</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout::cli::App;
use standout_macros::{embed_templates, embed_styles};

let app = App::builder()
    .templates(embed_templates!("src/templates"))
    .styles(embed_styles!("src/styles"))
    .default_theme("default")
    .command("list", list_handler, "list.j2")
    .build()?;

app.run(Cli::command(), std::env::args());
<span class="boring">}</span></code></pre></pre>
<h2 id="embedding-resources"><a class="header" href="#embedding-resources">Embedding Resources</a></h2>
<h3 id="templates"><a class="header" href="#templates">Templates</a></h3>
<p><code>embed_templates!</code> embeds template files at compile time:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.templates(embed_templates!("src/templates"))
<span class="boring">}</span></code></pre></pre>
<p>Collects files matching: <code>.jinja</code>, <code>.jinja2</code>, <code>.j2</code>, <code>.txt</code> (in priority order).</p>
<p>Directory structure:</p>
<pre><code class="language-text">src/templates/
  list.j2
  add.j2
  db/
    migrate.j2
    status.j2
</code></pre>
<p>Templates are referenced by path without extension: <code>"list"</code>, <code>"db/migrate"</code>.</p>
<h3 id="styles"><a class="header" href="#styles">Styles</a></h3>
<p><code>embed_styles!</code> embeds stylesheet files:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.styles(embed_styles!("src/styles"))
<span class="boring">}</span></code></pre></pre>
<p>Collects files matching: <code>.yaml</code>, <code>.yml</code>.</p>
<pre><code class="language-text">src/styles/
  default.yaml
  dark.yaml
  light.yaml
</code></pre>
<p>Themes are referenced by filename without extension: <code>"default"</code>, <code>"dark"</code>.</p>
<h3 id="hot-reloading-1"><a class="header" href="#hot-reloading-1">Hot Reloading</a></h3>
<p>In debug builds, embedded resources are re-read from disk on each render—edit without recompiling. In release builds, embedded content is used directly.</p>
<p>This is automatic when the source path exists on disk.</p>
<h2 id="runtime-overrides"><a class="header" href="#runtime-overrides">Runtime Overrides</a></h2>
<p>Users can override embedded resources with local files:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::builder()
    .templates(embed_templates!("src/templates"))
    .templates_dir("~/.myapp/templates")  // Overrides embedded
    .styles(embed_styles!("src/styles"))
    .styles_dir("~/.myapp/themes")        // Overrides embedded
<span class="boring">}</span></code></pre></pre>
<p>Local directories take precedence. This enables user customization without recompiling.</p>
<h2 id="theme-selection"><a class="header" href="#theme-selection">Theme Selection</a></h2>
<h3 id="from-stylesheet-registry"><a class="header" href="#from-stylesheet-registry">From Stylesheet Registry</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    .styles(embed_styles!("src/styles"))
    // Optional: set explicit default name
    // If omitted, tries "default", "theme", then "base"
    .default_theme("dark")
<span class="boring">}</span></code></pre></pre>
<p>If <code>.default_theme()</code> is not called, <code>AppBuilder</code> attempts to load a theme from the registry in this order:</p>
<ol>
<li><code>default</code></li>
<li><code>theme</code></li>
<li><code>base</code></li>
</ol>
<p>This allows you to provide a standard <code>base.yaml</code> or <code>theme.yaml</code> without requiring explicit configuration code. If the explicit theme isn't found, <code>build()</code> returns <code>SetupError::ThemeNotFound</code>.</p>
<h3 id="explicit-theme"><a class="header" href="#explicit-theme">Explicit Theme</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let theme = Theme::new()
    .add("title", Style::new().bold().cyan())
    .add("muted", Style::new().dim());

App::builder()
    .theme(theme)  // Overrides stylesheet registry
<span class="boring">}</span></code></pre></pre>
<p>Explicit <code>.theme()</code> takes precedence over <code>.default_theme()</code>.</p>
<h2 id="command-registration"><a class="header" href="#command-registration">Command Registration</a></h2>
<h3 id="simple-commands"><a class="header" href="#simple-commands">Simple Commands</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::builder()
    .command("list", list_handler, "list.j2")
    .command("add", add_handler, "add.j2")
<span class="boring">}</span></code></pre></pre>
<p>Arguments: command name, handler function, template path.</p>
<h3 id="with-configuration"><a class="header" href="#with-configuration">With Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::builder()
    .command_with("delete", delete_handler, |cfg| cfg
        .template("delete.j2")
        .pre_dispatch(require_confirmation)
        .post_dispatch(log_deletion))
<span class="boring">}</span></code></pre></pre>
<p>Inline hook attachment without separate <code>.hooks()</code> call.</p>
<h3 id="nested-groups"><a class="header" href="#nested-groups">Nested Groups</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::builder()
    .group("db", |g| g
        .command("migrate", migrate_handler, "db/migrate.j2")
        .command("status", status_handler, "db/status.j2")
        .group("backup", |b| b
            .command("create", backup_create, "db/backup/create.j2")
            .command("restore", backup_restore, "db/backup/restore.j2")))
<span class="boring">}</span></code></pre></pre>
<p>Creates command paths: <code>db.migrate</code>, <code>db.status</code>, <code>db.backup.create</code>, <code>db.backup.restore</code>.</p>
<h3 id="from-dispatch-macro"><a class="header" href="#from-dispatch-macro">From Dispatch Macro</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Dispatch)]
enum Commands {
    List,
    Add,
    #[dispatch(nested)]
    Db(DbCommands),
}

App::builder()
    .commands(Commands::dispatch_config())
<span class="boring">}</span></code></pre></pre>
<p>The macro generates registration for all variants.</p>
<h2 id="default-command"><a class="header" href="#default-command">Default Command</a></h2>
<p>When a CLI is invoked without a subcommand (a "naked" invocation like <code>myapp</code> or <code>myapp --verbose</code>), you can specify a default command to run:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::builder()
    .default_command("list")
    .command("list", list_handler, "list.j2")
    .command("add", add_handler, "add.j2")
<span class="boring">}</span></code></pre></pre>
<p>With this configuration:</p>
<ul>
<li><code>myapp</code> becomes <code>myapp list</code></li>
<li><code>myapp --output=json</code> becomes <code>myapp list --output=json</code></li>
<li><code>myapp add foo</code> stays as <code>myapp add foo</code> (explicit command takes precedence)</li>
</ul>
<h3 id="with-dispatch-macro"><a class="header" href="#with-dispatch-macro">With Dispatch Macro</a></h3>
<p>Use the <code>#[dispatch(default)]</code> attribute to mark a variant as the default:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Dispatch)]
#[dispatch(handlers = handlers)]
enum Commands {
    #[dispatch(default)]
    List,
    Add,
}

App::builder()
    .commands(Commands::dispatch_config())
<span class="boring">}</span></code></pre></pre>
<p>Only one command can be marked as default. Multiple <code>#[dispatch(default)]</code> attributes will cause a compile error.</p>
<h2 id="hooks"><a class="header" href="#hooks">Hooks</a></h2>
<p>Attach hooks to specific command paths:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::builder()
    .command("migrate", migrate_handler, "migrate.j2")
    .hooks("db.migrate", Hooks::new()
        .pre_dispatch(require_admin)
        .post_dispatch(add_timestamp)
        .post_output(log_result))
<span class="boring">}</span></code></pre></pre>
<p>The path uses dot notation matching the command hierarchy.</p>
<h2 id="context-injection-1"><a class="header" href="#context-injection-1">Context Injection</a></h2>
<p>Add values available in all templates:</p>
<h3 id="static-context-1"><a class="header" href="#static-context-1">Static Context</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::builder()
    .context("version", "1.0.0")
    .context("app_name", "MyApp")
<span class="boring">}</span></code></pre></pre>
<h3 id="dynamic-context-1"><a class="header" href="#dynamic-context-1">Dynamic Context</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::builder()
    .context_fn("terminal_width", |ctx| {
        Value::from(ctx.terminal_width.unwrap_or(80))
    })
    .context_fn("timestamp", |_ctx| {
        Value::from(chrono::Utc::now().to_rfc3339())
    })
<span class="boring">}</span></code></pre></pre>
<p>Dynamic providers receive <code>RenderContext</code> with output mode, terminal width, and handler data.</p>
<h2 id="topics-1"><a class="header" href="#topics-1">Topics</a></h2>
<p>Add help topics:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::builder()
    .topics_dir("docs/topics")
    .add_topic(Topic::new("auth", "Authentication...", TopicType::Text, None))
<span class="boring">}</span></code></pre></pre>
<p>See <a href="topics/topics-system.html">Topics System</a> for details.</p>
<h2 id="flag-customization"><a class="header" href="#flag-customization">Flag Customization</a></h2>
<h3 id="output-flag"><a class="header" href="#output-flag">Output Flag</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::builder()
    .output_flag(Some("format"))  // --format instead of --output
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::builder()
    .no_output_flag()  // Disable entirely
<span class="boring">}</span></code></pre></pre>
<h3 id="file-output-flag"><a class="header" href="#file-output-flag">File Output Flag</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::builder()
    .output_file_flag(Some("out"))  // --out instead of --output-file-path
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::builder()
    .no_output_file_flag()  // Disable entirely
<span class="boring">}</span></code></pre></pre>
<h2 id="the-app-struct"><a class="header" href="#the-app-struct">The App Struct</a></h2>
<p><code>build()</code> produces an <code>App</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct App {
    registry: TopicRegistry,
    output_flag: Option&lt;String&gt;,
    output_file_flag: Option&lt;String&gt;,
    output_mode: OutputMode,
    theme: Option&lt;Theme&gt;,
    command_hooks: HashMap&lt;String, Hooks&gt;,
    template_registry: Option&lt;TemplateRegistry&gt;,
    stylesheet_registry: Option&lt;StylesheetRegistry&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="running-the-app"><a class="header" href="#running-the-app">Running the App</a></h2>
<h3 id="standard-execution"><a class="header" href="#standard-execution">Standard Execution</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(matches) = app.run(Cli::command(), std::env::args()) {
    // Standout didn't handle this command, fall back to legacy
    legacy_dispatch(matches);
}
<span class="boring">}</span></code></pre></pre>
<p>Parses args, dispatches to handler, prints output. Returns <code>Option&lt;ArgMatches&gt;</code>—<code>None</code> if handled, <code>Some(matches)</code> for fallback.</p>
<h3 id="capture-output"><a class="header" href="#capture-output">Capture Output</a></h3>
<p>For testing, post-processing, or when you need the output string:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match app.run_to_string(cmd, args) {
    RunResult::Handled(output) =&gt; { /* use output string */ }
    RunResult::Binary(bytes, filename) =&gt; { /* handle binary */ }
    RunResult::NoMatch(matches) =&gt; { /* fallback dispatch */ }
}
<span class="boring">}</span></code></pre></pre>
<p>Returns <code>RunResult</code> instead of printing.</p>
<h3 id="parse-only"><a class="header" href="#parse-only">Parse Only</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let matches = app.parse_with(cmd);
// Use matches for manual dispatch
<span class="boring">}</span></code></pre></pre>
<p>Parses with Standout's augmented command but doesn't dispatch.</p>
<h2 id="build-validation"><a class="header" href="#build-validation">Build Validation</a></h2>
<p><code>build()</code> validates:</p>
<ul>
<li>Theme exists if <code>.default_theme()</code> was called</li>
<li>Returns <code>SetupError::ThemeNotFound</code> if not found</li>
</ul>
<p>What's NOT validated at build time:</p>
<ul>
<li>Templates (resolved lazily at render time)</li>
<li>Command handlers</li>
<li>Hook signatures (verified at registration)</li>
</ul>
<h2 id="complete-example-1"><a class="header" href="#complete-example-1">Complete Example</a></h2>
<pre><pre class="playground"><code class="language-rust">use standout::cli::{App, HandlerResult, Output};
use standout_macros::{embed_templates, embed_styles};
use clap::{Command, Arg};
use serde::Serialize;

#[derive(Serialize)]
struct ListOutput {
    items: Vec&lt;String&gt;,
}

fn list_handler(matches: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;ListOutput&gt; {
    let items = vec!["one".into(), "two".into()];
    Ok(Output::Render(ListOutput { items }))
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let cli = Command::new("myapp")
        .subcommand(Command::new("list").about("List items"));

    let app = App::builder()
        .templates(embed_templates!("src/templates"))
        .styles(embed_styles!("src/styles"))
        .default_theme("default")
        .context("version", env!("CARGO_PKG_VERSION"))
        .command("list", list_handler, "list.j2")
        .topics_dir("docs/topics")
        .build()?;

    app.run(cli, std::env::args());
    Ok(())
}</code></pre></pre>
<p>Template <code>src/templates/list.j2</code>:</p>
<pre><code class="language-jinja">[header]Items[/header] ({{ items | length }} total)
{% for item in items %}
  - {{ item }}
{% endfor %}

[muted]v{{ version }}[/muted]
</code></pre>
<p>Style <code>src/styles/default.yaml</code>:</p>
<pre><code class="language-yaml">header:
  fg: cyan
  bold: true
muted:
  dim: true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="execution-model-1"><a class="header" href="#execution-model-1">Execution Model</a></h1>
<p>Standout manages a strict linear pipeline from CLI input to rendered output. This explicitly separated flow ensures that logic (Handlers) remains decoupled from presentation (Templates) and side-effects (Hooks).</p>
<p>Understanding this model allows you to extend the framework predictably—knowing exactly where to intercept execution, what data is available, and how to test each stage in isolation.</p>
<h2 id="the-pipeline"><a class="header" href="#the-pipeline">The Pipeline</a></h2>
<pre><code class="language-text">Clap Parsing → Dispatch → Handler → Hooks → Rendering → Output
</code></pre>
<p>Each stage has a clear responsibility:</p>
<p><strong>Clap Parsing</strong>: Your <code>clap::Command</code> definition is augmented with Standout's flags (<code>--output</code>, custom help) and parsed normally. Standout doesn't replace clap—it builds on top of it.</p>
<p><strong>Dispatch</strong>: Standout extracts the <em>command path</em> from the parsed <code>ArgMatches</code>, navigating through subcommands to find the deepest match. It then looks up the registered handler for that path.</p>
<p><strong>Handler</strong>: Your logic function executes. It receives the <code>ArgMatches</code> and a <code>CommandContext</code>, returning a <code>HandlerResult&lt;T&gt;</code>—either data to render, a silent marker, or binary content. With <code>App</code>, handlers use <code>&amp;self</code>; with <code>LocalApp</code>, handlers use <code>&amp;mut self</code> (see <a href="topics/handler-contract.html">Handler Contract</a>).</p>
<p><strong>Hooks</strong>: If registered, hooks run at three points around the handler. They can validate, transform, or intercept without modifying handler logic.</p>
<p><strong>Rendering</strong>: Handler output is serialized and passed through the template engine, producing styled terminal output (or structured data like JSON, depending on output mode).</p>
<p><strong>Output</strong>: The result is written to stdout or a file.</p>
<p>This pipeline is what Standout manages for you—the glue code between "I have a clap definition" and "I want rich, testable output."</p>
<ul>
<li>See <a href="topics/handler-contract.html">Handler Contract</a> for handler details.</li>
<li>See <a href="topics/rendering-system.html">Rendering System</a> for the render phase.</li>
</ul>
<h2 id="command-paths"><a class="header" href="#command-paths">Command Paths</a></h2>
<p>A command path is a vector of strings representing the subcommand chain:</p>
<pre><code class="language-bash">myapp db migrate --steps 5
</code></pre>
<p>The command path is <code>["db", "migrate"]</code>.</p>
<p>When you register commands with <code>AppBuilder</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::builder()
    .command("list", list_handler, "list.j2")
    .group("db", |g| g
        .command("migrate", migrate_handler, "db/migrate.j2")
        .command("status", status_handler, "db/status.j2"))
    .build()?
<span class="boring">}</span></code></pre></pre>
<p>Standout builds an internal registry mapping paths to handlers:</p>
<ul>
<li><code>["list"]</code> → <code>list_handler</code></li>
<li><code>["db", "migrate"]</code> → <code>migrate_handler</code></li>
<li><code>["db", "status"]</code> → <code>status_handler</code></li>
</ul>
<p>The command path is available in <code>CommandContext.command_path</code> for your handler to inspect, and uses dot notation (<code>"db.migrate"</code>) when registering hooks.</p>
<h2 id="the-hooks-system"><a class="header" href="#the-hooks-system">The Hooks System</a></h2>
<p>Hooks are functions that run at specific points in the pipeline. They let you intercept, validate, or transform without touching handler logic—keeping concerns separated.</p>
<h3 id="three-phases"><a class="header" href="#three-phases">Three Phases</a></h3>
<p><strong>Pre-dispatch</strong>: Runs before the handler. Can abort execution.</p>
<p>Use for: authentication checks, input validation, logging start time. The hook receives <code>ArgMatches</code> and <code>CommandContext</code> but returns no data—only success or failure.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Hooks::new().pre_dispatch(|matches, ctx| {
    if !is_authenticated() {
        return Err(HookError::pre_dispatch("authentication required"));
    }
    Ok(())
})
<span class="boring">}</span></code></pre></pre>
<p><strong>Post-dispatch</strong>: Runs after the handler, before rendering. Can transform data.</p>
<p>Use for: adding timestamps, filtering sensitive fields, data enrichment. The hook receives handler output as <code>serde_json::Value</code>, allowing generic transformations regardless of the handler's output type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Hooks::new().post_dispatch(|_matches, _ctx, mut data| {
    if let Some(obj) = data.as_object_mut() {
        obj.insert("generated_at".into(), json!(Utc::now().to_rfc3339()));
    }
    Ok(data)
})
<span class="boring">}</span></code></pre></pre>
<p><strong>Post-output</strong>: Runs after rendering. Can transform the final string.</p>
<p>Use for: adding headers/footers, compression, logging. The hook receives <code>RenderedOutput</code>—an enum of <code>Text(String)</code>, <code>Binary(Vec&lt;u8&gt;, String)</code>, or <code>Silent</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Hooks::new().post_output(|_matches, _ctx, output| {
    match output {
        RenderedOutput::Text(s) =&gt; {
            Ok(RenderedOutput::Text(format!("{}\n-- Generated by MyApp", s)))
        }
        other =&gt; Ok(other),
    }
})
<span class="boring">}</span></code></pre></pre>
<h3 id="hook-chaining"><a class="header" href="#hook-chaining">Hook Chaining</a></h3>
<p>Multiple hooks per phase are supported. Pre-dispatch hooks run sequentially—first error aborts. Post-dispatch and post-output hooks <em>chain</em>: each receives the output of the previous, enabling composable transformations.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Hooks::new()
    .post_dispatch(add_metadata)      // Runs first
    .post_dispatch(filter_sensitive)  // Receives add_metadata's output
<span class="boring">}</span></code></pre></pre>
<p>Order matters: <code>filter_sensitive</code> sees the metadata that <code>add_metadata</code> inserted.</p>
<h3 id="attaching-hooks"><a class="header" href="#attaching-hooks">Attaching Hooks</a></h3>
<p>Two approaches:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Via AppBuilder.hooks() with dot-notation path
App::builder()
    .command("migrate", migrate_handler, "migrate.j2")
    .hooks("db.migrate", Hooks::new()
        .pre_dispatch(require_admin))
    .build()?

// Via command_with() inline
App::builder()
    .command_with("migrate", migrate_handler, |cfg| cfg
        .template("migrate.j2")
        .pre_dispatch(require_admin))
    .build()?
<span class="boring">}</span></code></pre></pre>
<p>See <a href="topics/app-configuration.html">App Configuration</a> for more on registration.</p>
<h3 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h3>
<p>When a hook returns <code>Err(HookError)</code>:</p>
<ul>
<li>Execution stops immediately</li>
<li>Remaining hooks in that phase don't run</li>
<li>For pre-dispatch: the handler never executes</li>
<li>For post phases: the rendered output is discarded</li>
<li>The error message becomes the command output</li>
</ul>
<p><code>HookError</code> includes the phase and an optional source error for context:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>HookError::pre_dispatch("database connection failed")
    .with_source(db_error)
<span class="boring">}</span></code></pre></pre>
<h2 id="dispatch-details"><a class="header" href="#dispatch-details">Dispatch Details</a></h2>
<p>When <code>app.run()</code> executes:</p>
<ol>
<li>Clap parses the arguments</li>
<li>Standout traverses the <code>ArgMatches</code> subcommand chain to find the deepest match</li>
<li><strong>If no subcommand was specified and a default command is configured</strong>, Standout inserts the default command and reparses</li>
<li>It extracts the command path (e.g., <code>["db", "migrate"]</code>)</li>
<li>It looks up the handler for that path</li>
<li>It executes the handler with the appropriate <code>ArgMatches</code> slice</li>
</ol>
<h3 id="default-command-behavior"><a class="header" href="#default-command-behavior">Default Command Behavior</a></h3>
<p>When you configure a default command:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::builder()
    .default_command("list")
<span class="boring">}</span></code></pre></pre>
<p>A "naked" invocation like <code>myapp</code> or <code>myapp --verbose</code> will automatically dispatch to the <code>list</code> command. The arguments are modified internally to insert the command name, then reparsed. This ensures all clap validation and parsing rules apply correctly to the default command.</p>
<p>If no handler matches, <code>run()</code> returns <code>Some(matches)</code>, letting you fall back to manual dispatch:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(matches) = app.run(cmd, args) {
    // Standout didn't handle this command, fall back to legacy
    match matches.subcommand() {
        Some(("legacy", sub)) =&gt; legacy_handler(sub),
        _ =&gt; {}
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This enables gradual adoption—Standout handles some commands while others use your existing code.</p>
<h2 id="what-standout-adds-to-your-command"><a class="header" href="#what-standout-adds-to-your-command">What Standout Adds to Your Command</a></h2>
<p>When you call <code>app.run()</code>, Standout augments your <code>clap::Command</code> with:</p>
<p><strong>Custom help subcommand</strong>:</p>
<pre><code class="language-bash">myapp help              # Main help
myapp help topic-name   # Specific topic
myapp help --page       # Use pager for long content
</code></pre>
<p><strong>Global <code>--output</code> flag</strong>:</p>
<pre><code class="language-bash">myapp list --output=json
myapp db status --output=yaml
</code></pre>
<p>Values: <code>auto</code>, <code>term</code>, <code>text</code>, <code>term-debug</code>, <code>json</code>, <code>yaml</code>, <code>xml</code>, <code>csv</code></p>
<p><strong>Global <code>--output-file-path</code> flag</strong>:</p>
<pre><code class="language-bash">myapp list --output-file-path=results.txt
</code></pre>
<p>These flags are global—they apply to all subcommands. You can rename or disable them via <code>AppBuilder</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::builder()
    .output_flag(Some("format"))       // Rename to --format
    .no_output_file_flag()             // Disable file output
<span class="boring">}</span></code></pre></pre>
<h2 id="app-vs-localapp-dispatch"><a class="header" href="#app-vs-localapp-dispatch">App vs LocalApp Dispatch</a></h2>
<p>Both <code>App</code> and <code>LocalApp</code> follow the same pipeline, with one key difference:</p>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th><code>App</code></th><th><code>LocalApp</code></th></tr></thead><tbody>
<tr><td>Handler storage</td><td><code>Arc&lt;dyn Fn + Send + Sync&gt;</code></td><td><code>Rc&lt;RefCell&lt;dyn FnMut&gt;&gt;</code></td></tr>
<tr><td>Handler call</td><td><code>handler.handle(...)</code> with <code>&amp;self</code></td><td><code>handler.handle(...)</code> with <code>&amp;mut self</code></td></tr>
<tr><td>Run method</td><td><code>app.run(cmd, args)</code> with <code>&amp;self</code></td><td><code>app.run(cmd, args)</code> with <code>&amp;mut self</code></td></tr>
<tr><td>Thread safety</td><td>Yes</td><td>No</td></tr>
</tbody></table>
</div>
<p>Choose <code>LocalApp</code> when your handlers need mutable access to captured state without interior mutability wrappers. See <a href="topics/handler-contract.html">Handler Contract</a> for detailed guidance.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-adopt-standout-alongside-existing-clap-code"><a class="header" href="#how-to-adopt-standout-alongside-existing-clap-code">How To: Adopt Standout Alongside Existing Clap Code</a></h1>
<p>Adopting a new framework shouldn't require rewriting your entire application. Standout is designed for <strong>gradual adoption</strong>, allowing you to migrate one command at a time without breaking existing functionality.</p>
<p>This guide shows how to run Standout alongside your existing manual dispatch or Clap loop.</p>
<h2 id="the-core-pattern"><a class="header" href="#the-core-pattern">The Core Pattern</a></h2>
<p>When Standout handles a command, it prints output and returns <code>None</code>. When no handler matches, it returns <code>Some(ArgMatches)</code> for your fallback:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(matches) = app.run(cli, std::env::args()) {
    // Standout didn't handle this command, fall back to legacy
    your_existing_dispatch(matches);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="pattern-1-standout-first-fallback-second"><a class="header" href="#pattern-1-standout-first-fallback-second">Pattern 1: Standout First, Fallback Second</a></h2>
<p>Try Standout dispatch first. If no match, use your existing code:</p>
<pre><pre class="playground"><code class="language-rust">use standout::cli::App;
use clap::Command;

fn main() {
    let cli = Command::new("myapp")
        .subcommand(Command::new("list"))     // Standout handles
        .subcommand(Command::new("status"))   // Your existing code
        .subcommand(Command::new("config"));  // Your existing code

    // Build Standout for just the commands you want
    let app = App::builder()
        .command("list", list_handler, "list.j2")
        .build()
        .expect("Failed to build app");

    // Try Standout first
    if let Some(matches) = app.run(cli, std::env::args()) {
        // Fall back to your existing dispatch
        match matches.subcommand() {
            Some(("status", sub)) =&gt; handle_status(sub),
            Some(("config", sub)) =&gt; handle_config(sub),
            _ =&gt; eprintln!("Unknown command"),
        }
    }
}</code></pre></pre>
<h2 id="pattern-2-existing-code-first-standout-fallback"><a class="header" href="#pattern-2-existing-code-first-standout-fallback">Pattern 2: Existing Code First, Standout Fallback</a></h2>
<p>Your dispatch handles known commands, Standout handles new ones:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let cli = build_cli();
    let matches = cli.clone().get_matches();

    // Your existing dispatch first
    match matches.subcommand() {
        Some(("legacy-cmd", sub)) =&gt; {
            handle_legacy(sub);
            return;
        }
        Some(("old-feature", sub)) =&gt; {
            handle_old_feature(sub);
            return;
        }
        _ =&gt; {
            // Not handled by existing code
        }
    }

    // Standout handles everything else
    let app = build_standout_app();
    app.run(cli, std::env::args());
}</code></pre></pre>
<h2 id="pattern-3-standout-inside-your-match"><a class="header" href="#pattern-3-standout-inside-your-match">Pattern 3: Standout Inside Your Match</a></h2>
<p>Call Standout for specific commands within your existing match:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let cli = build_cli();
    let matches = cli.clone().get_matches();

    match matches.subcommand() {
        Some(("status", sub)) =&gt; handle_status(sub),
        Some(("config", sub)) =&gt; handle_config(sub),

        // Use Standout just for these
        Some(("list", _)) | Some(("show", _)) =&gt; {
            let app = build_standout_app();
            app.run(cli, std::env::args());
        }

        _ =&gt; eprintln!("Unknown command"),
    }
}</code></pre></pre>
<h2 id="adding-standout-to-one-command"><a class="header" href="#adding-standout-to-one-command">Adding Standout to One Command</a></h2>
<p>Minimal setup for a single command:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let app = App::builder()
    .command("list", |matches, ctx| {
        let items = fetch_items()?;
        Ok(Output::Render(ListOutput { items }))
    }, "{% for item in items %}- {{ item }}\n{% endfor %}")
    .build()?;
<span class="boring">}</span></code></pre></pre>
<p>No embedded files required. The template is inline. No theme means style tags show <code>?</code> markers, but rendering still works.</p>
<h2 id="sharing-clap-command-definition"><a class="header" href="#sharing-clap-command-definition">Sharing Clap Command Definition</a></h2>
<p>Standout augments your <code>clap::Command</code> with <code>--output</code> and help. You can share the definition:</p>
<pre><pre class="playground"><code class="language-rust">fn build_cli() -&gt; Command {
    Command::new("myapp")
        .subcommand(Command::new("list").about("List items"))
        .subcommand(Command::new("status").about("Show status"))
}

fn main() {
    let cli = build_cli();

    let app = App::builder()
        .command("list", list_handler, "list.j2")
        .build()?;

    // Standout augments the command, then dispatches
    if let Some(matches) = app.run(cli, std::env::args()) {
        // matches from the augmented command (has --output, etc.)
        match matches.subcommand() {
            Some(("status", sub)) =&gt; handle_status(sub),
            _ =&gt; {}
        }
    }
}</code></pre></pre>
<h2 id="gradual-migration-strategy"><a class="header" href="#gradual-migration-strategy">Gradual Migration Strategy</a></h2>
<ol>
<li>
<p><strong>Start with one command</strong>: Pick a command with complex output. Add Standout for just that command.</p>
</li>
<li>
<p><strong>Keep existing tests passing</strong>: Your dispatch logic stays the same for unhandled commands.</p>
</li>
<li>
<p><strong>Add more commands over time</strong>: Register additional handlers as you refactor.</p>
</li>
<li>
<p><strong>Add themes when ready</strong>: Start with inline templates, add YAML stylesheets later.</p>
</li>
<li>
<p><strong>Eventually remove legacy dispatch</strong>: Once all commands are migrated, simplify to just <code>app.run()</code>.</p>
</li>
</ol>
<h2 id="using-run-vs-run_to_string"><a class="header" href="#using-run-vs-run_to_string">Using run() vs run_to_string()</a></h2>
<p><code>run()</code> prints output directly and returns <code>Option&lt;ArgMatches&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(matches) = app.run(cli, args) {
    // Standout didn't handle, use matches for fallback
    legacy_dispatch(matches);
}
<span class="boring">}</span></code></pre></pre>
<p><code>run_to_string()</code> captures output instead of printing, returning <code>RunResult</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match app.run_to_string(cli, args) {
    RunResult::Handled(output) =&gt; { /* process output string */ }
    RunResult::Binary(bytes, filename) =&gt; { /* handle binary */ }
    RunResult::NoMatch(matches) =&gt; { /* access matches */ }
}
<span class="boring">}</span></code></pre></pre>
<p>Use <code>run_to_string()</code> when you need to:</p>
<ul>
<li>Capture output for testing</li>
<li>Post-process the output string before printing</li>
<li>Log or record what was generated</li>
</ul>
<p>For normal partial adoption, <code>run()</code> is simpler and preferred.</p>
<h2 id="accessing-the---output-flag-in-fallback"><a class="header" href="#accessing-the---output-flag-in-fallback">Accessing the --output Flag in Fallback</a></h2>
<p>Standout adds <code>--output</code> globally. In fallback code, you can still access it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(matches) = app.run(cli, std::env::args()) {
    // Get the output mode Standout parsed
    let mode = matches.get_one::&lt;String&gt;("_output_mode")
        .map(|s| s.as_str())
        .unwrap_or("auto");

    match matches.subcommand() {
        Some(("status", sub)) =&gt; {
            if mode == "json" {
                println!("{}", serde_json::to_string(&amp;status_data)?);
            } else {
                print_status_text(&amp;status_data);
            }
        }
        _ =&gt; {}
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="disabling-standouts-flags"><a class="header" href="#disabling-standouts-flags">Disabling Standout's Flags</a></h2>
<p>If <code>--output</code> conflicts with your existing flags:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::builder()
    .no_output_flag()       // Don't add --output
    .no_output_file_flag()  // Don't add --output-file-path
    .command("list", handler, template)
    .build()?
<span class="boring">}</span></code></pre></pre>
<h2 id="example-hybrid-application"><a class="header" href="#example-hybrid-application">Example: Hybrid Application</a></h2>
<p>Complete example with both Standout and manual handlers:</p>
<pre><pre class="playground"><code class="language-rust">use standout::cli::{App, HandlerResult, Output, CommandContext};
use clap::{Command, ArgMatches};
use serde::Serialize;

#[derive(Serialize)]
struct ListOutput { items: Vec&lt;String&gt; }

fn list_handler(_m: &amp;ArgMatches, _ctx: &amp;CommandContext) -&gt; HandlerResult&lt;ListOutput&gt; {
    Ok(Output::Render(ListOutput {
        items: vec!["one".into(), "two".into()],
    }))
}

fn handle_status(_matches: &amp;ArgMatches) {
    println!("Status: OK");
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let cli = Command::new("myapp")
        .subcommand(Command::new("list").about("List items (Standout)"))
        .subcommand(Command::new("status").about("Show status (legacy)"));

    let app = App::builder()
        .command("list", list_handler, "{% for i in items %}- {{ i }}\n{% endfor %}")
        .build()?;

    if let Some(matches) = app.run(cli, std::env::args()) {
        match matches.subcommand() {
            Some(("status", sub)) =&gt; handle_status(sub),
            _ =&gt; eprintln!("Unknown command"),
        }
    }

    Ok(())
}</code></pre></pre>
<p>Run it:</p>
<pre><code class="language-bash">myapp list              # Standout handles, renders template
myapp list --output=json # Standout handles, JSON output
myapp status            # Fallback to handle_status()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-use-only-the-rendering-layer"><a class="header" href="#how-to-use-only-the-rendering-layer">How To: Use Only the Rendering Layer</a></h1>
<p>Standout's rendering layer is fully decoupled from its CLI integration (App, Clap, Dispatch). This means you can use the template engine, theme system, and structured output logic in any context—servers, TUI apps, or even other CLI frameworks.</p>
<p>This decoupling allows you to maintain consistent styling and logic across different parts of your ecosystem.</p>
<h2 id="when-to-use-this"><a class="header" href="#when-to-use-this">When to Use This</a></h2>
<ul>
<li>Adding styled output to an existing application</li>
<li>Building a library that produces formatted terminal output</li>
<li>Server-side rendering of CLI-style output</li>
<li>Testing templates in isolation</li>
</ul>
<h2 id="basic-rendering-1"><a class="header" href="#basic-rendering-1">Basic Rendering</a></h2>
<p>The simplest approach—auto-detect terminal capabilities:</p>
<pre><pre class="playground"><code class="language-rust">use standout::{render, Theme};
use console::Style;
use serde::Serialize;

#[derive(Serialize)]
struct Report {
    title: String,
    items: Vec&lt;String&gt;,
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let theme = Theme::new()
        .add("title", Style::new().bold().cyan())
        .add("item", Style::new().green());

    let data = Report {
        title: "Status Report".into(),
        items: vec!["Task A: complete".into(), "Task B: pending".into()],
    };

    let output = render(
        r#"[title]{{ title }}[/title]
{% for item in items %}
  [item]•[/item] {{ item }}
{% endfor %}"#,
        &amp;data,
        &amp;theme,
    )?;

    println!("{}", output);
    Ok(())
}</code></pre></pre>
<h2 id="explicit-output-mode"><a class="header" href="#explicit-output-mode">Explicit Output Mode</a></h2>
<p>Control ANSI code generation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout::{render_with_output, OutputMode};

// Force ANSI codes (even when piping)
let colored = render_with_output(template, &amp;data, &amp;theme, OutputMode::Term)?;

// Force plain text (no ANSI codes)
let plain = render_with_output(template, &amp;data, &amp;theme, OutputMode::Text)?;

// Debug mode (tags as literals)
let debug = render_with_output(template, &amp;data, &amp;theme, OutputMode::TermDebug)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="auto-dispatch-template-vs-serialization"><a class="header" href="#auto-dispatch-template-vs-serialization">Auto-Dispatch: Template vs Serialization</a></h2>
<p><code>render_auto</code> chooses between template rendering and direct serialization:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout::render_auto;

fn format_output(data: &amp;Report, mode: OutputMode) -&gt; Result&lt;String, Error&gt; {
    render_auto(template, data, &amp;theme, mode)
}

// Term/Text/Auto: renders template
format_output(&amp;data, OutputMode::Term)?;

// Json/Yaml/Xml/Csv: serializes data directly
format_output(&amp;data, OutputMode::Json)?;
<span class="boring">}</span></code></pre></pre>
<p>Same function, same data—output format determined by mode.</p>
<h2 id="full-control-output-mode--color-mode"><a class="header" href="#full-control-output-mode--color-mode">Full Control: Output Mode + Color Mode</a></h2>
<p>For tests or when forcing specific behavior:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout::{render_with_mode, ColorMode};

// Force dark mode styling
let dark = render_with_mode(
    template,
    &amp;data,
    &amp;theme,
    OutputMode::Term,
    ColorMode::Dark,
)?;

// Force light mode styling
let light = render_with_mode(
    template,
    &amp;data,
    &amp;theme,
    OutputMode::Term,
    ColorMode::Light,
)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="building-themes-programmatically"><a class="header" href="#building-themes-programmatically">Building Themes Programmatically</a></h2>
<p>No YAML files needed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout::Theme;
use console::{Style, Color};

let theme = Theme::new()
    // Simple styles
    .add("bold", Style::new().bold())
    .add("muted", Style::new().dim())
    .add("error", Style::new().red().bold())

    // With specific colors
    .add("info", Style::new().fg(Color::Cyan))
    .add("warning", Style::new().fg(Color::Yellow))

    // Aliases
    .add("disabled", "muted")
    .add("inactive", "muted")

    .add_adaptive(
        "panel",
        Style::new().bold(),
        Some(Style::new().fg(Color::Black)),  // Light mode
        Some(Style::new().fg(Color::White)),  // Dark mode
    );
<span class="boring">}</span></code></pre></pre>
<h3 id="theme-merging"><a class="header" href="#theme-merging">Theme Merging</a></h3>
<p>You can layer themes using <code>merge</code>. This is useful for user overrides:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let base_theme = Theme::from_file("base.yaml")?;
let user_overrides = Theme::from_file("user-config.yaml")?;

// User styles overwrite base styles
let final_theme = base_theme.merge(user_overrides);
<span class="boring">}</span></code></pre></pre>
<h2 id="pre-compiled-renderer"><a class="header" href="#pre-compiled-renderer">Pre-Compiled Renderer</a></h2>
<p>For repeated rendering with the same templates:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout::Renderer;

let theme = Theme::new()
    .add("title", Style::new().bold());

let mut renderer = Renderer::new(theme)?;

// Register templates
renderer.add_template("header", "[title]{{ title }}[/title]")?;
renderer.add_template("item", "  - {{ name }}: {{ value }}")?;

// Render multiple times
for record in records {
    let header = renderer.render("header", &amp;record)?;
    println!("{}", header);

    for item in &amp;record.items {
        let line = renderer.render("item", item)?;
        println!("{}", line);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="loading-templates-from-files"><a class="header" href="#loading-templates-from-files">Loading Templates from Files</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut renderer = Renderer::new(theme)?;

// Add directory of templates
renderer.add_template_dir("./templates")?;

// Templates resolved by name (without extension)
let output = renderer.render("report", &amp;data)?;
<span class="boring">}</span></code></pre></pre>
<p>In debug builds, file-based templates are re-read on each render (hot reload).</p>
<h2 id="template-validation"><a class="header" href="#template-validation">Template Validation</a></h2>
<p>Catch style tag errors without producing output:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout::validate_template;

let result = validate_template(template, &amp;sample_data, &amp;theme);
match result {
    Ok(()) =&gt; println!("Template is valid"),
    Err(e) =&gt; {
        eprintln!("Template errors: {}", e);
        std::process::exit(1);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Use at startup or in tests to fail fast on typos.</p>
<h2 id="context-injection-2"><a class="header" href="#context-injection-2">Context Injection</a></h2>
<h3 id="simple-variables-with-render_with_vars"><a class="header" href="#simple-variables-with-render_with_vars">Simple Variables with <code>render_with_vars</code></a></h3>
<p>For adding simple key-value pairs to the template context:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout::{render_with_vars, Theme, OutputMode};
use std::collections::HashMap;

let theme = Theme::new();

let mut vars = HashMap::new();
vars.insert("version", "1.0.0");
vars.insert("app_name", "MyApp");

let output = render_with_vars(
    "{{ name }} - {{ app_name }} v{{ version }}",
    &amp;data,
    &amp;theme,
    OutputMode::Text,
    vars,
)?;
<span class="boring">}</span></code></pre></pre>
<p>This is the recommended approach for most use cases.</p>
<h3 id="full-context-system"><a class="header" href="#full-context-system">Full Context System</a></h3>
<p>For dynamic context computed at render time:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout::{render_with_context, Theme, OutputMode};
use standout::context::{ContextRegistry, RenderContext};
use minijinja::Value;

let mut context = ContextRegistry::new();
context.add_static("version", Value::from("1.0.0"));
context.add_provider("timestamp", |_ctx: &amp;RenderContext| {
    Value::from(chrono::Utc::now().to_rfc3339())
});

let render_ctx = RenderContext::new(
    OutputMode::Term,
    Some(80),
    &amp;theme,
    &amp;serde_json::to_value(&amp;data)?,
);

let output = render_with_context(
    template,
    &amp;data,
    &amp;theme,
    OutputMode::Term,
    &amp;context,
    &amp;render_ctx,
)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="structured-output-without-templates"><a class="header" href="#structured-output-without-templates">Structured Output Without Templates</a></h2>
<p>For JSON/YAML output, templates are bypassed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout::render_auto;

#[derive(Serialize)]
struct ApiResponse {
    status: String,
    data: Vec&lt;Item&gt;,
}

let response = ApiResponse { ... };

// Direct JSON serialization
let json = render_auto("unused", &amp;response, &amp;theme, OutputMode::Json)?;
println!("{}", json);

// Direct YAML serialization
let yaml = render_auto("unused", &amp;response, &amp;theme, OutputMode::Yaml)?;
<span class="boring">}</span></code></pre></pre>
<p>The template parameter is ignored for structured modes.</p>
<h2 id="minimal-example"><a class="header" href="#minimal-example">Minimal Example</a></h2>
<p>Absolute minimum for styled output:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use standout::{render, Theme};
use console::Style;

let theme = Theme::new().add("ok", Style::new().green());
let output = render("[ok]Success[/ok]", &amp;(), &amp;theme)?;
println!("{}", output);
<span class="boring">}</span></code></pre></pre>
<p>No files, no configuration—just a theme and a template string.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="assets/version-banner.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
